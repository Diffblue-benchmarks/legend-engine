package org.finos.legend.engine.language.pure.grammar.from.antlr4.mapping.pureInstanceClassMapping;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import java.util.ArrayList;
import java.util.List;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.IntStream;
import org.antlr.v4.runtime.InterpreterRuleContext;
import org.antlr.v4.runtime.ListTokenSource;
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenSource;
import org.antlr.v4.runtime.atn.ParserATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.atn.PredictionMode;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.misc.Pair;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.xpath.XPathLexer;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.CodeLexerGrammar;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.CodeParserGrammarBaseVisitor;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.connection.ConnectionLexerGrammar;
import org.junit.Test;

public class PureInstanceClassMappingParserGrammarDiffblueTest {
  @Test
  public void testAllFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionContext actualAllFunctionResult = pureInstanceClassMappingParserGrammar
        .allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionResult.invokingState);
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.start;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(509, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionContext actualAllFunctionResult = pureInstanceClassMappingParserGrammar
        .allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(509, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionContext actualAllFunctionResult = pureInstanceClassMappingParserGrammar
        .allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(510, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionContextALL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testAllFunctionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllFunctionContext allFunctionContext = new PureInstanceClassMappingParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllFunctionContext allFunctionContext = new PureInstanceClassMappingParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);
    allFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(41,
        (new PureInstanceClassMappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllFunctionWithMilestoning() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = pureInstanceClassMappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionWithMilestoningResult.invokingState);
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.start;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionWithMilestoningResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(527, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunctionWithMilestoning2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = pureInstanceClassMappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(527, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoning3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = pureInstanceClassMappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(528, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoningContextALL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .ALL());
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);
    allFunctionWithMilestoningContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllFunctionWithMilestoningContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .COMMA());
  }

  @Test
  public void testAllFunctionWithMilestoningContextDOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .DOT());
  }

  @Test
  public void testAllFunctionWithMilestoningContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(44,
        (new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .PAREN_OPEN());
  }

  @Test
  public void testAllOrFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllOrFunctionContext actualAllOrFunctionResult = pureInstanceClassMappingParserGrammar
        .allOrFunction();

    // Assert
    RecognitionException recognitionException = actualAllOrFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllOrFunctionResult.invokingState);
    assertNull(actualAllOrFunctionResult.getParent());
    Token expectedStart = actualAllOrFunctionResult.start;
    Token start = actualAllOrFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllOrFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(507, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllOrFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllOrFunctionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllOrFunctionContext allOrFunctionContext = new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllOrFunctionContext allOrFunctionContext = new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);
    allOrFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAllFunction() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allFunction());
  }

  @Test
  public void testAllOrFunctionContextAllFunctionWithMilestoning() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1))
        .allFunctionWithMilestoning());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsFunction() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1))
        .allVersionsFunction());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsInRangeFunction() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1))
        .allVersionsInRangeFunction());
  }

  @Test
  public void testAllOrFunctionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters());
  }

  @Test
  public void testAllOrFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(40,
        (new PureInstanceClassMappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsFunctionResult.invokingState);
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.start;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(514, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(514, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(515, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunctionContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1))
        .ALL_VERSIONS());
  }

  @Test
  public void testAllVersionsFunctionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllVersionsFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(42, (new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1))
        .PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1))
        .PAREN_OPEN());
  }

  @Test
  public void testAllVersionsInRangeFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsInRangeFunctionResult.invokingState);
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.start;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(519, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsInRangeFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(519, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = pureInstanceClassMappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(520, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsInRangeFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .COMMA());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .DOT());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(43,
        (new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .PAREN_OPEN());
  }

  @Test
  public void testArithmeticPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ArithmeticPartContext actualArithmeticPartResult = pureInstanceClassMappingParserGrammar
        .arithmeticPart();

    // Assert
    RecognitionException recognitionException = actualArithmeticPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualArithmeticPartResult.invokingState);
    assertNull(actualArithmeticPartResult.getParent());
    Token expectedStart = actualArithmeticPartResult.start;
    Token start = actualArithmeticPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualArithmeticPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(710, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualArithmeticPartResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testArithmeticPartContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ArithmeticPartContext arithmeticPartContext = new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ArithmeticPartContext arithmeticPartContext = new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);
    arithmeticPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextDIVIDE() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE(1));
  }

  @Test
  public void testArithmeticPartContextExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testArithmeticPartContextGREATER_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1))
        .GREATER_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testArithmeticPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(59,
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testArithmeticPartContextLESS_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testArithmeticPartContextMINUS() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS(1));
  }

  @Test
  public void testArithmeticPartContextPLUS() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS(1));
  }

  @Test
  public void testArithmeticPartContextSTAR() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR(1));
  }

  @Test
  public void testAtomicExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(475, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[478 471]", getResult1.toString());
    assertEquals(478, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testAtomicExpression8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(475, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = pureInstanceClassMappingParserGrammar
        .atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(475, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpressionContextAT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testAtomicExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext atomicExpressionContext = new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.AtomicExpressionContext atomicExpressionContext = new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);
    atomicExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextDsl() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).dsl());
  }

  @Test
  public void testAtomicExpressionContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1))
        .expressionInstance());
  }

  @Test
  public void testAtomicExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(36,
        (new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAtomicExpressionContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1))
        .instanceLiteralToken());
  }

  @Test
  public void testAtomicExpressionContextInstanceReference() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1))
        .instanceReference());
  }

  @Test
  public void testAtomicExpressionContextLambdaFunction() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1))
        .lambdaFunction());
  }

  @Test
  public void testAtomicExpressionContextLambdaParam() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaParam());
  }

  @Test
  public void testAtomicExpressionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testAtomicExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testAtomicExpressionContextUnitInstance() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).unitInstance());
  }

  @Test
  public void testAtomicExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testBooleanPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.BooleanPartContext actualBooleanPartResult = pureInstanceClassMappingParserGrammar
        .booleanPart();

    // Assert
    RecognitionException recognitionException = actualBooleanPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBooleanPartResult.invokingState);
    assertNull(actualBooleanPartResult.getParent());
    Token expectedStart = actualBooleanPartResult.start;
    Token start = actualBooleanPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBooleanPartResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(717, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualBooleanPartResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBooleanPartContextAND() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).AND());
  }

  @Test
  public void testBooleanPartContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.BooleanPartContext booleanPartContext = new PureInstanceClassMappingParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.BooleanPartContext booleanPartContext = new PureInstanceClassMappingParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);
    booleanPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testBooleanPartContextExpression() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testBooleanPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(60,
        (new PureInstanceClassMappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testBooleanPartContextOR() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).OR());
  }

  @Test
  public void testBuildMilestoningVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext actualBuildMilestoningVariableExpressionResult = pureInstanceClassMappingParserGrammar
        .buildMilestoningVariableExpression();

    // Assert
    RecognitionException recognitionException = actualBuildMilestoningVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBuildMilestoningVariableExpressionResult.invokingState);
    assertEquals(1, actualBuildMilestoningVariableExpressionResult.depth());
    Token expectedStart = actualBuildMilestoningVariableExpressionResult.start;
    Token start = actualBuildMilestoningVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBuildMilestoningVariableExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(540, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualBuildMilestoningVariableExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);
    buildMilestoningVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextDATE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(),
            1)).DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(45,
        (new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(),
            1)).getRuleIndex());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(),
            1)).LATEST_DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(),
            1)).variable());
  }

  @Test
  public void testCodeBlock() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = pureInstanceClassMappingParserGrammar
        .codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = pureInstanceClassMappingParserGrammar
        .codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = pureInstanceClassMappingParserGrammar
        .codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(369, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = pureInstanceClassMappingParserGrammar
        .codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.CodeBlockContext actualCodeBlockResult = pureInstanceClassMappingParserGrammar
        .codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlockContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CodeBlockContext codeBlockContext = new PureInstanceClassMappingParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CodeBlockContext codeBlockContext = new PureInstanceClassMappingParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);
    codeBlockContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(21,
        (new PureInstanceClassMappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCodeBlockContextProgramLine() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine(1));
  }

  @Test
  public void testCodeBlockContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON(1));
  }

  @Test
  public void testCombinedArithmeticOnly() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([376] [399 376])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedArithmeticOnly10() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = pureInstanceClassMappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([376] [399 376])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedArithmeticOnly11() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = pureInstanceClassMappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([376] [399 376])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedArithmeticOnly2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(24));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(28));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly6() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = pureInstanceClassMappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = pureInstanceClassMappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnly9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = pureInstanceClassMappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);
    combinedArithmeticOnlyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextArithmeticPart() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
        .arithmeticPart()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
        .arithmeticPart(1));
  }

  @Test
  public void testCombinedArithmeticOnlyContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
        .expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedArithmeticOnlyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(24,
        (new PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testCombinedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([392] [399 392])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedExpression10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = pureInstanceClassMappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([392] [399 392])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(28));

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = pureInstanceClassMappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = pureInstanceClassMappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = pureInstanceClassMappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(399, expressionResult.invokingState);
    assertEquals(3, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    Interval expectedSourceInterval = actualCombinedExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, expressionResult.getSourceInterval());
  }

  @Test
  public void testCombinedExpression9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = pureInstanceClassMappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([392] [399 392])", getResult.toStringTree());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
  }

  @Test
  public void testCombinedExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext combinedExpressionContext = new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.CombinedExpressionContext combinedExpressionContext = new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);
    combinedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1))
        .expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedExpressionContextExpressionPart() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1))
        .expressionPart()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1))
        .expressionPart(1));
  }

  @Test
  public void testCombinedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(27, (new PureInstanceClassMappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testConstructor() {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar actualPureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(new ArrayList<Token>())));

    // Assert
    assertNull(actualPureInstanceClassMappingParserGrammar.getParseInfo());
    assertEquals(0, actualPureInstanceClassMappingParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualPureInstanceClassMappingParserGrammar.isMatchedEOF());
    assertNull(actualPureInstanceClassMappingParserGrammar.getContext());
    assertTrue(actualPureInstanceClassMappingParserGrammar
        .getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualPureInstanceClassMappingParserGrammar.getPrecedence());
    assertEquals("List", actualPureInstanceClassMappingParserGrammar.getSourceName());
    assertFalse(actualPureInstanceClassMappingParserGrammar.isTrace());
    assertTrue(actualPureInstanceClassMappingParserGrammar.getBuildParseTree());
    assertEquals(-1, actualPureInstanceClassMappingParserGrammar.getState());
    assertTrue(actualPureInstanceClassMappingParserGrammar
        .getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualPureInstanceClassMappingParserGrammar.getInterpreter();
    assertSame(actualPureInstanceClassMappingParserGrammar, interpreter.getParser());
    assertEquals(93, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualPureInstanceClassMappingParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualPureInstanceClassMappingParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testConstructor2() {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar actualPureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Assert
    assertNull(actualPureInstanceClassMappingParserGrammar.getParseInfo());
    assertEquals(0, actualPureInstanceClassMappingParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualPureInstanceClassMappingParserGrammar.isMatchedEOF());
    assertNull(actualPureInstanceClassMappingParserGrammar.getContext());
    assertTrue(actualPureInstanceClassMappingParserGrammar
        .getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualPureInstanceClassMappingParserGrammar.getPrecedence());
    assertEquals("List", actualPureInstanceClassMappingParserGrammar.getSourceName());
    assertFalse(actualPureInstanceClassMappingParserGrammar.isTrace());
    assertTrue(actualPureInstanceClassMappingParserGrammar.getBuildParseTree());
    assertEquals(-1, actualPureInstanceClassMappingParserGrammar.getState());
    assertTrue(actualPureInstanceClassMappingParserGrammar
        .getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualPureInstanceClassMappingParserGrammar.getInterpreter();
    assertSame(actualPureInstanceClassMappingParserGrammar, interpreter.getParser());
    assertEquals(93, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualPureInstanceClassMappingParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualPureInstanceClassMappingParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testContravarianceTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(820, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.stop;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertSame(start, actualContravarianceTypeParameterResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult
        .identifier();
    assertEquals(822, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.stop;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertSame(start, actualContravarianceTypeParameterResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult
        .identifier();
    assertEquals(822, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter4() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(
        new ConnectionLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(820, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testContravarianceTypeParameter5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.stop;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertSame(start, actualContravarianceTypeParameterResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult
        .identifier();
    assertEquals(822, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.stop;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertSame(start, actualContravarianceTypeParameterResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult
        .identifier();
    assertEquals(822, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(820, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameterContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(76,
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testContravarianceTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1))
            .identifier());
  }

  @Test
  public void testContravarianceTypeParameterContextMINUS() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1))
            .MINUS());
  }

  @Test
  public void testContravarianceTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testContravarianceTypeParameters3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testContravarianceTypeParameters4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [811])", actualContravarianceTypeParametersResult.toStringTree());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertTrue(((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(811, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testContravarianceTypeParameters5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testContravarianceTypeParameters6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(52));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testContravarianceTypeParameters7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = pureInstanceClassMappingParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(
        ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
            .COMMA()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
            .COMMA(1));
  }

  @Test
  public void testContravarianceTypeParametersContextContravarianceTypeParameter() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
            .contravarianceTypeParameter()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
            .contravarianceTypeParameter(1));
  }

  @Test
  public void testContravarianceTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(75,
        (new PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testDsl() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslContext actualDslResult = pureInstanceClassMappingParserGrammar.dsl();

    // Assert
    RecognitionException recognitionException = actualDslResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDslResult.invokingState);
    assertNull(actualDslResult.getParent());
    Token expectedStart = actualDslResult.start;
    Token start = actualDslResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(726, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDslContent() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));

    // Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = pureInstanceClassMappingParserGrammar
        .dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testDslContent2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = pureInstanceClassMappingParserGrammar
        .dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("null", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(737, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslContent3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = pureInstanceClassMappingParserGrammar
        .dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(737, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testDslContent5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = pureInstanceClassMappingParserGrammar
        .dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(737, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslContentContext actualDslContentResult = pureInstanceClassMappingParserGrammar
        .dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testDslContentContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslContentContext dslContentContext = new PureInstanceClassMappingParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslContentContext dslContentContext = new PureInstanceClassMappingParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);
    dslContentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(65,
        (new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_CLOSE());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_OPEN());
  }

  @Test
  public void testDslContentContextISLAND_CONTENT() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_CONTENT());
  }

  @Test
  public void testDslContentContextISLAND_END() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_END());
  }

  @Test
  public void testDslContentContextISLAND_HASH() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_HASH());
  }

  @Test
  public void testDslContentContextISLAND_START() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_START());
  }

  @Test
  public void testDslContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslContext dslContext = new PureInstanceClassMappingParserGrammar.DslContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslContext dslContext = new PureInstanceClassMappingParserGrammar.DslContext(
        new ParserRuleContext(), 1);
    dslContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextDslGraphFetch() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.DslContext(new ParserRuleContext(), 1)).dslGraphFetch());
  }

  @Test
  public void testDslContextDslNavigationPath() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.DslContext(new ParserRuleContext(), 1)).dslNavigationPath());
  }

  @Test
  public void testDslContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(62, (new PureInstanceClassMappingParserGrammar.DslContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetch() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<12>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(12, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetch2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = pureInstanceClassMappingParserGrammar
        .dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("null", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(730, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslGraphFetch3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = pureInstanceClassMappingParserGrammar
        .dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(730, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals("<missing ISLAND_OPEN>", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslGraphFetch5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = pureInstanceClassMappingParserGrammar
        .dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(730, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = pureInstanceClassMappingParserGrammar
        .dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<12>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(12, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetchContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext dslGraphFetchContext = new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslGraphFetchContext dslGraphFetchContext = new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);
    dslGraphFetchContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextDslContent() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent(1));
  }

  @Test
  public void testDslGraphFetchContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(64,
        (new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetchContextISLAND_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).ISLAND_OPEN());
  }

  @Test
  public void testDslNavigationPath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<8>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(8, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = pureInstanceClassMappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("null", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(728, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslNavigationPath3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = pureInstanceClassMappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(728, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslNavigationPath5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = pureInstanceClassMappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(728, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = pureInstanceClassMappingParserGrammar
        .dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<8>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(8, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPathContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext dslNavigationPathContext = new PureInstanceClassMappingParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.DslNavigationPathContext dslNavigationPathContext = new PureInstanceClassMappingParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);
    dslNavigationPathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(63, (new PureInstanceClassMappingParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testDslNavigationPathContextNAVIGATION_PATH_BLOCK() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1))
        .NAVIGATION_PATH_BLOCK());
  }

  @Test
  public void testEnumReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = pureInstanceClassMappingParserGrammar
        .enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumReferenceResult.identifier());
    assertNull(actualEnumReferenceResult.getStop());
    assertTrue(actualEnumReferenceResult.isEmpty());
    assertEquals("([] [342])", actualEnumReferenceResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(343, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1, tokenSource.getLine());
    assertEquals(342,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testEnumReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = pureInstanceClassMappingParserGrammar
        .enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.stop;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumReferenceResult.identifier());
    assertSame(start, actualEnumReferenceResult.getStop());
    assertEquals("null", actualEnumReferenceResult.getText());
    assertTrue(actualEnumReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(343, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(342,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).enumReference();

    // Assert
    assertEquals(-1, actualEnumReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualEnumReferenceResult.getChildCount());
    Token expectedStop = actualEnumReferenceResult.stop;
    Token stop = actualEnumReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualEnumReferenceResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualEnumReferenceResult.identifier();
    assertEquals(344, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(342,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReferenceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.EnumReferenceContext enumReferenceContext = new PureInstanceClassMappingParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.EnumReferenceContext enumReferenceContext = new PureInstanceClassMappingParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);
    enumReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextDOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testEnumReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(17,
        (new PureInstanceClassMappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEnumReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testEnumReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testEqualNotEqual() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = pureInstanceClassMappingParserGrammar
        .equalNotEqual();

    // Assert
    RecognitionException recognitionException = actualEqualNotEqualResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.start;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEqualNotEqualResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(373, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualEqualNotEqualResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testEqualNotEqual2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).equalNotEqual();

    // Assert
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    List<ParseTree> parseTreeList = actualEqualNotEqualResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.stop;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEqualNotEqualResult.getStop());
    assertEquals(1, actualEqualNotEqualResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedArithmeticOnlyContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([374] ([376 374] ([399 376 374] ([232 399 376 374] ([471 232 399 376 374] ([478 471 232 399 376 374]"
        + " ([863 478 471 232 399 376 374] <EOF>)))))))", getResult.toStringTree());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testEqualNotEqualContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.EqualNotEqualContext equalNotEqualContext = new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.EqualNotEqualContext equalNotEqualContext = new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);
    equalNotEqualContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextCombinedArithmeticOnly() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1))
        .combinedArithmeticOnly());
  }

  @Test
  public void testEqualNotEqualContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(23,
        (new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEqualNotEqualContextTEST_EQUAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_EQUAL());
  }

  @Test
  public void testEqualNotEqualContextTEST_NOT_EQUAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_NOT_EQUAL());
  }

  @Test
  public void testExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(251, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression10() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(251, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression11() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(251, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(251, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testExpression4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(8));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    PureInstanceClassMappingParserGrammar.DslContext dslResult = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult)
        .dsl();
    assertSame(start, dslResult.getStop());
    assertFalse(dslResult.isEmpty());
    assertEquals("[462 232]", dslResult.toString());
    assertEquals(1, dslResult.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, dslResult.getSourceInterval());
  }

  @Test
  public void testExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression6() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionContext actualExpressionResult = pureInstanceClassMappingParserGrammar
        .expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[471 232]", getResult1.toString());
    assertEquals(471, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionContext = new PureInstanceClassMappingParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionContext = new PureInstanceClassMappingParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);
    expressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAtomicExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).atomicExpression());
  }

  @Test
  public void testExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testExpressionContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testExpressionContextExpressionsArray() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).expressionsArray());
  }

  @Test
  public void testExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(8,
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionContextNotExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).notExpression());
  }

  @Test
  public void testExpressionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testExpressionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionContextPropertyOrFunctionExpression() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1))
        .propertyOrFunctionExpression()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1))
        .propertyOrFunctionExpression(1));
  }

  @Test
  public void testExpressionContextSignedExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).signedExpression());
  }

  @Test
  public void testExpressionContextSliceExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).sliceExpression());
  }

  @Test
  public void testExpressionInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = pureInstanceClassMappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceResult.invokingState);
    assertEquals(1, actualExpressionInstanceResult.depth());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(542, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = pureInstanceClassMappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.variable());
    assertTrue(actualExpressionInstanceResult.isEmpty());
    assertEquals(1, actualExpressionInstanceResult.depth());
    Token expectedStart = actualExpressionInstanceResult.stop;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals("<missing '^'><EOF>", actualExpressionInstanceResult.getText());
    assertSame(start, actualExpressionInstanceResult.getStop());
    assertEquals("([] <missing '^'> ([544] ([863 544] <EOF>)))", actualExpressionInstanceResult.toStringTree());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(556, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualExpressionInstanceResult, getResult.getParent());
    assertEquals(544,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<missing '^'>", getResult.toString());
  }

  @Test
  public void testExpressionInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = pureInstanceClassMappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.variable());
    assertTrue(actualExpressionInstanceResult.isEmpty());
    assertEquals(1, actualExpressionInstanceResult.depth());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals("<missing '^'><EOF>null", actualExpressionInstanceResult.getText());
    Token expectedStop = actualExpressionInstanceResult.stop;
    Token stop = actualExpressionInstanceResult.getStop();
    assertSame(expectedStop, stop);
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualExpressionInstanceResult
        .identifier();
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(561, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(stop, identifierResult.getStart());
    assertEquals(0, start.getTokenIndex());
    assertEquals(544,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(579, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(579, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(579, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
            .combinedExpression());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
            .expressionInstance());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(48,
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
            .qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceContext expressionInstanceContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceContext expressionInstanceContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);
    expressionInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionInstanceContextExpressionInstanceParserPropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment(1));
  }

  @Test
  public void testExpressionInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .GREATER_THAN());
  }

  @Test
  public void testExpressionInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(46, (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testExpressionInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testExpressionInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testExpressionInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .multiplicityArguments());
  }

  @Test
  public void testExpressionInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testExpressionInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .PAREN_CLOSE());
  }

  @Test
  public void testExpressionInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testExpressionInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .typeArguments());
  }

  @Test
  public void testExpressionInstanceContextVariable() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.start;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    assertEquals("([] [581])", actualExpressionInstanceParserPropertyAssignmentResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(592, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(581, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertTrue(((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(586, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(581, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(592, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(581, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertTrue(((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);
    expressionInstanceParserPropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextDOT() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).DOT().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).DOT(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextExpressionInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).expressionInstanceRightSide());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(49, (new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testExpressionInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(47));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(576, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
            .depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0))
        .getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextExpressionInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1))
            .expressionInstanceAtomicRightSide());
  }

  @Test
  public void testExpressionInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(47,
        (new PureInstanceClassMappingParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testExpressionOrExpressionGroup() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertEquals(2, expressionResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
    assertNull(expressionResult.getStop());
    assertSame(start, expressionResult.getStart());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(expressionResult, recognitionException.getCtx());
    assertEquals(251, recognitionException.getOffendingState());
  }

  @Test
  public void testExpressionOrExpressionGroup10() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = pureInstanceClassMappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup11() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = pureInstanceClassMappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertEquals(2, expressionResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
    assertNull(expressionResult.getStop());
    assertSame(start, expressionResult.getStart());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(expressionResult, recognitionException.getCtx());
    assertEquals(251, recognitionException.getOffendingState());
  }

  @Test
  public void testExpressionOrExpressionGroup12() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = pureInstanceClassMappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertEquals(2, expressionResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
    assertNull(expressionResult.getStop());
    assertSame(start, expressionResult.getStart());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(expressionResult, recognitionException.getCtx());
    assertEquals(251, recognitionException.getOffendingState());
  }

  @Test
  public void testExpressionOrExpressionGroup2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup3() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream())))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertEquals(2, expressionResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(399, expressionResult.invokingState);
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertNull(expressionResult.getStop());
    assertSame(start, expressionResult.getStart());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(251, recognitionException.getOffendingState());
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testExpressionOrExpressionGroup4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(28));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(233, ((PureInstanceClassMappingParserGrammar.NotExpressionContext) getResult).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.NotExpressionContext) getResult).depth());
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.NotExpressionContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(8));

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup7() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = pureInstanceClassMappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = pureInstanceClassMappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult
        .expression();
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals("null", expressionResult.getText());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[232 399]", getResult.toString());
    assertEquals(232, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) getResult).variable());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);
    expressionOrExpressionGroupContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1))
            .expression());
  }

  @Test
  public void testExpressionOrExpressionGroupContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(28,
        (new PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testExpressionPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionPartContext actualExpressionPartResult = pureInstanceClassMappingParserGrammar
        .expressionPart();

    // Assert
    RecognitionException recognitionException = actualExpressionPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionPartResult.invokingState);
    assertNull(actualExpressionPartResult.getParent());
    Token expectedStart = actualExpressionPartResult.start;
    Token start = actualExpressionPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(385, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionPartResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionPartContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionPartContext expressionPartContext = new PureInstanceClassMappingParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionPartContext expressionPartContext = new PureInstanceClassMappingParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);
    expressionPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextArithmeticPart() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).arithmeticPart());
  }

  @Test
  public void testExpressionPartContextBooleanPart() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).booleanPart());
  }

  @Test
  public void testExpressionPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(25,
        (new PureInstanceClassMappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionsArray() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = pureInstanceClassMappingParserGrammar
        .expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionsArrayResult.invokingState);
    assertNull(actualExpressionsArrayResult.getParent());
    Token expectedStart = actualExpressionsArrayResult.start;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionsArrayResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(401, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testExpressionsArray2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = pureInstanceClassMappingParserGrammar
        .expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionsArrayResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualExpressionsArrayResult.depth());
    Token expectedStart = actualExpressionsArrayResult.stop;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualExpressionsArrayResult.getChildCount());
    assertSame(start, actualExpressionsArrayResult.getStop());
    assertEquals("<missing '['><EOF>", actualExpressionsArrayResult.getText());
    assertTrue(actualExpressionsArrayResult.isEmpty());
    assertEquals(
        "([] <missing '['> ([402] ([232 402] ([471 232 402] ([478 471 232 402] ([863 478 471 232 402]" + " <EOF>))))))",
        actualExpressionsArrayResult.toStringTree());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(407, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, offendingToken.getType());
    assertEquals(402, ((PureInstanceClassMappingParserGrammar.ExpressionContext) parseTreeList.get(1)).invokingState);
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(0, offendingToken.getChannel());
  }

  @Test
  public void testExpressionsArrayContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionsArrayContext expressionsArrayContext = new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ExpressionsArrayContext expressionsArrayContext = new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);
    expressionsArrayContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1))
        .BRACKET_CLOSE());
  }

  @Test
  public void testExpressionsArrayContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testExpressionsArrayContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionsArrayContextExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testExpressionsArrayContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(29,
        (new PureInstanceClassMappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<17>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(17, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = pureInstanceClassMappingParserGrammar
        .fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("null", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(774, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFromMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = pureInstanceClassMappingParserGrammar
        .fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(774, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals("<missing INTEGER>", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testFromMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = pureInstanceClassMappingParserGrammar
        .fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(774, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = pureInstanceClassMappingParserGrammar
        .fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<17>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(17, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicityContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext fromMultiplicityContext = new PureInstanceClassMappingParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FromMultiplicityContext fromMultiplicityContext = new PureInstanceClassMappingParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);
    fromMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(68,
        (new PureInstanceClassMappingParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = pureInstanceClassMappingParserGrammar
        .functionExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    assertNull(actualFunctionExpressionResult.getParent());
    Token expectedStart = actualFunctionExpressionResult.start;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(429, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionExpression();

    // Assert
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualFunctionExpressionResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '->'> ([430] ([863 430] <EOF>)) [431])", actualFunctionExpressionResult.toStringTree());
    assertNull(actualFunctionExpressionResult.getParent());
    Token token = actualFunctionExpressionResult.stop;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualFunctionExpressionResult.getStop());
    assertEquals("<missing '->'><EOF>", actualFunctionExpressionResult.getText());
    assertEquals(3, actualFunctionExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(431, ((PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext) parseTreeList
        .get(2)).invokingState);
    assertTrue(((PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2))
        .getStart() instanceof CommonToken);
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).getStop());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    assertEquals(430, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    Interval expectedSourceInterval = actualFunctionExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertTrue(((PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext) parseTreeList
        .get(2)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[430]", getResult.toString());
  }

  @Test
  public void testFunctionExpressionContextARROW() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW(1));
  }

  @Test
  public void testFunctionExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionContext functionExpressionContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionContext functionExpressionContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);
    functionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters(1));
  }

  @Test
  public void testFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(33, (new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testFunctionExpressionContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .qualifiedName()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .qualifiedName(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = pureInstanceClassMappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionLatestMilestoningDateParameterResult.invokingState);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.start;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(441, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = pureInstanceClassMappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(441, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(39));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = pureInstanceClassMappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(442, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);
    functionExpressionLatestMilestoningDateParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(34, (new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).LATEST_DATE().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).LATEST_DATE(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testFunctionExpressionParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = pureInstanceClassMappingParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionParametersResult.invokingState);
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.start;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(449, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = pureInstanceClassMappingParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualFunctionExpressionParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.stop;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionParametersResult.getStop());
    assertEquals("<missing '('><EOF>", actualFunctionExpressionParametersResult.getText());
    assertEquals(2, actualFunctionExpressionParametersResult.getChildCount());
    assertTrue(actualFunctionExpressionParametersResult.isEmpty());
    assertEquals(
        "([] <missing '('> ([450] ([392 450] ([399 392 450] ([232 399 392 450] ([471 232 399 392 450] ([478 471"
            + " 232 399 392 450] ([863 478 471 232 399 392 450] <EOF>))))))))",
        actualFunctionExpressionParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(455, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(450,
        ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testFunctionExpressionParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);
    functionExpressionParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .COMMA()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .COMMA(1));
  }

  @Test
  public void testFunctionExpressionParametersContextCombinedExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .combinedExpression()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .combinedExpression(1));
  }

  @Test
  public void testFunctionExpressionParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(35,
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
            .PAREN_OPEN());
  }

  @Test
  public void testFunctionTypePureType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionTypePureTypeResult.getStop());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult
        .multiplicity();
    assertEquals(779, multiplicityResult.invokingState);
    assertNull(multiplicityResult.getStop());
    assertEquals("[779]", multiplicityResult.toString());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(778, typeResult.invokingState);
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertNull(typeResult.getStop());
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
  }

  @Test
  public void testFunctionTypePureType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token token = actualFunctionTypePureTypeResult.stop;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualFunctionTypePureTypeResult.getStop());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult
        .multiplicity();
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(779, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[779]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(1, typeResult.getChildCount());
    assertEquals(778, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
  }

  @Test
  public void testFunctionTypePureType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    assertSame(expectedStop, actualFunctionTypePureTypeResult.getStop());
    assertEquals("null<missing '['><EOF><missing ']'>", actualFunctionTypePureTypeResult.getText());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    assertEquals(779, actualFunctionTypePureTypeResult.multiplicity().invokingState);
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(778, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testFunctionTypePureType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    assertSame(expectedStop, actualFunctionTypePureTypeResult.getStop());
    assertEquals("null<missing '['><EOF>null", actualFunctionTypePureTypeResult.getText());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult
        .multiplicity();
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(779, multiplicityResult.invokingState);
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(778, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testFunctionTypePureTypeContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);
    functionTypePureTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(70, (new PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testFunctionTypePureTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1))
        .multiplicity());
  }

  @Test
  public void testFunctionTypePureTypeContextType() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testFunctionVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = pureInstanceClassMappingParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    assertNull(actualFunctionVariableExpressionResult.type());
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionVariableExpressionResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult
        .identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertNull(identifierResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(720, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
    assertEquals(-1, start.getType());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testFunctionVariableExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = pureInstanceClassMappingParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    Token expectedStart = actualFunctionVariableExpressionResult.stop;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualFunctionVariableExpressionResult.getChildCount());
    assertSame(start, actualFunctionVariableExpressionResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult
        .identifier();
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualFunctionVariableExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(720, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
  }

  @Test
  public void testFunctionVariableExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionVariableExpression();

    // Assert
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertEquals(4, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(4, actualFunctionVariableExpressionResult.getChildCount());
    Token expectedStop = actualFunctionVariableExpressionResult.stop;
    Token stop = actualFunctionVariableExpressionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing ':'><EOF>", actualFunctionVariableExpressionResult.getText());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionVariableExpressionResult
        .multiplicity();
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(722, multiplicityResult.invokingState);
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult
        .identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualFunctionVariableExpressionResult.type();
    assertNull(typeResult.type());
    assertEquals(721, typeResult.invokingState);
    assertEquals("([721] ([739 721] ([863 739 721] <EOF>)))", typeResult.toStringTree());
    assertEquals("<EOF>", typeResult.getText());
    assertSame(stop, typeResult.getStart());
    assertSame(stop, typeResult.getStop());
    assertEquals("null", identifierResult.getText());
    assertEquals(2, typeResult.depth());
  }

  @Test
  public void testFunctionVariableExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);
    functionVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1))
        .COLON());
  }

  @Test
  public void testFunctionVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(61,
        (new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testFunctionVariableExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1))
        .identifier());
  }

  @Test
  public void testFunctionVariableExpressionContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1))
        .multiplicity());
  }

  @Test
  public void testFunctionVariableExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1))
        .type());
  }

  @Test
  public void testIdentifier() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));

    // Act
    PureInstanceClassMappingParserGrammar.IdentifierContext actualIdentifierResult = pureInstanceClassMappingParserGrammar
        .identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Act
    PureInstanceClassMappingParserGrammar.IdentifierContext actualIdentifierResult = pureInstanceClassMappingParserGrammar
        .identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier3() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));

    // Act
    PureInstanceClassMappingParserGrammar.IdentifierContext actualIdentifierResult = pureInstanceClassMappingParserGrammar
        .identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.IdentifierContext actualIdentifierResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testIdentifier5() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.IdentifierContext actualIdentifierResult = pureInstanceClassMappingParserGrammar
        .identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testIdentifierContextALL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL_VERSIONS());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1))
        .ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testIdentifierContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierContext = new PureInstanceClassMappingParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierContext = new PureInstanceClassMappingParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);
    identifierContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextENUMERATION_MAPPING() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1))
        .ENUMERATION_MAPPING());
  }

  @Test
  public void testIdentifierContextLET() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testIdentifierContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testIdentifierContextVALID_STRING() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).VALID_STRING());
  }

  @Test
  public void testInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceContext actualInstanceResult = pureInstanceClassMappingParserGrammar
        .instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceResult.invokingState);
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(253, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceContext actualInstanceResult = pureInstanceClassMappingParserGrammar
        .instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.stop;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceResult.identifier());
    assertSame(start, actualInstanceResult.getStop());
    assertEquals("<missing '^'><EOF>", actualInstanceResult.getText());
    assertTrue(actualInstanceResult.isEmpty());
    assertEquals("([] <missing '^'> ([254] ([863 254] <EOF>)))", actualInstanceResult.toStringTree());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(264, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, offendingToken.getType());
    assertEquals(254,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(1, offendingToken.getStopIndex());
  }

  @Test
  public void testInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceContext actualInstanceResult = pureInstanceClassMappingParserGrammar
        .instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualInstanceResult.getChildCount());
    Token expectedStop = actualInstanceResult.stop;
    Token stop = actualInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '^'><EOF>null", actualInstanceResult.getText());
    assertTrue(actualInstanceResult.isEmpty());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualInstanceResult.identifier();
    assertEquals(266, identifierResult.invokingState);
    assertEquals("null", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(283, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals("[@0,1:1='<EOF>',<1>,channel=1,1:0]", start.toString());
    assertEquals(254,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(340, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.instance());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 335]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(340, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(340, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextEnumReference() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .enumReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(16,
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .identifier());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstance() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .instance());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .instanceLiteral());
  }

  @Test
  public void testInstanceAtomicRightSideContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .LATEST_DATE());
  }

  @Test
  public void testInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .qualifiedName());
  }

  @Test
  public void testInstanceAtomicRightSideContextStereotypeReference() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .stereotypeReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextTagReference() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .tagReference());
  }

  @Test
  public void testInstanceAtomicRightSideScalar() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(14));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[332 317]", getResult1.toString());
    assertEquals(332, ((PureInstanceClassMappingParserGrammar.InstanceLiteralContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceLiteralContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).instance());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[335 317]", getResult1.toString());
    assertEquals(335, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).identifier().invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideScalar9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideScalarContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(14,
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1))
            .instanceAtomicRightSide());
  }

  @Test
  public void testInstanceAtomicRightSideVector() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideVectorResult.invokingState);
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.start;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(319, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceAtomicRightSideVector2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = pureInstanceClassMappingParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideVectorResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.stop;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals("<missing '['><EOF>", actualInstanceAtomicRightSideVectorResult.getText());
    assertEquals(2, actualInstanceAtomicRightSideVectorResult.getChildCount());
    assertTrue(actualInstanceAtomicRightSideVectorResult.isEmpty());
    assertEquals("([] <missing '['> ([320] ([335 320] ([863 335 320] <EOF>))))",
        actualInstanceAtomicRightSideVectorResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(325, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(320,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideVectorContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .BRACKET_CLOSE());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .BRACKET_OPEN());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .COMMA()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .COMMA(1));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(15,
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .instanceAtomicRightSide()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
            .instanceAtomicRightSide(1));
  }

  @Test
  public void testInstanceContextAT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testInstanceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceContext instanceContext = new PureInstanceClassMappingParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceContext instanceContext = new PureInstanceClassMappingParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);
    instanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testInstanceContextFILE_NAME() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME());
  }

  @Test
  public void testInstanceContextFILE_NAME_END() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME_END());
  }

  @Test
  public void testInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(9,
        (new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceContextINTEGER() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER(1));
  }

  @Test
  public void testInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstanceContextInstancePropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1))
        .instancePropertyAssignment()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1))
        .instancePropertyAssignment(1));
  }

  @Test
  public void testInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1))
        .multiplicityArguments());
  }

  @Test
  public void testInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralContext actualInstanceLiteralResult = pureInstanceClassMappingParserGrammar
        .instanceLiteral();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceLiteralResult.invokingState);
    assertNull(actualInstanceLiteralResult.getParent());
    Token expectedStart = actualInstanceLiteralResult.start;
    Token start = actualInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(642, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceLiteral2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralContext actualInstanceLiteralResult = pureInstanceClassMappingParserGrammar
        .instanceLiteral();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralResult.children.size());
    assertNull(actualInstanceLiteralResult.getParent());
    Token expectedStart = actualInstanceLiteralResult.stop;
    Token start = actualInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralResult.getStop());
    assertEquals("null", actualInstanceLiteralResult.getText());
    assertEquals(1, actualInstanceLiteralResult.getChildCount());
    assertTrue(actualInstanceLiteralResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(642, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testInstanceLiteralContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceLiteralContext instanceLiteralContext = new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceLiteralContext instanceLiteralContext = new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);
    instanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(56,
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1))
        .instanceLiteralToken());
  }

  @Test
  public void testInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testInstanceLiteralToken() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = pureInstanceClassMappingParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralToken2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = pureInstanceClassMappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("null", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(644, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testInstanceLiteralToken3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = pureInstanceClassMappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(644, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testInstanceLiteralToken5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = pureInstanceClassMappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(644, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = pureInstanceClassMappingParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralTokenContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);
    instanceLiteralTokenContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testInstanceLiteralTokenContextDATE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DATE());
  }

  @Test
  public void testInstanceLiteralTokenContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralTokenContextFLOAT() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralTokenContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(57, (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testInstanceLiteralTokenContextINTEGER() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralTokenContextSTRING() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testInstancePropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = pureInstanceClassMappingParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertNull(actualInstancePropertyAssignmentResult.getStop());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult
        .identifier();
    assertEquals(309, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(310, recognitionException.getOffendingState());
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStartIndex());
    assertEquals("[@0,-1:-1='EOF',<-1>,1:0]", start.toString());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(-1, start.getType());
    assertEquals(-1, start.getStopIndex());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstancePropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = pureInstanceClassMappingParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.stop;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertSame(start, actualInstancePropertyAssignmentResult.getStop());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult
        .identifier();
    assertEquals(309, identifierResult.invokingState);
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(310, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("[@0,0:0='<no text>',<1>,0:-1]", start.toString());
  }

  @Test
  public void testInstancePropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instancePropertyAssignment();

    // Assert
    assertEquals(-1, actualInstancePropertyAssignmentResult.invokingState);
    List<ParseTree> parseTreeList = actualInstancePropertyAssignmentResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualInstancePropertyAssignmentResult.getChildCount());
    Token expectedStop = actualInstancePropertyAssignmentResult.stop;
    Token stop = actualInstancePropertyAssignmentResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '='><EOF>", actualInstancePropertyAssignmentResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(309, identifierResult.invokingState);
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(311,
        ((PureInstanceClassMappingParserGrammar.InstanceRightSideContext) parseTreeList.get(2)).invokingState);
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);
    instancePropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1))
        .EQUAL());
  }

  @Test
  public void testInstancePropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(12,
        (new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testInstancePropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1))
        .identifier());
  }

  @Test
  public void testInstancePropertyAssignmentContextInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1))
        .instanceRightSide());
  }

  @Test
  public void testInstanceReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(480, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(480, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(480, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testInstanceReference4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testInstanceReference9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = pureInstanceClassMappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(480, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReferenceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext instanceReferenceContext = new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceReferenceContext instanceReferenceContext = new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);
    instanceReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAllOrFunction() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1))
        .allOrFunction());
  }

  @Test
  public void testInstanceReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(37, (new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testInstanceReferenceContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1))
        .PATH_SEPARATOR());
  }

  @Test
  public void testInstanceReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1))
        .qualifiedName());
  }

  @Test
  public void testInstanceReferenceContextUnitName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(315, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(315, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(13));

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(317,
        ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.InstanceAtomicRightSideContext) getResult1).identifier());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = pureInstanceClassMappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(315, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSideContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext instanceRightSideContext = new PureInstanceClassMappingParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.InstanceRightSideContext instanceRightSideContext = new PureInstanceClassMappingParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);
    instanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(13, (new PureInstanceClassMappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideScalar() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSideScalar());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideVector() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSideVector());
  }

  @Test
  public void testLambdaFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = pureInstanceClassMappingParserGrammar
        .lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaFunctionResult.invokingState);
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.start;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(485, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = pureInstanceClassMappingParserGrammar
        .lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualLambdaFunctionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.stop;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLambdaFunctionResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF>", actualLambdaFunctionResult.getText());
    assertEquals(2, actualLambdaFunctionResult.getChildCount());
    assertTrue(actualLambdaFunctionResult.isEmpty());
    assertEquals("([] <missing BRACE_OPEN> ([486] ([621 486] <EOF>)))", actualLambdaFunctionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(491, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(486, ((PureInstanceClassMappingParserGrammar.LambdaParamContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testLambdaFunctionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaFunctionContext lambdaFunctionContext = new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaFunctionContext lambdaFunctionContext = new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);
    lambdaFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testLambdaFunctionContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testLambdaFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testLambdaFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(38,
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaFunctionContextLambdaParam() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam(1));
  }

  @Test
  public void testLambdaFunctionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testLambdaParam() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(621, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testLambdaParam2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.stop;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertSame(start, actualLambdaParamResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(621, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testLambdaParam3() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.stop;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertSame(start, actualLambdaParamResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(621, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, start.getLine());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("Input", start.getText());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParam4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertNull(identifierResult.getStop());
    assertFalse(identifierResult.isEmpty());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStart());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testLambdaParam5() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.LambdaParamContext actualLambdaParamResult = pureInstanceClassMappingParserGrammar
        .lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.stop;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertSame(start, actualLambdaParamResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(621, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, start.getLine());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("Input", start.getText());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParamContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaParamContext lambdaParamContext = new PureInstanceClassMappingParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaParamContext lambdaParamContext = new PureInstanceClassMappingParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);
    lambdaParamContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(54,
        (new PureInstanceClassMappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLambdaParamContextLambdaParamType() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).lambdaParamType());
  }

  @Test
  public void testLambdaParamType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = pureInstanceClassMappingParserGrammar
        .lambdaParamType();

    // Assert
    RecognitionException recognitionException = actualLambdaParamTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertNull(actualLambdaParamTypeResult.getParent());
    Token expectedStart = actualLambdaParamTypeResult.start;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(pureInstanceClassMappingParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualLambdaParamTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(625, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testLambdaParamType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParamType();

    // Assert
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertEquals(3, actualLambdaParamTypeResult.children.size());
    assertNull(actualLambdaParamTypeResult.getParent());
    Token token = actualLambdaParamTypeResult.stop;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualLambdaParamTypeResult.getStop());
    assertEquals("<missing ':'><EOF>", actualLambdaParamTypeResult.getText());
    assertEquals(3, actualLambdaParamTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualLambdaParamTypeResult
        .multiplicity();
    assertEquals(627, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[627]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualLambdaParamTypeResult.type();
    assertNull(typeResult.type());
    assertEquals("([626] ([739 626] ([863 739 626] <EOF>)))", typeResult.toStringTree());
    assertEquals("<EOF>", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertFalse(typeResult.isEmpty());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testLambdaParamTypeContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);
    lambdaParamTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testLambdaParamTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(55,
        (new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testLambdaParamTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testLambdaPipe() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LambdaPipeContext actualLambdaPipeResult = pureInstanceClassMappingParserGrammar
        .lambdaPipe();

    // Assert
    RecognitionException recognitionException = actualLambdaPipeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    assertNull(actualLambdaPipeResult.getParent());
    Token expectedStart = actualLambdaPipeResult.start;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaPipeResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(618, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaPipeResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaPipe2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.LambdaPipeContext actualLambdaPipeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaPipe();

    // Assert
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    List<ParseTree> parseTreeList = actualLambdaPipeResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaPipeResult.getParent());
    Token token = actualLambdaPipeResult.stop;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualLambdaPipeResult.getStop());
    assertEquals(2, actualLambdaPipeResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CodeBlockContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CodeBlockContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CodeBlockContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CodeBlockContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '|'>", getResult1.toString());
    assertEquals("([619] ([357 619] ([369 357 619] ([392 369 357 619] ([399 392 369 357 619] ([232 399 392 369 357 619]"
        + " ([471 232 399 392 369 357 619] ([478 471 232 399 392 369 357 619] ([863 478 471 232 399 392 369 357"
        + " 619] <EOF>)))))))))", getResult.toStringTree());
    assertSame(actualLambdaPipeResult, getResult1.getParent());
  }

  @Test
  public void testLambdaPipeContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaPipeContext lambdaPipeContext = new PureInstanceClassMappingParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LambdaPipeContext lambdaPipeContext = new PureInstanceClassMappingParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);
    lambdaPipeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testLambdaPipeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(53,
        (new PureInstanceClassMappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaPipeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testLetExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LetExpressionContext actualLetExpressionResult = pureInstanceClassMappingParserGrammar
        .letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLetExpressionResult.invokingState);
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.start;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLetExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(387, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testLetExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.LetExpressionContext actualLetExpressionResult = pureInstanceClassMappingParserGrammar
        .letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualLetExpressionResult.children.size());
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.stop;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualLetExpressionResult.getChildCount());
    assertSame(start, actualLetExpressionResult.getStop());
    assertEquals("<missing 'let'><EOF>", actualLetExpressionResult.getText());
    assertTrue(actualLetExpressionResult.isEmpty());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualLetExpressionResult.identifier();
    assertEquals(388, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(389, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals("[@0,1:1='<EOF>',<1>,channel=1,1:0]", start.toString());
  }

  @Test
  public void testLetExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LetExpressionContext letExpressionContext = new PureInstanceClassMappingParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.LetExpressionContext letExpressionContext = new PureInstanceClassMappingParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);
    letExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testLetExpressionContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testLetExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(26,
        (new PureInstanceClassMappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLetExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLetExpressionContextLET() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testMappingFilter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MappingFilterContext actualMappingFilterResult = pureInstanceClassMappingParserGrammar
        .mappingFilter();

    // Assert
    RecognitionException recognitionException = actualMappingFilterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMappingFilterResult.invokingState);
    assertNull(actualMappingFilterResult.getParent());
    Token expectedStart = actualMappingFilterResult.start;
    Token start = actualMappingFilterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingFilterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(192, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingFilterResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMappingFilter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.MappingFilterContext actualMappingFilterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).mappingFilter();

    // Assert
    assertEquals(-1, actualMappingFilterResult.invokingState);
    List<ParseTree> parseTreeList = actualMappingFilterResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMappingFilterResult.getParent());
    Token token = actualMappingFilterResult.stop;
    Token start = actualMappingFilterResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMappingFilterResult.getStop());
    assertEquals(2, actualMappingFilterResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '~filter'>", getResult1.toString());
    assertEquals("([193] ([392 193] ([399 392 193] ([232 399 392 193] ([471 232 399 392 193] ([478 471 232 399 392 193]"
        + " ([863 478 471 232 399 392 193] <EOF>)))))))", getResult.toStringTree());
    assertSame(actualMappingFilterResult, getResult1.getParent());
  }

  @Test
  public void testMappingFilterContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MappingFilterContext mappingFilterContext = new PureInstanceClassMappingParserGrammar.MappingFilterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingFilterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingFilterContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MappingFilterContext mappingFilterContext = new PureInstanceClassMappingParserGrammar.MappingFilterContext(
        new ParserRuleContext(), 1);
    mappingFilterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingFilterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingFilterContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MappingFilterContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testMappingFilterContextMAPPING_FILTER() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MappingFilterContext(new ParserRuleContext(), 1)).MAPPING_FILTER());
  }

  @Test
  public void testMappingSrc() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MappingSrcContext actualMappingSrcResult = pureInstanceClassMappingParserGrammar
        .mappingSrc();

    // Assert
    RecognitionException recognitionException = actualMappingSrcResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMappingSrcResult.invokingState);
    assertNull(actualMappingSrcResult.getParent());
    Token expectedStart = actualMappingSrcResult.start;
    Token start = actualMappingSrcResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingSrcResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(189, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingSrcResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMappingSrc2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.MappingSrcContext actualMappingSrcResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).mappingSrc();

    // Assert
    assertEquals(-1, actualMappingSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualMappingSrcResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMappingSrcResult.getParent());
    Token token = actualMappingSrcResult.stop;
    Token start = actualMappingSrcResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMappingSrcResult.getStop());
    assertEquals(2, actualMappingSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '~src'>", getResult1.toString());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([190] ([863 190] <EOF>))", getResult.toStringTree());
    assertSame(actualMappingSrcResult, getResult1.getParent());
    assertEquals("<EOF>", getResult.getText());
    assertEquals(863,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).identifier().invokingState);
  }

  @Test
  public void testMappingSrcContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MappingSrcContext mappingSrcContext = new PureInstanceClassMappingParserGrammar.MappingSrcContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingSrcContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingSrcContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MappingSrcContext mappingSrcContext = new PureInstanceClassMappingParserGrammar.MappingSrcContext(
        new ParserRuleContext(), 1);
    mappingSrcContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingSrcContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingSrcContextMAPPING_SRC() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MappingSrcContext(new ParserRuleContext(), 1)).MAPPING_SRC());
  }

  @Test
  public void testMappingSrcContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MappingSrcContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityContext actualMultiplicityResult = pureInstanceClassMappingParserGrammar
        .multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityResult.invokingState);
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(770, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityContext actualMultiplicityResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicity();

    // Assert
    assertEquals(-1, actualMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '['> ([771] ([832 771] <EOF>)) <missing ']'>)", actualMultiplicityResult.toStringTree());
    assertNull(actualMultiplicityResult.getParent());
    Token token = actualMultiplicityResult.stop;
    Token start = actualMultiplicityResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplicityResult.getStop());
    assertEquals("<missing '['><EOF><missing ']'>", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing ']'>", getResult1.getText());
    assertEquals("<missing ']'>", getResult1.toString());
    assertSame(actualMultiplicityResult, getResult1.getParent());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertEquals(832,
        ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).identifier().invokingState);
  }

  @Test
  public void testMultiplicity3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityContext actualMultiplicityResult = pureInstanceClassMappingParserGrammar
        .multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMultiplicityResult.stop;
    Token stop = actualMultiplicityResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '['><EOF>null", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertTrue(actualMultiplicityResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertEquals(772, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(stop, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertEquals(771,
        ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testMultiplicityArgument() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = pureInstanceClassMappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(839, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicityArgument2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.getChildCount());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult
        .identifier();
    assertEquals(832, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.getChildCount());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult
        .identifier();
    assertEquals(832, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.getChildCount());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult
        .identifier();
    assertEquals(832, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = pureInstanceClassMappingParserGrammar
        .multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.getChildCount());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult
        .identifier();
    assertEquals(832, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = pureInstanceClassMappingParserGrammar
        .multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.getChildCount());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult
        .identifier();
    assertEquals(832, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = pureInstanceClassMappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(839, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicityArgument8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = pureInstanceClassMappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(839, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicityArgumentContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextDOT_DOT() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).DOT_DOT());
  }

  @Test
  public void testMultiplicityArgumentContextFromMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1))
        .fromMultiplicity());
  }

  @Test
  public void testMultiplicityArgumentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(78, (new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1))
        .identifier());
  }

  @Test
  public void testMultiplicityArgumentContextToMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1))
        .toMultiplicity());
  }

  @Test
  public void testMultiplicityArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertEquals(832, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertEquals(832, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertEquals(832, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = pureInstanceClassMappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertEquals(832, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = pureInstanceClassMappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertEquals(832, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = pureInstanceClassMappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = pureInstanceClassMappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArgumentsContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplicityArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(77,
        (new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentsContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1))
        .multiplicityArgument()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1))
        .multiplicityArgument(1));
  }

  @Test
  public void testMultiplicityContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityContext = new PureInstanceClassMappingParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityContext = new PureInstanceClassMappingParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);
    multiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testMultiplicityContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(67,
        (new PureInstanceClassMappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1))
        .multiplicityArgument());
  }

  @Test
  public void testMultiplictyParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = pureInstanceClassMappingParserGrammar
        .multiplictyParameters();

    // Assert
    RecognitionException recognitionException = actualMultiplictyParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    assertNull(actualMultiplictyParametersResult.getParent());
    Token expectedStart = actualMultiplictyParametersResult.start;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplictyParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(849, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplictyParametersResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplictyParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplictyParameters();

    // Assert
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplictyParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMultiplictyParametersResult.getParent());
    Token token = actualMultiplictyParametersResult.stop;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplictyParametersResult.getStop());
    assertEquals("<missing '|'><EOF>", actualMultiplictyParametersResult.getText());
    assertEquals(2, actualMultiplictyParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertSame(actualMultiplictyParametersResult, parseTreeList.get(0).getParent());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testMultiplictyParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);
    multiplictyParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplictyParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(80,
        (new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testMultiplictyParametersContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1))
        .identifier()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1))
        .identifier(1));
  }

  @Test
  public void testMultiplictyParametersContextPIPE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testNotExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.NotExpressionContext actualNotExpressionResult = pureInstanceClassMappingParserGrammar
        .notExpression();

    // Assert
    RecognitionException recognitionException = actualNotExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualNotExpressionResult.invokingState);
    assertNull(actualNotExpressionResult.getParent());
    Token expectedStart = actualNotExpressionResult.start;
    Token start = actualNotExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNotExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(612, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualNotExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testNotExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.NotExpressionContext actualNotExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).notExpression();

    // Assert
    assertEquals(-1, actualNotExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualNotExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNotExpressionResult.getParent());
    Token token = actualNotExpressionResult.stop;
    Token start = actualNotExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualNotExpressionResult.getStop());
    assertEquals("<missing '!'><EOF>", actualNotExpressionResult.getText());
    assertEquals(2, actualNotExpressionResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualNotExpressionResult.expression();
    assertEquals(613, expressionResult.invokingState);
    List<ParseTree> parseTreeList1 = expressionResult.children;
    assertEquals(1, parseTreeList1.size());
    assertEquals("([613] ([232 613] ([471 232 613] ([478 471 232 613] ([863 478 471 232 613] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(actualNotExpressionResult, parseTreeList.get(0).getParent());
    assertEquals(232,
        ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) parseTreeList1.get(0)).invokingState);
  }

  @Test
  public void testNotExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.NotExpressionContext notExpressionContext = new PureInstanceClassMappingParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.NotExpressionContext notExpressionContext = new PureInstanceClassMappingParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);
    notExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testNotExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(51,
        (new PureInstanceClassMappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testNotExpressionContextNOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).NOT());
  }

  @Test
  public void testPackagePath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.PackagePathContext actualPackagePathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPackagePath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.PackagePathContext actualPackagePathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertNull(getResult1.toString());
  }

  @Test
  public void testPackagePath3() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.PackagePathContext actualPackagePathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePath4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.PackagePathContext actualPackagePathResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [865])", actualPackagePathResult.toStringTree());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(865, ((PureInstanceClassMappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testPackagePath5() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.PackagePathContext actualPackagePathResult = pureInstanceClassMappingParserGrammar
        .packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePathContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PackagePathContext packagePathContext = new PureInstanceClassMappingParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PackagePathContext packagePathContext = new PureInstanceClassMappingParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);
    packagePathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(82,
        (new PureInstanceClassMappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPackagePathContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier()
        .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testPackagePathContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR(1));
  }

  @Test
  public void testProgramLine() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(371, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(371, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(371, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testProgramLine4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(392,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ProgramLineContext actualProgramLineResult = pureInstanceClassMappingParserGrammar
        .programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(371, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLineContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ProgramLineContext programLineContext = new PureInstanceClassMappingParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ProgramLineContext programLineContext = new PureInstanceClassMappingParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);
    programLineContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testProgramLineContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(22,
        (new PureInstanceClassMappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testProgramLineContextLetExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).letExpression());
  }

  @Test
  public void testPropertyBracketExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = pureInstanceClassMappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyBracketExpressionResult.invokingState);
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.start;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyBracketExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(425, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyBracketExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = pureInstanceClassMappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(425, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(37));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = pureInstanceClassMappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(426, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);
    propertyBracketExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1))
        .BRACKET_CLOSE());
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1))
        .BRACKET_OPEN());
  }

  @Test
  public void testPropertyBracketExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(32,
        (new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testPropertyBracketExpressionContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1))
        .INTEGER());
  }

  @Test
  public void testPropertyBracketExpressionContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1))
        .STRING());
  }

  @Test
  public void testPropertyExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = pureInstanceClassMappingParserGrammar
        .propertyExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    assertNull(actualPropertyExpressionResult.getParent());
    Token expectedStart = actualPropertyExpressionResult.start;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(419, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualPropertyExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testPropertyExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyExpression();

    // Assert
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualPropertyExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPropertyExpressionResult.getParent());
    Token expectedStart = actualPropertyExpressionResult.stop;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualPropertyExpressionResult.getChildCount());
    assertSame(start, actualPropertyExpressionResult.getStop());
    assertEquals("<missing '.'><EOF>", actualPropertyExpressionResult.getText());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualPropertyExpressionResult
        .identifier();
    assertEquals(1, identifierResult.children.size());
    assertEquals(420, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualPropertyExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testPropertyExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyExpressionContext propertyExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyExpressionContext propertyExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);
    propertyExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionLatestMilestoningDateParameter() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionLatestMilestoningDateParameter());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters());
  }

  @Test
  public void testPropertyExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(31, (new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testPropertyExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyMapping() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyMappingContext actualPropertyMappingResult = pureInstanceClassMappingParserGrammar
        .propertyMapping();

    // Assert
    RecognitionException recognitionException = actualPropertyMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyMappingResult.invokingState);
    assertNull(actualPropertyMappingResult.getParent());
    Token expectedStart = actualPropertyMappingResult.start;
    Token start = actualPropertyMappingResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyMappingResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualPropertyMappingResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(205, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyMapping2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyMappingContext actualPropertyMappingResult = pureInstanceClassMappingParserGrammar
        .propertyMapping();

    // Assert
    RecognitionException recognitionException = actualPropertyMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualPropertyMappingResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPropertyMappingResult.getParent());
    assertEquals(-1, actualPropertyMappingResult.invokingState);
    Token expectedStart = actualPropertyMappingResult.stop;
    Token start = actualPropertyMappingResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyMappingResult.identifier());
    assertSame(start, actualPropertyMappingResult.getStop());
    assertEquals("null", actualPropertyMappingResult.getText());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualPropertyMappingResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(203, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals(2, inputStream.size());
    assertEquals(201,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testPropertyMappingContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyMappingContext propertyMappingContext = new PureInstanceClassMappingParserGrammar.PropertyMappingContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyMappingContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyMappingContext propertyMappingContext = new PureInstanceClassMappingParserGrammar.PropertyMappingContext(
        new ParserRuleContext(), 1);
    propertyMappingContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyMappingContextCOLON() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).COLON()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).COLON(1));
  }

  @Test
  public void testPropertyMappingContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testPropertyMappingContextENUMERATION_MAPPING() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1))
        .ENUMERATION_MAPPING());
  }

  @Test
  public void testPropertyMappingContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyMappingContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testPropertyMappingContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testPropertyMappingContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testPropertyMappingContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testPropertyMappingContextSourceAndTargetMappingId() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1))
        .sourceAndTargetMappingId());
  }

  @Test
  public void testPropertyMappingContextType() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyMappingContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testPropertyOrFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext actualPropertyOrFunctionExpressionResult = pureInstanceClassMappingParserGrammar
        .propertyOrFunctionExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyOrFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyOrFunctionExpressionResult.invokingState);
    assertNull(actualPropertyOrFunctionExpressionResult.getParent());
    Token expectedStart = actualPropertyOrFunctionExpressionResult.start;
    Token start = actualPropertyOrFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyOrFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(417, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyOrFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);
    propertyOrFunctionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextFunctionExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
            .functionExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(30,
        (new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyBracketExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
            .propertyBracketExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
            .propertyExpression());
  }

  @Test
  public void testPropertyReturnType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyReturnTypeResult.getStop());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult
        .multiplicity();
    assertEquals(355, multiplicityResult.invokingState);
    assertNull(multiplicityResult.getStop());
    assertEquals("[355]", multiplicityResult.toString());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(354, typeResult.invokingState);
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertNull(typeResult.getStop());
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
  }

  @Test
  public void testPropertyReturnType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token token = actualPropertyReturnTypeResult.stop;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualPropertyReturnTypeResult.getStop());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult
        .multiplicity();
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(355, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[355]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(1, typeResult.getChildCount());
    assertEquals(354, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
  }

  @Test
  public void testPropertyReturnType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    assertSame(expectedStop, actualPropertyReturnTypeResult.getStop());
    assertEquals("null<missing '['><EOF><missing ']'>", actualPropertyReturnTypeResult.getText());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    assertEquals(355, actualPropertyReturnTypeResult.multiplicity().invokingState);
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(354, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testPropertyReturnType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    assertSame(expectedStop, actualPropertyReturnTypeResult.getStop());
    assertEquals("null<missing '['><EOF>null", actualPropertyReturnTypeResult.getText());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    PureInstanceClassMappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult
        .multiplicity();
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(355, multiplicityResult.invokingState);
    PureInstanceClassMappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(354, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testPropertyReturnTypeContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);
    propertyReturnTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(20, (new PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testPropertyReturnTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1))
        .multiplicity());
  }

  @Test
  public void testPropertyReturnTypeContextType() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testPureInstanceClassMapping() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext actualPureInstanceClassMappingResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).pureInstanceClassMapping();

    // Assert
    assertEquals(-1, actualPureInstanceClassMappingResult.invokingState);
    List<ParseTree> parseTreeList = actualPureInstanceClassMappingResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPureInstanceClassMappingResult.getParent());
    Token expectedStart = actualPureInstanceClassMappingResult.stop;
    Token start = actualPureInstanceClassMappingResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPureInstanceClassMappingResult.getStop());
    assertEquals(1, actualPureInstanceClassMappingResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualPureInstanceClassMappingResult, getResult.getParent());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertEquals("EOF", getResult.getText());
  }

  @Test
  public void testPureInstanceClassMapping2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext actualPureInstanceClassMappingResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).pureInstanceClassMapping();

    // Assert
    assertEquals(-1, actualPureInstanceClassMappingResult.invokingState);
    List<ParseTree> parseTreeList = actualPureInstanceClassMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPureInstanceClassMappingResult.getParent());
    Token expectedStart = actualPureInstanceClassMappingResult.start;
    Token start = actualPureInstanceClassMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPureInstanceClassMappingResult.stop;
    Token stop = actualPureInstanceClassMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualPureInstanceClassMappingResult.getText());
    assertEquals(2, actualPureInstanceClassMappingResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertTrue(((PureInstanceClassMappingParserGrammar.PropertyMappingContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(177,
        ((PureInstanceClassMappingParserGrammar.PropertyMappingContext) parseTreeList.get(0)).invokingState);
    assertSame(actualPureInstanceClassMappingResult, getResult.getParent());
  }

  @Test
  public void testPureInstanceClassMapping3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(2));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext actualPureInstanceClassMappingResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).pureInstanceClassMapping();

    // Assert
    assertEquals(-1, actualPureInstanceClassMappingResult.invokingState);
    List<ParseTree> parseTreeList = actualPureInstanceClassMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPureInstanceClassMappingResult.getParent());
    Token expectedStart = actualPureInstanceClassMappingResult.start;
    Token start = actualPureInstanceClassMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPureInstanceClassMappingResult.stop;
    Token stop = actualPureInstanceClassMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualPureInstanceClassMappingResult.getText());
    assertEquals(2, actualPureInstanceClassMappingResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(170, ((PureInstanceClassMappingParserGrammar.MappingSrcContext) parseTreeList.get(0)).invokingState);
    assertSame(actualPureInstanceClassMappingResult, getResult.getParent());
  }

  @Test
  public void testPureInstanceClassMapping4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(3));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext actualPureInstanceClassMappingResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).pureInstanceClassMapping();

    // Assert
    assertEquals(-1, actualPureInstanceClassMappingResult.invokingState);
    List<ParseTree> parseTreeList = actualPureInstanceClassMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPureInstanceClassMappingResult.getParent());
    Token expectedStart = actualPureInstanceClassMappingResult.start;
    Token start = actualPureInstanceClassMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPureInstanceClassMappingResult.stop;
    Token stop = actualPureInstanceClassMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualPureInstanceClassMappingResult.getText());
    assertEquals(2, actualPureInstanceClassMappingResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(171,
        ((PureInstanceClassMappingParserGrammar.MappingFilterContext) parseTreeList.get(0)).invokingState);
    assertSame(actualPureInstanceClassMappingResult, getResult.getParent());
  }

  @Test
  public void testPureInstanceClassMappingContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext pureInstanceClassMappingContext = new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(pureInstanceClassMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPureInstanceClassMappingContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext pureInstanceClassMappingContext = new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(
        new ParserRuleContext(), 1);
    pureInstanceClassMappingContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(pureInstanceClassMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPureInstanceClassMappingContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1)).COMMA()
            .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .COMMA(1));
  }

  @Test
  public void testPureInstanceClassMappingContextEOF() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1)).EOF());
  }

  @Test
  public void testPureInstanceClassMappingContextMappingFilter() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .mappingFilter()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .mappingFilter(1));
  }

  @Test
  public void testPureInstanceClassMappingContextMappingSrc() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .mappingSrc()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .mappingSrc(1));
  }

  @Test
  public void testPureInstanceClassMappingContextPropertyMapping() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .propertyMapping()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.PureInstanceClassMappingContext(new ParserRuleContext(), 1))
        .propertyMapping(1));
  }

  @Test
  public void testQualifiedName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(861, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.stop;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertSame(start, actualQualifiedNameResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertEquals(863, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(861, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testQualifiedName4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.stop;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertSame(start, actualQualifiedNameResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertEquals(863, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.stop;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertSame(start, actualQualifiedNameResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertEquals(863, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.stop;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertSame(start, actualQualifiedNameResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertEquals(863, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.stop;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertSame(start, actualQualifiedNameResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertEquals(863, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(861, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = pureInstanceClassMappingParserGrammar
        .qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(861, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedNameContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.QualifiedNameContext qualifiedNameContext = new PureInstanceClassMappingParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.QualifiedNameContext qualifiedNameContext = new PureInstanceClassMappingParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);
    qualifiedNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(81,
        (new PureInstanceClassMappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testQualifiedNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testQualifiedNameContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testQualifiedNameContextPackagePath() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).packagePath());
  }

  @Test
  public void testSignedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.SignedExpressionContext actualSignedExpressionResult = pureInstanceClassMappingParserGrammar
        .signedExpression();

    // Assert
    RecognitionException recognitionException = actualSignedExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertNull(actualSignedExpressionResult.getParent());
    Token expectedStart = actualSignedExpressionResult.start;
    Token start = actualSignedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSignedExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(615, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualSignedExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSignedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.SignedExpressionContext actualSignedExpressionResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).signedExpression();

    // Assert
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertEquals(1, actualSignedExpressionResult.children.size());
    assertNull(actualSignedExpressionResult.getParent());
    Token token = actualSignedExpressionResult.stop;
    assertSame(token, actualSignedExpressionResult.getStart());
    Token stop = actualSignedExpressionResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualSignedExpressionResult.getChildCount());
    PureInstanceClassMappingParserGrammar.ExpressionContext expressionResult = actualSignedExpressionResult
        .expression();
    assertEquals("([616] ([232 616] ([471 232 616] ([478 471 232 616] ([863 478 471 232 616] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(232,
        ((PureInstanceClassMappingParserGrammar.AtomicExpressionContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testSignedExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SignedExpressionContext signedExpressionContext = new PureInstanceClassMappingParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SignedExpressionContext signedExpressionContext = new PureInstanceClassMappingParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);
    signedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testSignedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(52,
        (new PureInstanceClassMappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSignedExpressionContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testSignedExpressionContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testSliceExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.SliceExpressionContext actualSliceExpressionResult = pureInstanceClassMappingParserGrammar
        .sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSliceExpressionResult.invokingState);
    assertNull(actualSliceExpressionResult.getParent());
    Token expectedStart = actualSliceExpressionResult.start;
    Token start = actualSliceExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSliceExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(595, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSliceExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.SliceExpressionContext actualSliceExpressionResult = pureInstanceClassMappingParserGrammar
        .sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualSliceExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualSliceExpressionResult.getParent());
    Token token = actualSliceExpressionResult.stop;
    assertSame(token, actualSliceExpressionResult.getStart());
    Token stop = actualSliceExpressionResult.getStop();
    assertSame(token, stop);
    assertEquals("<missing '['><EOF>", actualSliceExpressionResult.getText());
    assertEquals(2, actualSliceExpressionResult.getChildCount());
    assertTrue(actualSliceExpressionResult.isEmpty());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(608, recognitionException.getOffendingState());
    assertSame(stop, ((NoViableAltException) recognitionException).getStartToken());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals(0, stop.getTokenIndex());
    assertSame(actualSliceExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testSliceExpressionContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SliceExpressionContext sliceExpressionContext = new PureInstanceClassMappingParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SliceExpressionContext sliceExpressionContext = new PureInstanceClassMappingParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);
    sliceExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testSliceExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testSliceExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON(1));
  }

  @Test
  public void testSliceExpressionContextExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testSliceExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(50,
        (new PureInstanceClassMappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSourceAndTargetMappingId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext actualSourceAndTargetMappingIdResult = pureInstanceClassMappingParserGrammar
        .sourceAndTargetMappingId();

    // Assert
    RecognitionException recognitionException = actualSourceAndTargetMappingIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSourceAndTargetMappingIdResult.invokingState);
    assertNull(actualSourceAndTargetMappingIdResult.getParent());
    Token expectedStart = actualSourceAndTargetMappingIdResult.start;
    Token start = actualSourceAndTargetMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceAndTargetMappingIdResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(219, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSourceAndTargetMappingIdResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testSourceAndTargetMappingId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext actualSourceAndTargetMappingIdResult = pureInstanceClassMappingParserGrammar
        .sourceAndTargetMappingId();

    // Assert
    RecognitionException recognitionException = actualSourceAndTargetMappingIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualSourceAndTargetMappingIdResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualSourceAndTargetMappingIdResult.getParent());
    Token expectedStart = actualSourceAndTargetMappingIdResult.stop;
    Token start = actualSourceAndTargetMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceAndTargetMappingIdResult.getStop());
    assertEquals("<missing '['><EOF>", actualSourceAndTargetMappingIdResult.getText());
    assertEquals(2, actualSourceAndTargetMappingIdResult.getChildCount());
    assertTrue(actualSourceAndTargetMappingIdResult.isEmpty());
    assertEquals("([] <missing '['> ([220] ([227 220] ([863 227 220] <EOF>))))",
        actualSourceAndTargetMappingIdResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(223, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualSourceAndTargetMappingIdResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(220, ((PureInstanceClassMappingParserGrammar.SourceIdContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testSourceAndTargetMappingIdContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext sourceAndTargetMappingIdContext = new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sourceAndTargetMappingIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceAndTargetMappingIdContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext sourceAndTargetMappingIdContext = new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(
        new ParserRuleContext(), 1);
    sourceAndTargetMappingIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sourceAndTargetMappingIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceAndTargetMappingIdContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(new ParserRuleContext(), 1))
        .BRACKET_CLOSE());
  }

  @Test
  public void testSourceAndTargetMappingIdContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(new ParserRuleContext(), 1))
        .BRACKET_OPEN());
  }

  @Test
  public void testSourceAndTargetMappingIdContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(new ParserRuleContext(), 1))
        .COMMA());
  }

  @Test
  public void testSourceAndTargetMappingIdContextSourceId() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(new ParserRuleContext(), 1))
        .sourceId());
  }

  @Test
  public void testSourceAndTargetMappingIdContextTargetId() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceAndTargetMappingIdContext(new ParserRuleContext(), 1))
        .targetId());
  }

  @Test
  public void testSourceId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.start;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.stop;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testSourceId3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.stop;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testSourceId4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.stop;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testSourceId5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = pureInstanceClassMappingParserGrammar
        .sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.stop;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testSourceId6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = pureInstanceClassMappingParserGrammar
        .sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.stop;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testSourceId7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = pureInstanceClassMappingParserGrammar
        .sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.start;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceId8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.SourceIdContext actualSourceIdResult = pureInstanceClassMappingParserGrammar
        .sourceId();

    // Assert
    assertEquals(-1, actualSourceIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceIdResult.getParent());
    Token expectedStart = actualSourceIdResult.start;
    Token start = actualSourceIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceIdResult.getStop());
    assertEquals(1, actualSourceIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceIdContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SourceIdContext sourceIdContext = new PureInstanceClassMappingParserGrammar.SourceIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sourceIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceIdContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.SourceIdContext sourceIdContext = new PureInstanceClassMappingParserGrammar.SourceIdContext(
        new ParserRuleContext(), 1);
    sourceIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sourceIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(6,
        (new PureInstanceClassMappingParserGrammar.SourceIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSourceIdContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.SourceIdContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testStereotypeReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = pureInstanceClassMappingParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeReferenceResult.identifier());
    assertNull(actualStereotypeReferenceResult.getStop());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    assertEquals("([] [346])", actualStereotypeReferenceResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(347, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1, tokenSource.getLine());
    assertEquals(346,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testStereotypeReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = pureInstanceClassMappingParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.stop;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeReferenceResult.identifier());
    assertSame(start, actualStereotypeReferenceResult.getStop());
    assertEquals("null", actualStereotypeReferenceResult.getText());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(347, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(346,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).stereotypeReference();

    // Assert
    assertEquals(-1, actualStereotypeReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualStereotypeReferenceResult.getChildCount());
    Token expectedStop = actualStereotypeReferenceResult.stop;
    Token stop = actualStereotypeReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '@'><EOF>", actualStereotypeReferenceResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualStereotypeReferenceResult
        .identifier();
    assertEquals(348, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(346,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReferenceContextAT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testStereotypeReferenceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);
    stereotypeReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(18, (new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testStereotypeReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1))
        .identifier());
  }

  @Test
  public void testStereotypeReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1))
        .qualifiedName());
  }

  @Test
  public void testTagReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TagReferenceContext actualTagReferenceResult = pureInstanceClassMappingParserGrammar
        .tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTagReferenceResult.identifier());
    assertNull(actualTagReferenceResult.getStop());
    assertTrue(actualTagReferenceResult.isEmpty());
    assertEquals("([] [350])", actualTagReferenceResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(351, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1, tokenSource.getLine());
    assertEquals(350,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTagReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TagReferenceContext actualTagReferenceResult = pureInstanceClassMappingParserGrammar
        .tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.stop;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTagReferenceResult.identifier());
    assertSame(start, actualTagReferenceResult.getStop());
    assertEquals("null", actualTagReferenceResult.getText());
    assertTrue(actualTagReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(351, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(350,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.TagReferenceContext actualTagReferenceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).tagReference();

    // Assert
    assertEquals(-1, actualTagReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualTagReferenceResult.getChildCount());
    Token expectedStop = actualTagReferenceResult.stop;
    Token stop = actualTagReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '%'><EOF>", actualTagReferenceResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTagReferenceResult.identifier();
    assertEquals(352, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(350,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReferenceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TagReferenceContext tagReferenceContext = new PureInstanceClassMappingParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TagReferenceContext tagReferenceContext = new PureInstanceClassMappingParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);
    tagReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(19,
        (new PureInstanceClassMappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTagReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTagReferenceContextPERCENT() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).PERCENT());
  }

  @Test
  public void testTagReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTargetId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.start;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.stop;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTargetId3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.stop;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTargetId4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.stop;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTargetId5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = pureInstanceClassMappingParserGrammar
        .targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.stop;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTargetId6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = pureInstanceClassMappingParserGrammar
        .targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.stop;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTargetId7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = pureInstanceClassMappingParserGrammar
        .targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.start;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetId8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.TargetIdContext actualTargetIdResult = pureInstanceClassMappingParserGrammar
        .targetId();

    // Assert
    assertEquals(-1, actualTargetIdResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetIdResult.getParent());
    Token expectedStart = actualTargetIdResult.start;
    Token start = actualTargetIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetIdResult.getStop());
    assertEquals(1, actualTargetIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetIdContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TargetIdContext targetIdContext = new PureInstanceClassMappingParserGrammar.TargetIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(targetIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTargetIdContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TargetIdContext targetIdContext = new PureInstanceClassMappingParserGrammar.TargetIdContext(
        new ParserRuleContext(), 1);
    targetIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(targetIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTargetIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(7,
        (new PureInstanceClassMappingParserGrammar.TargetIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTargetIdContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TargetIdContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testToMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));

    // Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = pureInstanceClassMappingParserGrammar
        .toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testToMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = pureInstanceClassMappingParserGrammar
        .toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("null", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(776, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testToMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = pureInstanceClassMappingParserGrammar
        .toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(776, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testToMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = pureInstanceClassMappingParserGrammar
        .toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(776, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = pureInstanceClassMappingParserGrammar
        .toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(pureInstanceClassMappingParserGrammar.getRuleContext());
    assertEquals(-1, pureInstanceClassMappingParserGrammar.getState());
  }

  @Test
  public void testToMultiplicityContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext toMultiplicityContext = new PureInstanceClassMappingParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.ToMultiplicityContext toMultiplicityContext = new PureInstanceClassMappingParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);
    toMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(69,
        (new PureInstanceClassMappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testToMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testToMultiplicityContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(pureInstanceClassMappingParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(768, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testType10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(pureInstanceClassMappingParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(768, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource1, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(pureInstanceClassMappingParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(768, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getStartIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[863 739]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(863, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeContext actualTypeResult = pureInstanceClassMappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(pureInstanceClassMappingParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(768, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testTypeAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = pureInstanceClassMappingParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.start;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(781, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = pureInstanceClassMappingParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.stop;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([782] ([801 782] ([809 801 782] <EOF>))))",
        actualTypeAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(784, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(782,
        ((PureInstanceClassMappingParserGrammar.TypeParametersContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeAndMultiplicityParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
            .GREATER_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(71,
        (new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
            .LESS_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
            .multiplictyParameters());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextTypeParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
            .typeParameters());
  }

  @Test
  public void testTypeArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = pureInstanceClassMappingParserGrammar
        .typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = pureInstanceClassMappingParserGrammar
        .typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = pureInstanceClassMappingParserGrammar
        .typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((PureInstanceClassMappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[739 841]", getResult1.toString());
    assertEquals(739, ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new CommonTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = pureInstanceClassMappingParserGrammar
        .typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    pureInstanceClassMappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = pureInstanceClassMappingParserGrammar
        .typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((PureInstanceClassMappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArgumentsContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext typeArgumentsContext = new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeArgumentsContext typeArgumentsContext = new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);
    typeArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(79,
        (new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeArgumentsContextType() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type(1));
  }

  @Test
  public void testTypeContextARROW() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).ARROW());
  }

  @Test
  public void testTypeContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeContext typeContext = new PureInstanceClassMappingParserGrammar.TypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeContext typeContext = new PureInstanceClassMappingParserGrammar.TypeContext(
        new ParserRuleContext(), 1);
    typeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testTypeContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testTypeContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeContextFunctionTypePureType() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType(1));
  }

  @Test
  public void testTypeContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(66,
        (new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testTypeContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testTypeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testTypeContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testTypeContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testTypeContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(809, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.stop;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertSame(start, actualTypeParameterResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(809, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTypeParameter3() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.stop;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertSame(start, actualTypeParameterResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(809, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, start.getLine());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("Input", start.getText());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameter4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertNull(identifierResult.getStop());
    assertFalse(identifierResult.isEmpty());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStart());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testTypeParameter5() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeParameterContext actualTypeParameterResult = pureInstanceClassMappingParserGrammar
        .typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.stop;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertSame(start, actualTypeParameterResult.getStop());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(809, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, start.getLine());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("Input", start.getText());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameterContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParameterContext typeParameterContext = new PureInstanceClassMappingParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParameterContext typeParameterContext = new PureInstanceClassMappingParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);
    typeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(74,
        (new PureInstanceClassMappingParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertNull(((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, tokenSource.getLine());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(809, identifierResult.invokingState);
    assertEquals("[809 801]", identifierResult.toString());
  }

  @Test
  public void testTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTypeParameters3() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTypeParameters4() throws RecognitionException {
    // Arrange and Act
    PureInstanceClassMappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] ([801] [809 801]))", actualTypeParametersResult.toStringTree());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals("", actualTypeParametersResult.getText());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(801,
        ((PureInstanceClassMappingParserGrammar.TypeParameterContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testTypeParameters5() throws RecognitionException {
    // Arrange
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.TypeParametersContext actualTypeParametersResult = pureInstanceClassMappingParserGrammar
        .typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = ((PureInstanceClassMappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTypeParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParametersContext typeParametersContext = new PureInstanceClassMappingParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParametersContext typeParametersContext = new PureInstanceClassMappingParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);
    typeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new PureInstanceClassMappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA()
        .isEmpty());
    assertNull((new PureInstanceClassMappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(73,
        (new PureInstanceClassMappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersContextTypeParameter() {
    // Arrange, Act and Assert
    assertTrue(
        (new PureInstanceClassMappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter()
            .isEmpty());
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter(1));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = pureInstanceClassMappingParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.start;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(791, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = pureInstanceClassMappingParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.stop;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([792] ([811 792] ([822 811 792] <EOF>))))",
        actualTypeParametersWithContravarianceAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(794, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(792, ((PureInstanceClassMappingParserGrammar.ContravarianceTypeParametersContext) parseTreeList
        .get(1)).invokingState);
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeParametersWithContravarianceAndMultiplicityParametersContext
        .<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextContravarianceTypeParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
            new ParserRuleContext(), 1)).contravarianceTypeParameters());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
            new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(72,
        (new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
            new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
            new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
            new ParserRuleContext(), 1)).multiplictyParameters());
  }

  @Test
  public void testUnitInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    PureInstanceClassMappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceResult.getStop());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(303, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).invokingState);
    assertEquals("([303] [305 303])", getResult.toStringTree());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).depth());
    assertNull(((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).identifier());
    assertEquals(1, tokenSource.getLine());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals(302, ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) getResult1).invokingState);
    assertTrue(
        ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[302]", getResult1.toString());
    assertTrue(
        ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) getResult1).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testUnitInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.stop;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceResult.getStop());
    assertEquals("null", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertFalse(((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList.get(1)).isEmpty());
    assertSame(start, ((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList.get(1)).getStop());
    assertNull(((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList.get(1)).identifier());
    assertEquals(302,
        ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    assertSame(start,
        ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).depth());
    assertNull(((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStop());
    assertTrue(((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, ((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList.get(1)).getStart());
    assertEquals(2, ((PureInstanceClassMappingParserGrammar.UnitNameContext) parseTreeList.get(1)).depth());
  }

  @Test
  public void testUnitInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitInstanceResult.stop;
    Token stop = actualUnitInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(302,
        ((PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("[303]", getResult.toString());
    assertEquals(3, getResult.getChildCount());
    assertEquals(303, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).invokingState);
    assertSame(stop, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(307, ((PureInstanceClassMappingParserGrammar.UnitNameContext) getResult).identifier().invokingState);
  }

  @Test
  public void testUnitInstanceContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitInstanceContext unitInstanceContext = new PureInstanceClassMappingParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitInstanceContext unitInstanceContext = new PureInstanceClassMappingParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);
    unitInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(10,
        (new PureInstanceClassMappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitInstanceContextUnitInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1))
        .unitInstanceLiteral());
  }

  @Test
  public void testUnitInstanceContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testUnitInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = pureInstanceClassMappingParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualUnitInstanceLiteralResult.invokingState);
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.start;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(664, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testUnitInstanceLiteral2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = pureInstanceClassMappingParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualUnitInstanceLiteralResult.children.size());
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.stop;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceLiteralResult.getStop());
    assertEquals("null", actualUnitInstanceLiteralResult.getText());
    assertEquals(1, actualUnitInstanceLiteralResult.getChildCount());
    assertTrue(actualUnitInstanceLiteralResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(664, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testUnitInstanceLiteralContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);
    unitInstanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testUnitInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testUnitInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(58, (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testUnitInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testUnitInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testUnitInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull(
        (new PureInstanceClassMappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testUnitName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.UnitNameContext actualUnitNameResult = pureInstanceClassMappingParserGrammar
        .unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitNameResult.identifier());
    assertNull(actualUnitNameResult.getStop());
    assertTrue(actualUnitNameResult.isEmpty());
    assertEquals("([] [305])", actualUnitNameResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(306, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1, tokenSource.getLine());
    assertEquals(305,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testUnitName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.UnitNameContext actualUnitNameResult = pureInstanceClassMappingParserGrammar
        .unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.stop;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitNameResult.identifier());
    assertSame(start, actualUnitNameResult.getStop());
    assertEquals("null", actualUnitNameResult.getText());
    assertTrue(actualUnitNameResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(306, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(305,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.UnitNameContext actualUnitNameResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitName();

    // Assert
    assertEquals(-1, actualUnitNameResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(3, actualUnitNameResult.getChildCount());
    Token expectedStop = actualUnitNameResult.stop;
    Token stop = actualUnitNameResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitNameResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualUnitNameResult.identifier();
    assertEquals(307, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(305,
        ((PureInstanceClassMappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitNameContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitNameContext unitNameContext = new PureInstanceClassMappingParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.UnitNameContext unitNameContext = new PureInstanceClassMappingParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);
    unitNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(11,
        (new PureInstanceClassMappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testUnitNameContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testUnitNameContextTILDE() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).TILDE());
  }

  @Test
  public void testVariable() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.VariableContext actualVariableResult = pureInstanceClassMappingParserGrammar
        .variable();

    // Assert
    RecognitionException recognitionException = actualVariableResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualVariableResult.invokingState);
    assertNull(actualVariableResult.getParent());
    Token expectedStart = actualVariableResult.start;
    Token start = actualVariableResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualVariableResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(499, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualVariableResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testVariable2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    PureInstanceClassMappingParserGrammar.VariableContext actualVariableResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).variable();

    // Assert
    assertEquals(-1, actualVariableResult.invokingState);
    List<ParseTree> parseTreeList = actualVariableResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualVariableResult.getParent());
    Token expectedStart = actualVariableResult.stop;
    Token start = actualVariableResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualVariableResult.getChildCount());
    assertSame(start, actualVariableResult.getStop());
    assertEquals("<missing '$'><EOF>", actualVariableResult.getText());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualVariableResult.identifier();
    assertEquals(1, identifierResult.children.size());
    assertEquals(500, identifierResult.invokingState);
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualVariableResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testVariableContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.VariableContext variableContext = new PureInstanceClassMappingParserGrammar.VariableContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.VariableContext variableContext = new PureInstanceClassMappingParserGrammar.VariableContext(
        new ParserRuleContext(), 1);
    variableContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextDOLLAR() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).DOLLAR());
  }

  @Test
  public void testVariableContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(39,
        (new PureInstanceClassMappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testVariableContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testWord() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = pureInstanceClassMappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(876, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.stop;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualWordResult.getChildCount());
    assertSame(start, actualWordResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertEquals(873, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.stop;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualWordResult.getChildCount());
    assertSame(start, actualWordResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertEquals(873, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = (new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.stop;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualWordResult.getChildCount());
    assertSame(start, actualWordResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertEquals(873, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setBuildParseTree(true);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = pureInstanceClassMappingParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.stop;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualWordResult.getChildCount());
    assertSame(start, actualWordResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertEquals(873, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = pureInstanceClassMappingParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.stop;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(1, actualWordResult.getChildCount());
    assertSame(start, actualWordResult.getStop());
    PureInstanceClassMappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertEquals(873, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        commonTokenStream);
    pureInstanceClassMappingParserGrammar.setTrace(true);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = pureInstanceClassMappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(876, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    PureInstanceClassMappingParserGrammar pureInstanceClassMappingParserGrammar = new PureInstanceClassMappingParserGrammar(
        new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    pureInstanceClassMappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    PureInstanceClassMappingParserGrammar.WordContext actualWordResult = pureInstanceClassMappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(876, recognitionException.getOffendingState());
    assertSame(pureInstanceClassMappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWordContextAccept() {
    // Arrange
    PureInstanceClassMappingParserGrammar.WordContext wordContext = new PureInstanceClassMappingParserGrammar.WordContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextAccept2() {
    // Arrange
    PureInstanceClassMappingParserGrammar.WordContext wordContext = new PureInstanceClassMappingParserGrammar.WordContext(
        new ParserRuleContext(), 1);
    wordContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.WordContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testWordContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(83,
        (new PureInstanceClassMappingParserGrammar.WordContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testWordContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.WordContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testWordContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new PureInstanceClassMappingParserGrammar.WordContext(new ParserRuleContext(), 1)).identifier());
  }
}

