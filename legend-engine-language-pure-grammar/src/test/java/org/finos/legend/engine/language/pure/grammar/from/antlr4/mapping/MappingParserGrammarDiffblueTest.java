package org.finos.legend.engine.language.pure.grammar.from.antlr4.mapping;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import java.util.ArrayList;
import java.util.List;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.IntStream;
import org.antlr.v4.runtime.InterpreterRuleContext;
import org.antlr.v4.runtime.ListTokenSource;
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenSource;
import org.antlr.v4.runtime.atn.ParserATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.atn.PredictionMode;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.misc.Pair;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.xpath.XPathLexer;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.CodeLexerGrammar;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.CodeParserGrammarBaseVisitor;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.connection.ConnectionLexerGrammar;
import org.junit.Test;

public class MappingParserGrammarDiffblueTest {
  @Test
  public void testAllFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionContext actualAllFunctionResult = mappingParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionResult.invokingState);
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.start;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(673, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionContext actualAllFunctionResult = mappingParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(673, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(47));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionContext actualAllFunctionResult = mappingParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(674, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionContextALL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testAllFunctionContextAccept() {
    // Arrange
    MappingParserGrammar.AllFunctionContext allFunctionContext = new MappingParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextAccept2() {
    // Arrange
    MappingParserGrammar.AllFunctionContext allFunctionContext = new MappingParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);
    allFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(61, (new MappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllFunctionWithMilestoning() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = mappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionWithMilestoningResult.invokingState);
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.start;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionWithMilestoningResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(691, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunctionWithMilestoning2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = mappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(691, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoning3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(47));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = mappingParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(692, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoningContextALL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept() {
    // Arrange
    MappingParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new MappingParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept2() {
    // Arrange
    MappingParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new MappingParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);
    allFunctionWithMilestoningContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllFunctionWithMilestoningContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testAllFunctionWithMilestoningContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllFunctionWithMilestoningContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(64,
        (new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllOrFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllOrFunctionContext actualAllOrFunctionResult = mappingParserGrammar.allOrFunction();

    // Assert
    RecognitionException recognitionException = actualAllOrFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllOrFunctionResult.invokingState);
    assertNull(actualAllOrFunctionResult.getParent());
    Token expectedStart = actualAllOrFunctionResult.start;
    Token start = actualAllOrFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllOrFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(671, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllOrFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllOrFunctionContextAccept() {
    // Arrange
    MappingParserGrammar.AllOrFunctionContext allOrFunctionContext = new MappingParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAccept2() {
    // Arrange
    MappingParserGrammar.AllOrFunctionContext allOrFunctionContext = new MappingParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);
    allOrFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAllFunction() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allFunction());
  }

  @Test
  public void testAllOrFunctionContextAllFunctionWithMilestoning() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allFunctionWithMilestoning());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsFunction() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allVersionsFunction());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsInRangeFunction() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allVersionsInRangeFunction());
  }

  @Test
  public void testAllOrFunctionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).functionExpressionParameters());
  }

  @Test
  public void testAllOrFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(60, (new MappingParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = mappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsFunctionResult.invokingState);
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.start;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(678, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = mappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(678, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(47));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = mappingParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(679, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunctionContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).ALL_VERSIONS());
  }

  @Test
  public void testAllVersionsFunctionContextAccept() {
    // Arrange
    MappingParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new MappingParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextAccept2() {
    // Arrange
    MappingParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new MappingParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllVersionsFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(62, (new MappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllVersionsInRangeFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = mappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsInRangeFunctionResult.invokingState);
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.start;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(683, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsInRangeFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = mappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(683, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(47));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = mappingParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(684, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept() {
    // Arrange
    MappingParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new MappingParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept2() {
    // Arrange
    MappingParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new MappingParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsInRangeFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(63,
        (new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testArithmeticPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ArithmeticPartContext actualArithmeticPartResult = mappingParserGrammar.arithmeticPart();

    // Assert
    RecognitionException recognitionException = actualArithmeticPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualArithmeticPartResult.invokingState);
    assertNull(actualArithmeticPartResult.getParent());
    Token expectedStart = actualArithmeticPartResult.start;
    Token start = actualArithmeticPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualArithmeticPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(874, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualArithmeticPartResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testArithmeticPartContextAccept() {
    // Arrange
    MappingParserGrammar.ArithmeticPartContext arithmeticPartContext = new MappingParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextAccept2() {
    // Arrange
    MappingParserGrammar.ArithmeticPartContext arithmeticPartContext = new MappingParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);
    arithmeticPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextDIVIDE() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE().isEmpty());
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE(1));
  }

  @Test
  public void testArithmeticPartContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testArithmeticPartContextGREATER_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).GREATER_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testArithmeticPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(79, (new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testArithmeticPartContextLESS_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testArithmeticPartContextMINUS() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS().isEmpty());
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS(1));
  }

  @Test
  public void testArithmeticPartContextPLUS() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS().isEmpty());
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS(1));
  }

  @Test
  public void testArithmeticPartContextSTAR() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR().isEmpty());
    assertNull((new MappingParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR(1));
  }

  @Test
  public void testAtomicExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(639, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(639, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(51));

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.ExpressionInstanceContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceContext) getResult).getStop());
    RecognitionException recognitionException = ((MappingParserGrammar.ExpressionInstanceContext) getResult).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, ((MappingParserGrammar.ExpressionInstanceContext) getResult).children.size());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(getResult, recognitionException.getCtx());
    assertEquals(709, recognitionException.getOffendingState());
  }

  @Test
  public void testAtomicExpression4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    assertNull(actualAtomicExpressionResult.dsl());
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.getParent());
    Token expectedStart = actualAtomicExpressionResult.stop;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAtomicExpressionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[642 635]", getResult1.toString());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = mappingParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertEquals(1, actualAtomicExpressionResult.depth());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAtomicExpressionResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(639, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpressionContextAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testAtomicExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.AtomicExpressionContext atomicExpressionContext = new MappingParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.AtomicExpressionContext atomicExpressionContext = new MappingParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);
    atomicExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextDsl() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).dsl());
  }

  @Test
  public void testAtomicExpressionContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).expressionInstance());
  }

  @Test
  public void testAtomicExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(56, (new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAtomicExpressionContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).instanceLiteralToken());
  }

  @Test
  public void testAtomicExpressionContextInstanceReference() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).instanceReference());
  }

  @Test
  public void testAtomicExpressionContextLambdaFunction() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaFunction());
  }

  @Test
  public void testAtomicExpressionContextLambdaParam() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaParam());
  }

  @Test
  public void testAtomicExpressionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testAtomicExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testAtomicExpressionContextUnitInstance() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).unitInstance());
  }

  @Test
  public void testAtomicExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testBooleanPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.BooleanPartContext actualBooleanPartResult = mappingParserGrammar.booleanPart();

    // Assert
    RecognitionException recognitionException = actualBooleanPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBooleanPartResult.invokingState);
    assertNull(actualBooleanPartResult.getParent());
    Token expectedStart = actualBooleanPartResult.start;
    Token start = actualBooleanPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBooleanPartResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(881, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualBooleanPartResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBooleanPartContextAND() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).AND());
  }

  @Test
  public void testBooleanPartContextAccept() {
    // Arrange
    MappingParserGrammar.BooleanPartContext booleanPartContext = new MappingParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextAccept2() {
    // Arrange
    MappingParserGrammar.BooleanPartContext booleanPartContext = new MappingParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);
    booleanPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testBooleanPartContextExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testBooleanPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(80, (new MappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testBooleanPartContextOR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).OR());
  }

  @Test
  public void testBuildMilestoningVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.BuildMilestoningVariableExpressionContext actualBuildMilestoningVariableExpressionResult = mappingParserGrammar
        .buildMilestoningVariableExpression();

    // Assert
    RecognitionException recognitionException = actualBuildMilestoningVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBuildMilestoningVariableExpressionResult.invokingState);
    assertNull(actualBuildMilestoningVariableExpressionResult.getParent());
    Token expectedStart = actualBuildMilestoningVariableExpressionResult.start;
    Token start = actualBuildMilestoningVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBuildMilestoningVariableExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(704, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualBuildMilestoningVariableExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new MappingParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new MappingParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);
    buildMilestoningVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextDATE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(65, (new MappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1))
        .getRuleIndex());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).LATEST_DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testCodeBlock() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = mappingParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = mappingParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = mappingParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = mappingParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(533, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.CodeBlockContext actualCodeBlockResult = mappingParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlockContextAccept() {
    // Arrange
    MappingParserGrammar.CodeBlockContext codeBlockContext = new MappingParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextAccept2() {
    // Arrange
    MappingParserGrammar.CodeBlockContext codeBlockContext = new MappingParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);
    codeBlockContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(41, (new MappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCodeBlockContextProgramLine() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine().isEmpty());
    assertNull((new MappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine(1));
  }

  @Test
  public void testCodeBlockContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON().isEmpty());
    assertNull((new MappingParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON(1));
  }

  @Test
  public void testCombinedArithmeticOnly() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([540] [563 540])", getResult.toStringTree());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(563, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testCombinedArithmeticOnly10() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(new CommonToken(1)));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = mappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([540] [563 540])", getResult.toStringTree());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(563, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testCombinedArithmeticOnly11() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(44));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = mappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(540, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedArithmeticOnly2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(540, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedArithmeticOnly3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(540));

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(540, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedArithmeticOnly4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(44));

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualCombinedArithmeticOnlyResult.stop;
    Token stop = actualCombinedArithmeticOnlyResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(stop, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("nullnull", getResult.getText());
  }

  @Test
  public void testCombinedArithmeticOnly5() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] ([540] [563 540]))", actualCombinedArithmeticOnlyResult.toStringTree());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals("", actualCombinedArithmeticOnlyResult.getText());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(540, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testCombinedArithmeticOnly6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(44));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = mappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([540] [563 540])", getResult.toStringTree());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(563, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testCombinedArithmeticOnly7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(44));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(540, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedArithmeticOnly8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(44));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.enterRule(new ParserRuleContext(), 0, 1);

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = mappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(0, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("null", actualCombinedArithmeticOnlyResult.getText());
    Token token = actualCombinedArithmeticOnlyResult.stop;
    assertSame(token, actualCombinedArithmeticOnlyResult.getStart());
    Token stop = actualCombinedArithmeticOnlyResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(2, actualCombinedArithmeticOnlyResult.depth());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getParent().getChildCount());
    Interval expectedSourceInterval = actualCombinedArithmeticOnlyResult.getSourceInterval();
    ParseTree getResult = parseTreeList.get(0);
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(stop, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(44));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = mappingParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualCombinedArithmeticOnlyResult.stop;
    Token stop = actualCombinedArithmeticOnlyResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertSame(stop, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("nullnull", getResult.getText());
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept() {
    // Arrange
    MappingParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new MappingParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept2() {
    // Arrange
    MappingParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new MappingParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);
    combinedArithmeticOnlyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextArithmeticPart() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).arithmeticPart()
        .isEmpty());
    assertNull((new MappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).arithmeticPart(1));
  }

  @Test
  public void testCombinedArithmeticOnlyContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
        .expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedArithmeticOnlyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(44,
        (new MappingParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCombinedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([556] [563 556])", getResult.toStringTree());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(563, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testCombinedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(48));

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedExpression4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] ([556] [563 556]))", actualCombinedExpressionResult.toStringTree());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals("", actualCombinedExpressionResult.getText());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testCombinedExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(48));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(48));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = mappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(3, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(start, expressionResult.getStart());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(start, expressionResult.getStop());
  }

  @Test
  public void testCombinedExpression7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = mappingParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([556] [563 556])", getResult.toStringTree());
    MappingParserGrammar.ExpressionContext expressionResult = ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(563, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testCombinedExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.CombinedExpressionContext combinedExpressionContext = new MappingParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.CombinedExpressionContext combinedExpressionContext = new MappingParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);
    combinedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedExpressionContextExpressionPart() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionPart().isEmpty());
    assertNull((new MappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionPart(1));
  }

  @Test
  public void testCombinedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(47, (new MappingParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstructor() {
    // Arrange and Act
    MappingParserGrammar actualMappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(new ArrayList<Token>())));

    // Assert
    assertNull(actualMappingParserGrammar.getParseInfo());
    assertEquals(0, actualMappingParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualMappingParserGrammar.isMatchedEOF());
    assertNull(actualMappingParserGrammar.getContext());
    assertTrue(actualMappingParserGrammar.getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualMappingParserGrammar.getPrecedence());
    assertEquals("List", actualMappingParserGrammar.getSourceName());
    assertFalse(actualMappingParserGrammar.isTrace());
    assertTrue(actualMappingParserGrammar.getBuildParseTree());
    assertEquals(-1, actualMappingParserGrammar.getState());
    assertTrue(
        actualMappingParserGrammar.getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualMappingParserGrammar.getInterpreter();
    assertSame(actualMappingParserGrammar, interpreter.getParser());
    assertEquals(105, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualMappingParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualMappingParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testConstructor2() {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar actualMappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Assert
    assertNull(actualMappingParserGrammar.getParseInfo());
    assertEquals(0, actualMappingParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualMappingParserGrammar.isMatchedEOF());
    assertNull(actualMappingParserGrammar.getContext());
    assertTrue(actualMappingParserGrammar.getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualMappingParserGrammar.getPrecedence());
    assertEquals("List", actualMappingParserGrammar.getSourceName());
    assertFalse(actualMappingParserGrammar.isTrace());
    assertTrue(actualMappingParserGrammar.getBuildParseTree());
    assertEquals(-1, actualMappingParserGrammar.getState());
    assertTrue(
        actualMappingParserGrammar.getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualMappingParserGrammar.getInterpreter();
    assertSame(actualMappingParserGrammar, interpreter.getParser());
    assertEquals(105, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualMappingParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualMappingParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testContravarianceTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = mappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(984, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter4() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(
        new ConnectionLexerGrammar(new ANTLRInputStream()));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = mappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(984, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getStartIndex());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testContravarianceTypeParameter5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = mappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = mappingParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(984, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameterContextAccept() {
    // Arrange
    MappingParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new MappingParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextAccept2() {
    // Arrange
    MappingParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new MappingParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(96,
        (new MappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testContravarianceTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testContravarianceTypeParameterContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testContravarianceTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(975, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testContravarianceTypeParameters3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(975, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testContravarianceTypeParameters4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [975])", actualContravarianceTypeParametersResult.toStringTree());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertTrue(((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(975, ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testContravarianceTypeParameters5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(975, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testContravarianceTypeParameters6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(57));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = mappingParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(975, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testContravarianceTypeParameters7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = mappingParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParametersContextAccept() {
    // Arrange
    MappingParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new MappingParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new MappingParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testContravarianceTypeParametersContextContravarianceTypeParameter() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
        .contravarianceTypeParameter()
        .isEmpty());
    assertNull((new MappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
        .contravarianceTypeParameter(1));
  }

  @Test
  public void testContravarianceTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(95,
        (new MappingParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.DefinitionContext actualDefinitionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token token = actualDefinitionResult.stop;
    Token start = actualDefinitionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualDefinitionResult.getStop());
    assertEquals(2, actualDefinitionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(1, tokenSource.getLine());
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals(2, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).depth());
    assertEquals(210, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertNull(((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).getStop());
    assertSame(start, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).getStart());
  }

  @Test
  public void testDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    MappingParserGrammar.DefinitionContext actualDefinitionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(0, stop.getLine());
    assertEquals("EOF", stop.getText());
    assertEquals(210, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertTrue(((MappingParserGrammar.MappingContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(211, ((MappingParserGrammar.MappingContext) parseTreeList.get(1)).invokingState);
    assertEquals(0, tokenSource.getLine());
  }

  @Test
  public void testDefinition3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    MappingParserGrammar.DefinitionContext actualDefinitionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(2, stop.getTokenIndex());
    assertEquals(0, stop.getLine());
    assertEquals("EOF", stop.getText());
    assertEquals(210, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertTrue(((MappingParserGrammar.MappingContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(211, ((MappingParserGrammar.MappingContext) parseTreeList.get(1)).invokingState);
    assertEquals(0, tokenSource.getLine());
  }

  @Test
  public void testDefinition4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    MappingParserGrammar.DefinitionContext actualDefinitionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull<missing '('><EOF>EOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(1, stop.getCharPositionInLine());
    assertEquals(2, stop.getStartIndex());
    assertEquals(1, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(3, stop.getTokenIndex());
    assertEquals(1, stop.getLine());
    assertEquals("EOF", stop.getText());
    assertEquals(210, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    String expectedSourceName = String.join("", "<", System.getProperty("sun.os.patch.level"), ">");
    assertEquals(expectedSourceName, tokenSource.getSourceName());
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
    assertTrue(((MappingParserGrammar.MappingContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.NoViableAltException);
    assertEquals(1, tokenSource.getLine());
    assertEquals(211, ((MappingParserGrammar.MappingContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testDefinition5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    MappingParserGrammar.DefinitionContext actualDefinitionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull<missing '('><EOF>nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(4, stop.getTokenIndex());
    assertEquals(0, stop.getLine());
    assertEquals("EOF", stop.getText());
    assertEquals(210, ((MappingParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertTrue(((MappingParserGrammar.MappingContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.NoViableAltException);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(211, ((MappingParserGrammar.MappingContext) parseTreeList.get(1)).invokingState);
    assertEquals(0, tokenSource.getLine());
  }

  @Test
  public void testDefinitionContextAccept() {
    // Arrange
    MappingParserGrammar.DefinitionContext definitionContext = new MappingParserGrammar.DefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(definitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefinitionContextAccept2() {
    // Arrange
    MappingParserGrammar.DefinitionContext definitionContext = new MappingParserGrammar.DefinitionContext(
        new ParserRuleContext(), 1);
    definitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(definitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefinitionContextEOF() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).EOF());
  }

  @Test
  public void testDefinitionContextImports() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).imports());
  }

  @Test
  public void testDefinitionContextMapping() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).mapping().isEmpty());
    assertNull((new MappingParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).mapping(1));
  }

  @Test
  public void testDsl() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslContext actualDslResult = mappingParserGrammar.dsl();

    // Assert
    RecognitionException recognitionException = actualDslResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDslResult.invokingState);
    assertNull(actualDslResult.getParent());
    Token expectedStart = actualDslResult.start;
    Token start = actualDslResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(890, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDslContent() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.DslContentContext actualDslContentResult = mappingParserGrammar.dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testDslContent2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslContentContext actualDslContentResult = mappingParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("null", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(901, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslContent3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslContentContext actualDslContentResult = mappingParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(901, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.DslContentContext actualDslContentResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testDslContent5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslContentContext actualDslContentResult = mappingParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(901, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslContentContext actualDslContentResult = mappingParserGrammar.dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testDslContentContextAccept() {
    // Arrange
    MappingParserGrammar.DslContentContext dslContentContext = new MappingParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextAccept2() {
    // Arrange
    MappingParserGrammar.DslContentContext dslContentContext = new MappingParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);
    dslContentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(85, (new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_CLOSE());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_OPEN());
  }

  @Test
  public void testDslContentContextISLAND_CONTENT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_CONTENT());
  }

  @Test
  public void testDslContentContextISLAND_END() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_END());
  }

  @Test
  public void testDslContentContextISLAND_HASH() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_HASH());
  }

  @Test
  public void testDslContentContextISLAND_START() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_START());
  }

  @Test
  public void testDslContextAccept() {
    // Arrange
    MappingParserGrammar.DslContext dslContext = new MappingParserGrammar.DslContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextAccept2() {
    // Arrange
    MappingParserGrammar.DslContext dslContext = new MappingParserGrammar.DslContext(new ParserRuleContext(), 1);
    dslContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextDslGraphFetch() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContext(new ParserRuleContext(), 1)).dslGraphFetch());
  }

  @Test
  public void testDslContextDslNavigationPath() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslContext(new ParserRuleContext(), 1)).dslNavigationPath());
  }

  @Test
  public void testDslContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(82, (new MappingParserGrammar.DslContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetch() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<18>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(18, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetch2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = mappingParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("null", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(894, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslGraphFetch3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = mappingParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(894, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals("<missing ISLAND_OPEN>", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslGraphFetch5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = mappingParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(894, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = mappingParserGrammar.dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<18>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(18, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetchContextAccept() {
    // Arrange
    MappingParserGrammar.DslGraphFetchContext dslGraphFetchContext = new MappingParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextAccept2() {
    // Arrange
    MappingParserGrammar.DslGraphFetchContext dslGraphFetchContext = new MappingParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);
    dslGraphFetchContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextDslContent() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent().isEmpty());
    assertNull((new MappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent(1));
  }

  @Test
  public void testDslGraphFetchContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(84, (new MappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetchContextISLAND_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).ISLAND_OPEN());
  }

  @Test
  public void testDslNavigationPath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<14>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(14, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = mappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("null", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(892, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslNavigationPath3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = mappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(892, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslNavigationPath5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = mappingParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(892, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = mappingParserGrammar
        .dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<14>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(14, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPathContextAccept() {
    // Arrange
    MappingParserGrammar.DslNavigationPathContext dslNavigationPathContext = new MappingParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextAccept2() {
    // Arrange
    MappingParserGrammar.DslNavigationPathContext dslNavigationPathContext = new MappingParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);
    dslNavigationPathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(83, (new MappingParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslNavigationPathContextNAVIGATION_PATH_BLOCK() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1)).NAVIGATION_PATH_BLOCK());
  }

  @Test
  public void testEnumReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = mappingParserGrammar.enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumReferenceResult.getStop());
    assertEquals(1, actualEnumReferenceResult.getChildCount());
    assertTrue(actualEnumReferenceResult.isEmpty());
    assertEquals("([] [506])", actualEnumReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(507, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(506, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testEnumReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = mappingParserGrammar.enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.stop;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumReferenceResult.getStop());
    assertEquals("null", actualEnumReferenceResult.getText());
    assertEquals(1, actualEnumReferenceResult.getChildCount());
    assertTrue(actualEnumReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(507, recognitionException.getOffendingState());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(506, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.EnumReferenceContext actualEnumReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).enumReference();

    // Assert
    assertEquals(-1, actualEnumReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualEnumReferenceResult.stop;
    Token stop = actualEnumReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualEnumReferenceResult.getText());
    assertEquals(3, actualEnumReferenceResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualEnumReferenceResult.identifier();
    assertEquals(508, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(506, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReferenceContextAccept() {
    // Arrange
    MappingParserGrammar.EnumReferenceContext enumReferenceContext = new MappingParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextAccept2() {
    // Arrange
    MappingParserGrammar.EnumReferenceContext enumReferenceContext = new MappingParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);
    enumReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testEnumReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(37, (new MappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEnumReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testEnumReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testEqualNotEqual() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = mappingParserGrammar.equalNotEqual();

    // Assert
    RecognitionException recognitionException = actualEqualNotEqualResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.start;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEqualNotEqualResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(537, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualEqualNotEqualResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testEqualNotEqual2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).equalNotEqual();

    // Assert
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    List<ParseTree> parseTreeList = actualEqualNotEqualResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.stop;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEqualNotEqualResult.getStop());
    assertEquals(1, actualEqualNotEqualResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.CombinedArithmeticOnlyContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedArithmeticOnlyContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedArithmeticOnlyContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedArithmeticOnlyContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([538] ([540 538] ([563 540 538] ([396 563 540 538] ([635 396 563 540 538] ([642 635 396 563 540 538]"
        + " ([1027 642 635 396 563 540 538] <EOF>)))))))", getResult.toStringTree());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testEqualNotEqualContextAccept() {
    // Arrange
    MappingParserGrammar.EqualNotEqualContext equalNotEqualContext = new MappingParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextAccept2() {
    // Arrange
    MappingParserGrammar.EqualNotEqualContext equalNotEqualContext = new MappingParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);
    equalNotEqualContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextCombinedArithmeticOnly() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).combinedArithmeticOnly());
  }

  @Test
  public void testEqualNotEqualContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(43, (new MappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEqualNotEqualContextTEST_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_EQUAL());
  }

  @Test
  public void testEqualNotEqualContextTEST_NOT_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_NOT_EQUAL());
  }

  @Test
  public void testExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).variable());
    assertEquals(2, ((MappingParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[635 396]", getResult1.toString());
    assertEquals(635, ((MappingParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionContext actualExpressionResult = mappingParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionContext expressionContext = new MappingParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionContext expressionContext = new MappingParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);
    expressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAtomicExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).atomicExpression());
  }

  @Test
  public void testExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testExpressionContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testExpressionContextExpressionsArray() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).expressionsArray());
  }

  @Test
  public void testExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(28, (new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionContextNotExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).notExpression());
  }

  @Test
  public void testExpressionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testExpressionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionContextPropertyOrFunctionExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).propertyOrFunctionExpression()
        .isEmpty());
    assertNull(
        (new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).propertyOrFunctionExpression(1));
  }

  @Test
  public void testExpressionContextSignedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).signedExpression());
  }

  @Test
  public void testExpressionContextSliceExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).sliceExpression());
  }

  @Test
  public void testExpressionInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = mappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceResult.invokingState);
    assertNull(actualExpressionInstanceResult.getParent());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(706, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testExpressionInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = mappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.getParent());
    assertNull(actualExpressionInstanceResult.variable());
    assertEquals(-1, actualExpressionInstanceResult.invokingState);
    Token token = actualExpressionInstanceResult.stop;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionInstanceResult.getStop());
    assertEquals("<missing '^'><EOF>", actualExpressionInstanceResult.getText());
    assertEquals("([] <missing '^'> ([708] ([1027 708] <EOF>)))", actualExpressionInstanceResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(720, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualExpressionInstanceResult, getResult.getParent());
    assertEquals(708, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<missing '^'>", getResult.toStringTree());
    assertEquals("<missing '^'>", getResult.getText());
  }

  @Test
  public void testExpressionInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = mappingParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.getParent());
    assertNull(actualExpressionInstanceResult.variable());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualExpressionInstanceResult.stop;
    Token stop = actualExpressionInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertTrue(actualExpressionInstanceResult.isEmpty());
    assertEquals("<missing '^'><EOF>null", actualExpressionInstanceResult.getText());
    assertEquals(722, actualExpressionInstanceResult.identifier().invokingState);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(725, recognitionException.getOffendingState());
    assertEquals("[@1,0:0='<no text>',<1>,0:-1]", stop.toString());
    assertEquals(708, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(743, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(743, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = mappingParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(743, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .expressionInstance());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(68,
        (new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceContext expressionInstanceContext = new MappingParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceContext expressionInstanceContext = new MappingParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);
    expressionInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionInstanceContextExpressionInstanceParserPropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment()
        .isEmpty());
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment(1));
  }

  @Test
  public void testExpressionInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testExpressionInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(66, (new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testExpressionInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testExpressionInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testExpressionInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testExpressionInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testExpressionInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testExpressionInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testExpressionInstanceContextVariable() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = mappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.start;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    assertEquals("([] [745])", actualExpressionInstanceParserPropertyAssignmentResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(756, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(745, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertTrue(((MappingParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = mappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(750, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(745, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = mappingParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(756, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(745, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertTrue(((MappingParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);
    expressionInstanceParserPropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextDOT() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1)).DOT()
            .isEmpty());
    assertNull((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .DOT(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .EQUAL());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextExpressionInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .expressionInstanceRightSide());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(69,
        (new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .identifier()
        .isEmpty());
    assertNull((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .identifier(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .PLUS());
  }

  @Test
  public void testExpressionInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = mappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = mappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = mappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(740, ((MappingParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = mappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = mappingParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start,
        ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new MappingParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new MappingParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextExpressionInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1))
        .expressionInstanceAtomicRightSide());
  }

  @Test
  public void testExpressionInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(67,
        (new MappingParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionOrExpressionGroup() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(563, expressionResult.invokingState);
    assertEquals(0, start.getTokenIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertNull(expressionResult.getStop());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroup2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals("null", expressionResult.getText());
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(396, ((MappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertEquals("[396 563]", getResult.toString());
  }

  @Test
  public void testExpressionOrExpressionGroup3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(563));

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals("null", expressionResult.getText());
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, expressionResult.children.size());
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroup4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(563, expressionResult.invokingState);
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, start.getLine());
    assertNull(expressionResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(415, recognitionException.getOffendingState());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertSame(start, recognitionException.getOffendingToken());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroup5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(48));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals("null", expressionResult.getText());
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(396, ((MappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertEquals("[396 563]", getResult.toString());
  }

  @Test
  public void testExpressionOrExpressionGroup6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(48));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = mappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    assertSame(token, actualExpressionOrExpressionGroupResult.getStart());
    Token stop = actualExpressionOrExpressionGroupResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals("null", expressionResult.getText());
    assertSame(stop, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertFalse(expressionResult.isEmpty());
    assertSame(stop, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(396, ((MappingParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertSame(stop, ((MappingParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertEquals("[396 563]", getResult.toString());
  }

  @Test
  public void testExpressionOrExpressionGroup7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = mappingParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(563, expressionResult.invokingState);
    assertEquals(0, start.getTokenIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertNull(expressionResult.getStop());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(415, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new MappingParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new MappingParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);
    expressionOrExpressionGroupContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testExpressionOrExpressionGroupContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(48,
        (new MappingParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionPartContext actualExpressionPartResult = mappingParserGrammar.expressionPart();

    // Assert
    RecognitionException recognitionException = actualExpressionPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionPartResult.invokingState);
    assertNull(actualExpressionPartResult.getParent());
    Token expectedStart = actualExpressionPartResult.start;
    Token start = actualExpressionPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(549, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionPartResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionPartContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionPartContext expressionPartContext = new MappingParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionPartContext expressionPartContext = new MappingParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);
    expressionPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextArithmeticPart() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).arithmeticPart());
  }

  @Test
  public void testExpressionPartContextBooleanPart() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).booleanPart());
  }

  @Test
  public void testExpressionPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(45, (new MappingParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionsArray() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = mappingParserGrammar.expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionsArrayResult.invokingState);
    assertNull(actualExpressionsArrayResult.getParent());
    Token expectedStart = actualExpressionsArrayResult.start;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionsArrayResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(565, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testExpressionsArray2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = mappingParserGrammar.expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionsArrayResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualExpressionsArrayResult.depth());
    Token expectedStart = actualExpressionsArrayResult.stop;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualExpressionsArrayResult.getChildCount());
    assertSame(start, actualExpressionsArrayResult.getStop());
    assertEquals("<missing '['><EOF>", actualExpressionsArrayResult.getText());
    assertTrue(actualExpressionsArrayResult.isEmpty());
    assertEquals("([] <missing '['> ([566] ([396 566] ([635 396 566] ([642 635 396 566] ([1027 642 635 396 566]"
        + " <EOF>))))))", actualExpressionsArrayResult.toStringTree());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(571, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, offendingToken.getType());
    assertEquals(566, ((MappingParserGrammar.ExpressionContext) parseTreeList.get(1)).invokingState);
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(0, offendingToken.getChannel());
  }

  @Test
  public void testExpressionsArrayContextAccept() {
    // Arrange
    MappingParserGrammar.ExpressionsArrayContext expressionsArrayContext = new MappingParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextAccept2() {
    // Arrange
    MappingParserGrammar.ExpressionsArrayContext expressionsArrayContext = new MappingParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);
    expressionsArrayContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testExpressionsArrayContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testExpressionsArrayContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionsArrayContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testExpressionsArrayContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(49, (new MappingParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<23>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(23, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = mappingParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("null", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(938, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFromMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = mappingParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(938, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals("<missing INTEGER>", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testFromMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = mappingParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(938, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = mappingParserGrammar.fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<23>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(23, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicityContextAccept() {
    // Arrange
    MappingParserGrammar.FromMultiplicityContext fromMultiplicityContext = new MappingParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextAccept2() {
    // Arrange
    MappingParserGrammar.FromMultiplicityContext fromMultiplicityContext = new MappingParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);
    fromMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(88, (new MappingParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = mappingParserGrammar
        .functionExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    assertNull(actualFunctionExpressionResult.getParent());
    Token expectedStart = actualFunctionExpressionResult.start;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(593, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionExpression();

    // Assert
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualFunctionExpressionResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '->'> ([594] ([1027 594] <EOF>)) [595])", actualFunctionExpressionResult.toStringTree());
    assertNull(actualFunctionExpressionResult.getParent());
    Token token = actualFunctionExpressionResult.stop;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualFunctionExpressionResult.getStop());
    assertEquals("<missing '->'><EOF>", actualFunctionExpressionResult.getText());
    assertEquals(3, actualFunctionExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(595, ((MappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).invokingState);
    assertTrue(((MappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2))
        .getStart() instanceof CommonToken);
    assertEquals(2, ((MappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).depth());
    assertSame(start, ((MappingParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).getStop());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    assertEquals(594, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    Interval expectedSourceInterval = actualFunctionExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertTrue(((MappingParserGrammar.FunctionExpressionParametersContext) parseTreeList
        .get(2)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[594]", getResult.toString());
  }

  @Test
  public void testFunctionExpressionContextARROW() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW().isEmpty());
    assertNull((new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW(1));
  }

  @Test
  public void testFunctionExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.FunctionExpressionContext functionExpressionContext = new MappingParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.FunctionExpressionContext functionExpressionContext = new MappingParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);
    functionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).functionExpressionParameters()
            .isEmpty());
    assertNull((new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters(1));
  }

  @Test
  public void testFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(53, (new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionExpressionContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).qualifiedName().isEmpty());
    assertNull((new MappingParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = mappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionLatestMilestoningDateParameterResult.invokingState);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.start;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(605, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = mappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(605, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(44));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = mappingParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(606, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept() {
    // Arrange
    MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept2() {
    // Arrange
    MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);
    functionExpressionLatestMilestoningDateParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextCOMMA() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .COMMA());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(54,
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .LATEST_DATE()
            .isEmpty());
    assertNull(
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .LATEST_DATE(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .PAREN_OPEN());
  }

  @Test
  public void testFunctionExpressionParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = mappingParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionParametersResult.invokingState);
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.start;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(613, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = mappingParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualFunctionExpressionParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.stop;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionParametersResult.getStop());
    assertEquals("<missing '('><EOF>", actualFunctionExpressionParametersResult.getText());
    assertEquals(2, actualFunctionExpressionParametersResult.getChildCount());
    assertTrue(actualFunctionExpressionParametersResult.isEmpty());
    assertEquals(
        "([] <missing '('> ([614] ([556 614] ([563 556 614] ([396 563 556 614] ([635 396 563 556 614] ([642 635"
            + " 396 563 556 614] ([1027 642 635 396 563 556 614] <EOF>))))))))",
        actualFunctionExpressionParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(619, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(614, ((MappingParserGrammar.CombinedExpressionContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testFunctionExpressionParametersContextAccept() {
    // Arrange
    MappingParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new MappingParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new MappingParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);
    functionExpressionParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testFunctionExpressionParametersContextCombinedExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).combinedExpression()
            .isEmpty());
    assertNull((new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
        .combinedExpression(1));
  }

  @Test
  public void testFunctionExpressionParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(55,
        (new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testFunctionTypePureType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    assertNull(actualFunctionTypePureTypeResult.getStop());
    assertEquals(-1, start.getType());
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertSame(start, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertNull(multiplicityResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    MappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertFalse(typeResult.isEmpty());
    assertNull(typeResult.getStop());
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
  }

  @Test
  public void testFunctionTypePureType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.stop;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    assertSame(start, actualFunctionTypePureTypeResult.getStop());
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertTrue(multiplicityResult.getStart() instanceof CommonToken);
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(start, multiplicityResult.getStop());
    MappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(2, typeResult.depth());
    assertEquals(942, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    Interval expectedSourceInterval = actualFunctionTypePureTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, typeResult.getSourceInterval());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testFunctionTypePureType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    Token stop = actualFunctionTypePureTypeResult.getStop();
    assertSame(expectedStop, stop);
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertEquals("([943] <missing '['> ([935 943] ([996 935 943] <EOF>)) <missing ']'>)",
        multiplicityResult.toStringTree());
    assertEquals("<missing '['><EOF><missing ']'>", multiplicityResult.getText());
    assertSame(stop, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(stop, multiplicityResult.getStop());
    assertEquals(3, multiplicityResult.getChildCount());
    MappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(942, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    assertEquals(2, typeResult.depth());
  }

  @Test
  public void testFunctionTypePureType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    CommonToken commonToken = new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1);
    tokenList.add(commonToken);
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    Token stop = actualFunctionTypePureTypeResult.getStop();
    assertSame(expectedStop, stop);
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertEquals("<missing '['><EOF>null", multiplicityResult.getText());
    assertSame(commonToken, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(stop, multiplicityResult.getStop());
    assertEquals(3, multiplicityResult.getChildCount());
    MappingParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(942, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, typeResult.depth());
  }

  @Test
  public void testFunctionTypePureTypeContextAccept() {
    // Arrange
    MappingParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new MappingParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextAccept2() {
    // Arrange
    MappingParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new MappingParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);
    functionTypePureTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(90, (new MappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionTypePureTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testFunctionTypePureTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testFunctionVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = mappingParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertNull(actualFunctionVariableExpressionResult.type());
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionVariableExpressionResult.getStop());
    MappingParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult.identifier();
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(883, identifierResult.invokingState);
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(884, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
  }

  @Test
  public void testFunctionVariableExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = mappingParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertNull(actualFunctionVariableExpressionResult.type());
    Token expectedStart = actualFunctionVariableExpressionResult.stop;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionVariableExpressionResult.getStop());
    assertEquals("null", actualFunctionVariableExpressionResult.getText());
    MappingParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult.identifier();
    assertEquals(883, identifierResult.invokingState);
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualFunctionVariableExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(884, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
  }

  @Test
  public void testFunctionVariableExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionVariableExpression();

    // Assert
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertEquals(4, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    assertSame(expectedStart, actualFunctionVariableExpressionResult.getStart());
    assertEquals(4, actualFunctionVariableExpressionResult.getChildCount());
    Token expectedStop = actualFunctionVariableExpressionResult.stop;
    Token stop = actualFunctionVariableExpressionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing ':'><EOF>", actualFunctionVariableExpressionResult.getText());
    assertEquals(883, actualFunctionVariableExpressionResult.identifier().invokingState);
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualFunctionVariableExpressionResult.multiplicity();
    assertTrue(multiplicityResult.getStart() instanceof CommonToken);
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(stop, multiplicityResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    MappingParserGrammar.TypeContext typeResult = actualFunctionVariableExpressionResult.type();
    assertEquals(885, typeResult.invokingState);
    assertEquals("<EOF>", typeResult.getText());
    assertSame(stop, typeResult.getStart());
    assertNull(typeResult.type());
    assertEquals(2, typeResult.depth());
    assertEquals("([885] ([903 885] ([1027 903 885] <EOF>)))", typeResult.toStringTree());
    assertSame(stop, typeResult.getStop());
  }

  @Test
  public void testFunctionVariableExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new MappingParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new MappingParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);
    functionVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testFunctionVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(81,
        (new MappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionVariableExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testFunctionVariableExpressionContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testFunctionVariableExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testIdentifier() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.IdentifierContext actualIdentifierResult = mappingParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Act
    MappingParserGrammar.IdentifierContext actualIdentifierResult = mappingParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier3() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));

    // Act
    MappingParserGrammar.IdentifierContext actualIdentifierResult = mappingParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testIdentifier4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.IdentifierContext actualIdentifierResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testIdentifier5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.IdentifierContext actualIdentifierResult = mappingParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testIdentifierContextALL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL_VERSIONS());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testIdentifierContextAccept() {
    // Arrange
    MappingParserGrammar.IdentifierContext identifierContext = new MappingParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextAccept2() {
    // Arrange
    MappingParserGrammar.IdentifierContext identifierContext = new MappingParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);
    identifierContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextEXTENDS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).EXTENDS());
  }

  @Test
  public void testIdentifierContextIMPORT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).IMPORT());
  }

  @Test
  public void testIdentifierContextINCLUDE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).INCLUDE());
  }

  @Test
  public void testIdentifierContextLET() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testIdentifierContextMAPPING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).MAPPING());
  }

  @Test
  public void testIdentifierContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testIdentifierContextTESTS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).TESTS());
  }

  @Test
  public void testIdentifierContextTEST_ASSERT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).TEST_ASSERT());
  }

  @Test
  public void testIdentifierContextTEST_INPUT_DATA() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).TEST_INPUT_DATA());
  }

  @Test
  public void testIdentifierContextTEST_QUERY() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).TEST_QUERY());
  }

  @Test
  public void testIdentifierContextVALID_STRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).VALID_STRING());
  }

  @Test
  public void testImportStatement() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ImportStatementContext actualImportStatementResult = mappingParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualImportStatementResult.invokingState);
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.start;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportStatementResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(225, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testImportStatement2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ImportStatementContext actualImportStatementResult = mappingParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualImportStatementResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.stop;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualImportStatementResult.getStop());
    assertEquals("<missing 'import'><EOF>", actualImportStatementResult.getText());
    assertEquals(2, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    assertEquals("([] <missing 'import'> ([226] ([1029 226] <EOF>)))", actualImportStatementResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(1034, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(parseTreeList.get(1), recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(226, ((MappingParserGrammar.PackagePathContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testImportStatementContextAccept() {
    // Arrange
    MappingParserGrammar.ImportStatementContext importStatementContext = new MappingParserGrammar.ImportStatementContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(importStatementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportStatementContextAccept2() {
    // Arrange
    MappingParserGrammar.ImportStatementContext importStatementContext = new MappingParserGrammar.ImportStatementContext(
        new ParserRuleContext(), 1);
    importStatementContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(importStatementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportStatementContextIMPORT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).IMPORT());
  }

  @Test
  public void testImportStatementContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testImportStatementContextPackagePath() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).packagePath());
  }

  @Test
  public void testImportStatementContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testImportStatementContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testImports() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImports2() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ImportsContext actualImportsResult = (new MappingParserGrammar(
        new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream())))).imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testImports3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImports4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ImportsContext actualImportsResult = (new MappingParserGrammar(
        new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream("Input"))))).imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    List<ParseTree> parseTreeList = actualImportsResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] ([219] I ([226 219] ([1029 226 219] n))) ([219] p ([226 219] ([1029 226 219] u))) ([219] t ([226"
        + " 219] [1029 226 219])))", actualImportsResult.toStringTree());
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualImportsResult.stop;
    Token stop = actualImportsResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("Input", actualImportsResult.getText());
    assertEquals(3, actualImportsResult.getChildCount());
    assertEquals(4, stop.getCharPositionInLine());
    assertEquals(4, stop.getStartIndex());
    assertEquals(4, stop.getStopIndex());
    assertEquals(0, stop.getChannel());
    assertEquals(2, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(2, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, start.getStopIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(4, stop.getTokenIndex());
    assertEquals(1, stop.getLine());
    assertEquals("I", start.getText());
    assertEquals("t", stop.getText());
    assertTrue(((MappingParserGrammar.ImportStatementContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(219, ((MappingParserGrammar.ImportStatementContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, ((CodeLexerGrammar) stop.getTokenSource()).getType());
    assertEquals(219, ((MappingParserGrammar.ImportStatementContext) parseTreeList.get(1)).invokingState);
    assertEquals(4, ((CodeLexerGrammar) stop.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(4, ((CodeLexerGrammar) stop.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) stop.getTokenSource())._hitEOF);
    assertNull(((CodeLexerGrammar) stop.getTokenSource())._text);
    assertTrue(((MappingParserGrammar.ImportStatementContext) parseTreeList
        .get(2)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(((MappingParserGrammar.ImportStatementContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(219, ((MappingParserGrammar.ImportStatementContext) parseTreeList.get(2)).invokingState);
    assertEquals(1, ((CodeLexerGrammar) stop.getTokenSource())._tokenStartLine);
    assertEquals(0, ((CodeLexerGrammar) stop.getTokenSource()).getChannel());
  }

  @Test
  public void testImports5() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImports6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImports7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(222));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImports8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(2));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ImportsContext actualImportsResult = mappingParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testImportsContextAccept() {
    // Arrange
    MappingParserGrammar.ImportsContext importsContext = new MappingParserGrammar.ImportsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(importsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportsContextAccept2() {
    // Arrange
    MappingParserGrammar.ImportsContext importsContext = new MappingParserGrammar.ImportsContext(
        new ParserRuleContext(), 1);
    importsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(importsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportsContextImportStatement() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.ImportsContext(new ParserRuleContext(), 1)).importStatement().isEmpty());
    assertNull((new MappingParserGrammar.ImportsContext(new ParserRuleContext(), 1)).importStatement(1));
  }

  @Test
  public void testIncludeMapping() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.IncludeMappingContext actualIncludeMappingResult = mappingParserGrammar.includeMapping();

    // Assert
    RecognitionException recognitionException = actualIncludeMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualIncludeMappingResult.invokingState);
    assertNull(actualIncludeMappingResult.getParent());
    Token expectedStart = actualIncludeMappingResult.start;
    Token start = actualIncludeMappingResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIncludeMappingResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(251, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualIncludeMappingResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testIncludeMapping2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.IncludeMappingContext actualIncludeMappingResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).includeMapping();

    // Assert
    assertEquals(-1, actualIncludeMappingResult.invokingState);
    List<ParseTree> parseTreeList = actualIncludeMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualIncludeMappingResult.getParent());
    Token token = actualIncludeMappingResult.stop;
    Token start = actualIncludeMappingResult.getStart();
    assertSame(token, start);
    assertSame(token, actualIncludeMappingResult.getStop());
    assertEquals(2, actualIncludeMappingResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([252] ([1027 252] <EOF>))", getResult.toStringTree());
    ParseTree getResult1 = parseTreeList.get(0);
    assertSame(actualIncludeMappingResult, getResult1.getParent());
    assertEquals("<missing 'include'>", getResult1.toString());
    assertEquals(1027, ((MappingParserGrammar.QualifiedNameContext) getResult).identifier().invokingState);
  }

  @Test
  public void testIncludeMappingContextAccept() {
    // Arrange
    MappingParserGrammar.IncludeMappingContext includeMappingContext = new MappingParserGrammar.IncludeMappingContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(includeMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIncludeMappingContextAccept2() {
    // Arrange
    MappingParserGrammar.IncludeMappingContext includeMappingContext = new MappingParserGrammar.IncludeMappingContext(
        new ParserRuleContext(), 1);
    includeMappingContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(includeMappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIncludeMappingContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testIncludeMappingContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testIncludeMappingContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testIncludeMappingContextINCLUDE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).INCLUDE());
  }

  @Test
  public void testIncludeMappingContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testIncludeMappingContextStoreSubPath() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).storeSubPath().isEmpty());
    assertNull((new MappingParserGrammar.IncludeMappingContext(new ParserRuleContext(), 1)).storeSubPath(1));
  }

  @Test
  public void testInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceContext actualInstanceResult = mappingParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceResult.invokingState);
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(417, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceContext actualInstanceResult = mappingParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.stop;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceResult.getStop());
    assertEquals("<missing '^'><EOF>", actualInstanceResult.getText());
    assertEquals(2, actualInstanceResult.getChildCount());
    assertTrue(actualInstanceResult.isEmpty());
    assertEquals("([] <missing '^'> ([418] ([1027 418] <EOF>)))", actualInstanceResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(428, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualInstanceResult, getResult.getParent());
    assertEquals(418, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<missing '^'>", getResult.toString());
    assertEquals("<missing '^'>", getResult.getText());
  }

  @Test
  public void testInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceContext actualInstanceResult = mappingParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    assertSame(expectedStart, actualInstanceResult.getStart());
    Token expectedStop = actualInstanceResult.stop;
    Token stop = actualInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '^'><EOF>null", actualInstanceResult.getText());
    assertEquals(3, actualInstanceResult.getChildCount());
    assertTrue(actualInstanceResult.isEmpty());
    MappingParserGrammar.IdentifierContext identifierResult = actualInstanceResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(447, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals(418, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(504, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(token, start);
    assertSame(token, actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 499]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(504, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = mappingParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(504, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new MappingParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new MappingParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextEnumReference() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).enumReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(36,
        (new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstance() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).instance());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).instanceLiteral());
  }

  @Test
  public void testInstanceAtomicRightSideContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).LATEST_DATE());
  }

  @Test
  public void testInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testInstanceAtomicRightSideContextStereotypeReference() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).stereotypeReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextTagReference() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).tagReference());
  }

  @Test
  public void testInstanceAtomicRightSideScalar() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = mappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = mappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = mappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).identifier());
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[499 481]", getResult1.toString());
    assertEquals(499, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = mappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = mappingParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new MappingParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new MappingParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideScalarContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(34,
        (new MappingParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide());
  }

  @Test
  public void testInstanceAtomicRightSideVector() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = mappingParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideVectorResult.invokingState);
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.start;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(483, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceAtomicRightSideVector2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = mappingParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideVectorResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.stop;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals("<missing '['><EOF>", actualInstanceAtomicRightSideVectorResult.getText());
    assertEquals(2, actualInstanceAtomicRightSideVectorResult.getChildCount());
    assertTrue(actualInstanceAtomicRightSideVectorResult.isEmpty());
    assertEquals("([] <missing '['> ([484] ([499 484] ([1027 499 484] <EOF>))))",
        actualInstanceAtomicRightSideVectorResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(489, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(484, ((MappingParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new MappingParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new MappingParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideVectorContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(35,
        (new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide()
        .isEmpty());
    assertNull((new MappingParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide(1));
  }

  @Test
  public void testInstanceContextAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testInstanceContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceContext instanceContext = new MappingParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceContext instanceContext = new MappingParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);
    instanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testInstanceContextFILE_NAME() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME());
  }

  @Test
  public void testInstanceContextFILE_NAME_END() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME_END());
  }

  @Test
  public void testInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(29, (new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceContextINTEGER() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER().isEmpty());
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER(1));
  }

  @Test
  public void testInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstanceContextInstancePropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).instancePropertyAssignment().isEmpty());
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).instancePropertyAssignment(1));
  }

  @Test
  public void testInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName().isEmpty());
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceLiteralContext actualInstanceLiteralResult = mappingParserGrammar.instanceLiteral();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceLiteralResult.invokingState);
    assertNull(actualInstanceLiteralResult.getParent());
    Token expectedStart = actualInstanceLiteralResult.start;
    Token start = actualInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(806, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceLiteralContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceLiteralContext instanceLiteralContext = new MappingParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceLiteralContext instanceLiteralContext = new MappingParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);
    instanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(76, (new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).instanceLiteralToken());
  }

  @Test
  public void testInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testInstanceLiteralToken() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = mappingParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralToken2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = mappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("null", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(808, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testInstanceLiteralToken3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = mappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(808, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testInstanceLiteralToken5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = mappingParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(808, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = mappingParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralTokenContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new MappingParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new MappingParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);
    instanceLiteralTokenContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testInstanceLiteralTokenContextDATE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DATE());
  }

  @Test
  public void testInstanceLiteralTokenContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralTokenContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralTokenContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(77, (new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceLiteralTokenContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralTokenContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testInstancePropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = mappingParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstancePropertyAssignmentResult.getStop());
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    MappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(474, recognitionException.getOffendingState());
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(-1, start.getStartIndex());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
  }

  @Test
  public void testInstancePropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = mappingParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.stop;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstancePropertyAssignmentResult.getStop());
    assertEquals("null", actualInstancePropertyAssignmentResult.getText());
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    MappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertEquals(473, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(474, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testInstancePropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instancePropertyAssignment();

    // Assert
    assertEquals(-1, actualInstancePropertyAssignmentResult.invokingState);
    List<ParseTree> parseTreeList = actualInstancePropertyAssignmentResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualInstancePropertyAssignmentResult.stop;
    Token stop = actualInstancePropertyAssignmentResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '='><EOF>", actualInstancePropertyAssignmentResult.getText());
    assertEquals(3, actualInstancePropertyAssignmentResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertEquals(473, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(475, ((MappingParserGrammar.InstanceRightSideContext) parseTreeList.get(2)).invokingState);
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept() {
    // Arrange
    MappingParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new MappingParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept2() {
    // Arrange
    MappingParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new MappingParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);
    instancePropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testInstancePropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(32,
        (new MappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstancePropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstancePropertyAssignmentContextInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).instanceRightSide());
  }

  @Test
  public void testInstanceReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(644, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(642, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testInstanceReference8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(644, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = mappingParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(644, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReferenceContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceReferenceContext instanceReferenceContext = new MappingParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceReferenceContext instanceReferenceContext = new MappingParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);
    instanceReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAllOrFunction() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).allOrFunction());
  }

  @Test
  public void testInstanceReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(57, (new MappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceReferenceContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testInstanceReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testInstanceReferenceContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(479, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(481, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertNull(((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).instance());
    assertEquals(3, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(479, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = mappingParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(479, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSideContextAccept() {
    // Arrange
    MappingParserGrammar.InstanceRightSideContext instanceRightSideContext = new MappingParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextAccept2() {
    // Arrange
    MappingParserGrammar.InstanceRightSideContext instanceRightSideContext = new MappingParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);
    instanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(33, (new MappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideScalar() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSideScalar());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideVector() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSideVector());
  }

  @Test
  public void testLambdaFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = mappingParserGrammar.lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaFunctionResult.invokingState);
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.start;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(649, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = mappingParserGrammar.lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualLambdaFunctionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.stop;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLambdaFunctionResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF>", actualLambdaFunctionResult.getText());
    assertEquals(2, actualLambdaFunctionResult.getChildCount());
    assertTrue(actualLambdaFunctionResult.isEmpty());
    assertEquals("([] <missing BRACE_OPEN> ([650] ([785 650] <EOF>)))", actualLambdaFunctionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(655, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(650, ((MappingParserGrammar.LambdaParamContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testLambdaFunctionContextAccept() {
    // Arrange
    MappingParserGrammar.LambdaFunctionContext lambdaFunctionContext = new MappingParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextAccept2() {
    // Arrange
    MappingParserGrammar.LambdaFunctionContext lambdaFunctionContext = new MappingParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);
    lambdaFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testLambdaFunctionContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testLambdaFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testLambdaFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(58, (new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaFunctionContextLambdaParam() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam().isEmpty());
    assertNull((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam(1));
  }

  @Test
  public void testLambdaFunctionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testLambdaParam() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(785, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testLambdaParam2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token token = actualLambdaParamResult.stop;
    assertSame(token, actualLambdaParamResult.getStart());
    Token stop = actualLambdaParamResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testLambdaParam3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.stop;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(785, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParam4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.LambdaParamContext actualLambdaParamResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(785, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testLambdaParam5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.LambdaParamContext actualLambdaParamResult = mappingParserGrammar.lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.stop;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(785, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParamContextAccept() {
    // Arrange
    MappingParserGrammar.LambdaParamContext lambdaParamContext = new MappingParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextAccept2() {
    // Arrange
    MappingParserGrammar.LambdaParamContext lambdaParamContext = new MappingParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);
    lambdaParamContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(74, (new MappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLambdaParamContextLambdaParamType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).lambdaParamType());
  }

  @Test
  public void testLambdaParamType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = mappingParserGrammar.lambdaParamType();

    // Assert
    RecognitionException recognitionException = actualLambdaParamTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertNull(actualLambdaParamTypeResult.getParent());
    Token expectedStart = actualLambdaParamTypeResult.start;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamTypeResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualLambdaParamTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(789, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaParamType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParamType();

    // Assert
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertEquals(3, actualLambdaParamTypeResult.children.size());
    assertNull(actualLambdaParamTypeResult.getParent());
    Token token = actualLambdaParamTypeResult.stop;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(token, start);
    assertEquals(3, actualLambdaParamTypeResult.getChildCount());
    assertSame(token, actualLambdaParamTypeResult.getStop());
    assertEquals("<missing ':'><EOF>", actualLambdaParamTypeResult.getText());
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualLambdaParamTypeResult.multiplicity();
    assertTrue(multiplicityResult.getStart() instanceof CommonToken);
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(start, multiplicityResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    MappingParserGrammar.TypeContext typeResult = actualLambdaParamTypeResult.type();
    assertEquals("([790] ([903 790] ([1027 903 790] <EOF>)))", typeResult.toStringTree());
    assertEquals("<EOF>", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    Interval expectedSourceInterval = actualLambdaParamTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, typeResult.getSourceInterval());
    assertEquals(790, typeResult.invokingState);
  }

  @Test
  public void testLambdaParamTypeContextAccept() {
    // Arrange
    MappingParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new MappingParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextAccept2() {
    // Arrange
    MappingParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new MappingParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);
    lambdaParamTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testLambdaParamTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(75, (new MappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testLambdaParamTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testLambdaPipe() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LambdaPipeContext actualLambdaPipeResult = mappingParserGrammar.lambdaPipe();

    // Assert
    RecognitionException recognitionException = actualLambdaPipeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    assertNull(actualLambdaPipeResult.getParent());
    Token expectedStart = actualLambdaPipeResult.start;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaPipeResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(782, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaPipeResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaPipe2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.LambdaPipeContext actualLambdaPipeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaPipe();

    // Assert
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    List<ParseTree> parseTreeList = actualLambdaPipeResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaPipeResult.getParent());
    Token token = actualLambdaPipeResult.stop;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualLambdaPipeResult.getStop());
    assertEquals(2, actualLambdaPipeResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CodeBlockContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CodeBlockContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CodeBlockContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CodeBlockContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '|'>", getResult1.toString());
    assertEquals("([783] ([521 783] ([533 521 783] ([556 533 521 783] ([563 556 533 521 783] ([396 563 556 533 521 783]"
        + " ([635 396 563 556 533 521 783] ([642 635 396 563 556 533 521 783] ([1027 642 635 396 563 556 533 521"
        + " 783] <EOF>)))))))))", getResult.toStringTree());
    assertSame(actualLambdaPipeResult, getResult1.getParent());
  }

  @Test
  public void testLambdaPipeContextAccept() {
    // Arrange
    MappingParserGrammar.LambdaPipeContext lambdaPipeContext = new MappingParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextAccept2() {
    // Arrange
    MappingParserGrammar.LambdaPipeContext lambdaPipeContext = new MappingParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);
    lambdaPipeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testLambdaPipeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(73, (new MappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaPipeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testLetExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LetExpressionContext actualLetExpressionResult = mappingParserGrammar.letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLetExpressionResult.invokingState);
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.start;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLetExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(551, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testLetExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.LetExpressionContext actualLetExpressionResult = mappingParserGrammar.letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualLetExpressionResult.children.size());
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.stop;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLetExpressionResult.getStop());
    assertEquals("<missing 'let'><EOF>", actualLetExpressionResult.getText());
    assertEquals(2, actualLetExpressionResult.getChildCount());
    assertTrue(actualLetExpressionResult.isEmpty());
    MappingParserGrammar.IdentifierContext identifierResult = actualLetExpressionResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(553, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testLetExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.LetExpressionContext letExpressionContext = new MappingParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.LetExpressionContext letExpressionContext = new MappingParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);
    letExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testLetExpressionContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testLetExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(46, (new MappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLetExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLetExpressionContextLET() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testMapping() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingContext actualMappingResult = mappingParserGrammar.mapping();

    // Assert
    RecognitionException recognitionException = actualMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMappingResult.invokingState);
    assertNull(actualMappingResult.getParent());
    Token expectedStart = actualMappingResult.start;
    Token start = actualMappingResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(231, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMapping2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingContext actualMappingResult = mappingParserGrammar.mapping();

    // Assert
    RecognitionException recognitionException = actualMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMappingResult.getParent());
    Token token = actualMappingResult.stop;
    assertSame(token, actualMappingResult.getStart());
    Token stop = actualMappingResult.getStop();
    assertSame(token, stop);
    assertEquals(2, actualMappingResult.getChildCount());
    assertTrue(actualMappingResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertEquals(233, recognitionException.getOffendingState());
    assertSame(actualMappingResult, recognitionException.getCtx());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, stop.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualMappingResult, getResult.getParent());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(232, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertNull(getResult.getText());
  }

  @Test
  public void testMapping3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingContext actualMappingResult = mappingParserGrammar.mapping();

    // Assert
    RecognitionException recognitionException = actualMappingResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMappingResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMappingResult.getParent());
    Token expectedStart = actualMappingResult.start;
    Token start = actualMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMappingResult.stop;
    Token stop = actualMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualMappingResult.getText());
    assertEquals(2, actualMappingResult.getChildCount());
    assertTrue(actualMappingResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(233, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualMappingResult, recognitionException.getCtx());
    assertEquals(232, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testMapping4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingContext actualMappingResult = mappingParserGrammar.mapping();

    // Assert
    RecognitionException recognitionException = actualMappingResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualMappingResult.children;
    assertEquals(4, parseTreeList.size());
    assertNull(actualMappingResult.getParent());
    Token expectedStart = actualMappingResult.start;
    Token start = actualMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMappingResult.stop;
    Token stop = actualMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull<missing '('><EOF>", actualMappingResult.getText());
    assertEquals(4, actualMappingResult.getChildCount());
    assertTrue(actualMappingResult.isEmpty());
    assertEquals("[@2,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(245, recognitionException.getOffendingState());
    assertTrue(((NoViableAltException) recognitionException).getStartToken() instanceof CommonToken);
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualMappingResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((MappingParserGrammar.MappingElementContext) parseTreeList
        .get(3)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(232, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals(240, ((MappingParserGrammar.MappingElementContext) parseTreeList.get(3)).invokingState);
  }

  @Test
  public void testMapping5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingContext actualMappingResult = mappingParserGrammar.mapping();

    // Assert
    RecognitionException recognitionException = actualMappingResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualMappingResult.children;
    assertEquals(5, parseTreeList.size());
    assertNull(actualMappingResult.getParent());
    Token expectedStart = actualMappingResult.start;
    Token start = actualMappingResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMappingResult.stop;
    Token stop = actualMappingResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull<missing '('><EOF>null", actualMappingResult.getText());
    assertEquals(5, actualMappingResult.getChildCount());
    assertTrue(actualMappingResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(245, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertTrue(((NoViableAltException) recognitionException).getStartToken() instanceof CommonToken);
    assertEquals("[@3,0:0='<no text>',<1>,0:-1]", stop.toString());
    assertSame(actualMappingResult, recognitionException.getCtx());
    assertEquals(240, ((MappingParserGrammar.MappingElementContext) parseTreeList.get(4)).invokingState);
    assertEquals(232, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals(240, ((MappingParserGrammar.MappingElementContext) parseTreeList.get(3)).invokingState);
    assertTrue(((MappingParserGrammar.MappingElementContext) parseTreeList
        .get(3)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(((MappingParserGrammar.MappingElementContext) parseTreeList
        .get(4)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMappingContextAccept() {
    // Arrange
    MappingParserGrammar.MappingContext mappingContext = new MappingParserGrammar.MappingContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingContext mappingContext = new MappingParserGrammar.MappingContext(
        new ParserRuleContext(), 1);
    mappingContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingContextIncludeMapping() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).includeMapping().isEmpty());
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).includeMapping(1));
  }

  @Test
  public void testMappingContextMAPPING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).MAPPING());
  }

  @Test
  public void testMappingContextMappingElement() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).mappingElement().isEmpty());
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).mappingElement(1));
  }

  @Test
  public void testMappingContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testMappingContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testMappingContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testMappingContextTests() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingContext(new ParserRuleContext(), 1)).tests());
  }

  @Test
  public void testMappingElement() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementContext actualMappingElementResult = mappingParserGrammar.mappingElement();

    // Assert
    RecognitionException recognitionException = actualMappingElementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMappingElementResult.invokingState);
    assertNull(actualMappingElementResult.getParent());
    Token expectedStart = actualMappingElementResult.start;
    Token start = actualMappingElementResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(276, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingElementResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMappingElement2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementContext actualMappingElementResult = mappingParserGrammar.mappingElement();

    // Assert
    RecognitionException recognitionException = actualMappingElementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMappingElementResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMappingElementResult.getParent());
    Token expectedStart = actualMappingElementResult.stop;
    Token start = actualMappingElementResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementResult.getStop());
    assertEquals("null", actualMappingElementResult.getText());
    assertEquals(1, actualMappingElementResult.getChildCount());
    assertTrue(actualMappingElementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(283, recognitionException.getOffendingState());
    assertSame(actualMappingElementResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(2, inputStream.size());
    assertEquals(278, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testMappingElement3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(56));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementContext actualMappingElementResult = mappingParserGrammar.mappingElement();

    // Assert
    RecognitionException recognitionException = actualMappingElementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMappingElementResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMappingElementResult.getParent());
    Token token = actualMappingElementResult.stop;
    assertSame(token, actualMappingElementResult.getStart());
    Token stop = actualMappingElementResult.getStop();
    assertSame(token, stop);
    assertEquals(2, actualMappingElementResult.getChildCount());
    assertTrue(actualMappingElementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertEquals(292, recognitionException.getOffendingState());
    assertSame(actualMappingElementResult, recognitionException.getCtx());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, stop.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualMappingElementResult, getResult.getParent());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(278, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertNull(getResult.getText());
  }

  @Test
  public void testMappingElementBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementBody();

    // Assert
    assertEquals(-1, actualMappingElementBodyResult.invokingState);
    List<ParseTree> parseTreeList = actualMappingElementBodyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.start;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyResult.getStop());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualMappingElementBodyResult, getResult.getParent());
    assertEquals("<missing BRACE_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing BRACE_OPEN>',<9>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(9, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing BRACE_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testMappingElementBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = mappingParserGrammar
        .mappingElementBody();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyResult.children.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.stop;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyResult.getStop());
    assertEquals("null", actualMappingElementBodyResult.getText());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertTrue(actualMappingElementBodyResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(299, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingElementBodyResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testMappingElementBody3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = mappingParserGrammar
        .mappingElementBody();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyResult.children.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.stop;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyResult.getStop());
    assertEquals("Input", actualMappingElementBodyResult.getText());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertTrue(actualMappingElementBodyResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(299, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualMappingElementBodyResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testMappingElementBody4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).mappingElementBody();

    // Assert
    assertEquals(-1, actualMappingElementBodyResult.invokingState);
    assertEquals(1, actualMappingElementBodyResult.children.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.start;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyResult.getStop());
    assertEquals("<missing BRACE_OPEN>", actualMappingElementBodyResult.getText());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testMappingElementBody5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = mappingParserGrammar
        .mappingElementBody();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyResult.children.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.stop;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyResult.getStop());
    assertEquals("Input", actualMappingElementBodyResult.getText());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertTrue(actualMappingElementBodyResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(299, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualMappingElementBodyResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testMappingElementBody6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementBodyContext actualMappingElementBodyResult = mappingParserGrammar
        .mappingElementBody();

    // Assert
    assertEquals(-1, actualMappingElementBodyResult.invokingState);
    List<ParseTree> parseTreeList = actualMappingElementBodyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMappingElementBodyResult.getParent());
    Token expectedStart = actualMappingElementBodyResult.start;
    Token start = actualMappingElementBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyResult.getStop());
    assertEquals(1, actualMappingElementBodyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualMappingElementBodyResult, getResult.getParent());
    assertEquals("<missing BRACE_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing BRACE_OPEN>',<9>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(9, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing BRACE_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testMappingElementBodyContent() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = mappingParserGrammar
        .mappingElementBodyContent();

    // Assert
    assertEquals(-1, actualMappingElementBodyContentResult.invokingState);
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.start;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testMappingElementBodyContent2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = mappingParserGrammar
        .mappingElementBodyContent();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyContentResult.children.size());
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.stop;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyContentResult.getStop());
    assertEquals("null", actualMappingElementBodyContentResult.getText());
    assertEquals(1, actualMappingElementBodyContentResult.getChildCount());
    assertTrue(actualMappingElementBodyContentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(306, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMappingElementBodyContentResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testMappingElementBodyContent3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = mappingParserGrammar
        .mappingElementBodyContent();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyContentResult.children.size());
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.stop;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyContentResult.getStop());
    assertEquals("Input", actualMappingElementBodyContentResult.getText());
    assertEquals(1, actualMappingElementBodyContentResult.getChildCount());
    assertTrue(actualMappingElementBodyContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(306, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualMappingElementBodyContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testMappingElementBodyContent4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).mappingElementBodyContent();

    // Assert
    assertEquals(-1, actualMappingElementBodyContentResult.invokingState);
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.start;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyContentResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testMappingElementBodyContent5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = mappingParserGrammar
        .mappingElementBodyContent();

    // Assert
    RecognitionException recognitionException = actualMappingElementBodyContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualMappingElementBodyContentResult.children.size());
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.stop;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMappingElementBodyContentResult.getStop());
    assertEquals("Input", actualMappingElementBodyContentResult.getText());
    assertEquals(1, actualMappingElementBodyContentResult.getChildCount());
    assertTrue(actualMappingElementBodyContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(306, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualMappingElementBodyContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testMappingElementBodyContent6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementBodyContentContext actualMappingElementBodyContentResult = mappingParserGrammar
        .mappingElementBodyContent();

    // Assert
    assertEquals(-1, actualMappingElementBodyContentResult.invokingState);
    assertNull(actualMappingElementBodyContentResult.getParent());
    Token expectedStart = actualMappingElementBodyContentResult.start;
    Token start = actualMappingElementBodyContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementBodyContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testMappingElementBodyContentContextAccept() {
    // Arrange
    MappingParserGrammar.MappingElementBodyContentContext mappingElementBodyContentContext = new MappingParserGrammar.MappingElementBodyContentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingElementBodyContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementBodyContentContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingElementBodyContentContext mappingElementBodyContentContext = new MappingParserGrammar.MappingElementBodyContentContext(
        new ParserRuleContext(), 1);
    mappingElementBodyContentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingElementBodyContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementBodyContentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(11,
        (new MappingParserGrammar.MappingElementBodyContentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMappingElementBodyContentContextMAPPING_ISLAND_BRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementBodyContentContext(new ParserRuleContext(), 1))
        .MAPPING_ISLAND_BRACE_CLOSE());
  }

  @Test
  public void testMappingElementBodyContentContextMAPPING_ISLAND_BRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementBodyContentContext(new ParserRuleContext(), 1))
        .MAPPING_ISLAND_BRACE_OPEN());
  }

  @Test
  public void testMappingElementBodyContentContextMAPPING_ISLAND_CONTENT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementBodyContentContext(new ParserRuleContext(), 1))
        .MAPPING_ISLAND_CONTENT());
  }

  @Test
  public void testMappingElementBodyContextAccept() {
    // Arrange
    MappingParserGrammar.MappingElementBodyContext mappingElementBodyContext = new MappingParserGrammar.MappingElementBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingElementBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementBodyContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingElementBodyContext mappingElementBodyContext = new MappingParserGrammar.MappingElementBodyContext(
        new ParserRuleContext(), 1);
    mappingElementBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingElementBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testMappingElementBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(10, (new MappingParserGrammar.MappingElementBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMappingElementBodyContextMappingElementBodyContent() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.MappingElementBodyContext(new ParserRuleContext(), 1)).mappingElementBodyContent()
            .isEmpty());
    assertNull(
        (new MappingParserGrammar.MappingElementBodyContext(new ParserRuleContext(), 1)).mappingElementBodyContent(1));
  }

  @Test
  public void testMappingElementContextAccept() {
    // Arrange
    MappingParserGrammar.MappingElementContext mappingElementContext = new MappingParserGrammar.MappingElementContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingElementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingElementContext mappingElementContext = new MappingParserGrammar.MappingElementContext(
        new ParserRuleContext(), 1);
    mappingElementContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingElementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).BRACKET_CLOSE().isEmpty());
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).BRACKET_CLOSE(1));
  }

  @Test
  public void testMappingElementContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).BRACKET_OPEN().isEmpty());
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).BRACKET_OPEN(1));
  }

  @Test
  public void testMappingElementContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testMappingElementContextEXTENDS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).EXTENDS());
  }

  @Test
  public void testMappingElementContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(9, (new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMappingElementContextMappingElementBody() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).mappingElementBody());
  }

  @Test
  public void testMappingElementContextMappingElementId() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).mappingElementId());
  }

  @Test
  public void testMappingElementContextMappingElementName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).mappingElementName());
  }

  @Test
  public void testMappingElementContextParserName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).parserName());
  }

  @Test
  public void testMappingElementContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testMappingElementContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testMappingElementContextSuperClassMappingId() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementContext(new ParserRuleContext(), 1)).superClassMappingId());
  }

  @Test
  public void testMappingElementId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token expectedStart = actualMappingElementIdResult.start;
    Token start = actualMappingElementIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementIdResult.getStop());
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token token = actualMappingElementIdResult.stop;
    assertSame(token, actualMappingElementIdResult.getStart());
    Token stop = actualMappingElementIdResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementIdResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 314]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementId3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token token = actualMappingElementIdResult.stop;
    assertSame(token, actualMappingElementIdResult.getStart());
    Token stop = actualMappingElementIdResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementIdResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 314]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementId4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token token = actualMappingElementIdResult.stop;
    assertSame(token, actualMappingElementIdResult.getStart());
    Token stop = actualMappingElementIdResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementIdResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 314]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementId5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = mappingParserGrammar.mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token token = actualMappingElementIdResult.stop;
    assertSame(token, actualMappingElementIdResult.getStart());
    Token stop = actualMappingElementIdResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementIdResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 314]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementId6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = mappingParserGrammar.mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token token = actualMappingElementIdResult.stop;
    assertSame(token, actualMappingElementIdResult.getStart());
    Token stop = actualMappingElementIdResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementIdResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 314]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementId7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = mappingParserGrammar.mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token expectedStart = actualMappingElementIdResult.start;
    Token start = actualMappingElementIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementIdResult.getStop());
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementId8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.MappingElementIdContext actualMappingElementIdResult = mappingParserGrammar.mappingElementId();

    // Assert
    assertEquals(-1, actualMappingElementIdResult.invokingState);
    assertEquals(1, actualMappingElementIdResult.children.size());
    assertNull(actualMappingElementIdResult.getParent());
    Token expectedStart = actualMappingElementIdResult.start;
    Token start = actualMappingElementIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementIdResult.getStop());
    assertEquals(1, actualMappingElementIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementIdResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementIdContextAccept() {
    // Arrange
    MappingParserGrammar.MappingElementIdContext mappingElementIdContext = new MappingParserGrammar.MappingElementIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingElementIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementIdContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingElementIdContext mappingElementIdContext = new MappingParserGrammar.MappingElementIdContext(
        new ParserRuleContext(), 1);
    mappingElementIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingElementIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(15, (new MappingParserGrammar.MappingElementIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMappingElementIdContextWord() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementIdContext(new ParserRuleContext(), 1)).word());
  }

  @Test
  public void testMappingElementName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token expectedStart = actualMappingElementNameResult.start;
    Token start = actualMappingElementNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementNameResult.getStop());
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token token = actualMappingElementNameResult.stop;
    assertSame(token, actualMappingElementNameResult.getStart());
    Token stop = actualMappingElementNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    assertEquals(308, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementNameResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 308]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token token = actualMappingElementNameResult.stop;
    assertSame(token, actualMappingElementNameResult.getStart());
    Token stop = actualMappingElementNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    assertEquals(308, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementNameResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 308]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementName4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token token = actualMappingElementNameResult.stop;
    assertSame(token, actualMappingElementNameResult.getStart());
    Token stop = actualMappingElementNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    assertEquals(308, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementNameResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 308]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementName5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = mappingParserGrammar
        .mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token token = actualMappingElementNameResult.stop;
    assertSame(token, actualMappingElementNameResult.getStart());
    Token stop = actualMappingElementNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    assertEquals(308, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementNameResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 308]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementName6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = mappingParserGrammar
        .mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token token = actualMappingElementNameResult.stop;
    assertSame(token, actualMappingElementNameResult.getStart());
    Token stop = actualMappingElementNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    assertEquals(308, wordResult.invokingState);
    assertEquals(1, wordResult.children.size());
    assertEquals("null", wordResult.getText());
    assertSame(stop, wordResult.getStop());
    assertEquals(2, wordResult.depth());
    assertSame(stop, wordResult.getStart());
    assertEquals(1, wordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    Interval expectedSourceInterval = actualMappingElementNameResult.getSourceInterval();
    MappingParserGrammar.IdentifierContext identifierResult = wordResult.identifier();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1037 308]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(1037, identifierResult.invokingState);
  }

  @Test
  public void testMappingElementName7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = mappingParserGrammar
        .mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token expectedStart = actualMappingElementNameResult.start;
    Token start = actualMappingElementNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementNameResult.getStop());
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementName8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.MappingElementNameContext actualMappingElementNameResult = mappingParserGrammar
        .mappingElementName();

    // Assert
    assertEquals(-1, actualMappingElementNameResult.invokingState);
    assertEquals(1, actualMappingElementNameResult.children.size());
    assertNull(actualMappingElementNameResult.getParent());
    Token expectedStart = actualMappingElementNameResult.start;
    Token start = actualMappingElementNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMappingElementNameResult.getStop());
    assertEquals(1, actualMappingElementNameResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    MappingParserGrammar.WordContext wordResult = actualMappingElementNameResult.word();
    RecognitionException recognitionException = wordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, wordResult.getStart());
    assertEquals(2, wordResult.depth());
    assertFalse(wordResult.isEmpty());
    assertNull(wordResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, tokenSource.getLine());
    assertSame(wordResult, recognitionException.getCtx());
  }

  @Test
  public void testMappingElementNameContextAccept() {
    // Arrange
    MappingParserGrammar.MappingElementNameContext mappingElementNameContext = new MappingParserGrammar.MappingElementNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(mappingElementNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementNameContextAccept2() {
    // Arrange
    MappingParserGrammar.MappingElementNameContext mappingElementNameContext = new MappingParserGrammar.MappingElementNameContext(
        new ParserRuleContext(), 1);
    mappingElementNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(mappingElementNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMappingElementNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(12, (new MappingParserGrammar.MappingElementNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMappingElementNameContextWord() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MappingElementNameContext(new ParserRuleContext(), 1)).word());
  }

  @Test
  public void testMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MultiplicityContext actualMultiplicityResult = mappingParserGrammar.multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityResult.invokingState);
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(934, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.MultiplicityContext actualMultiplicityResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicity();

    // Assert
    assertEquals(-1, actualMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '['> ([935] ([996 935] <EOF>)) <missing ']'>)", actualMultiplicityResult.toStringTree());
    assertNull(actualMultiplicityResult.getParent());
    Token token = actualMultiplicityResult.stop;
    Token start = actualMultiplicityResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplicityResult.getStop());
    assertEquals("<missing '['><EOF><missing ']'>", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing ']'>", getResult1.getText());
    assertEquals("<missing ']'>", getResult1.toString());
    assertSame(actualMultiplicityResult, getResult1.getParent());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertEquals(935, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
  }

  @Test
  public void testMultiplicity3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MultiplicityContext actualMultiplicityResult = mappingParserGrammar.multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMultiplicityResult.stop;
    Token stop = actualMultiplicityResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '['><EOF>null", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertTrue(actualMultiplicityResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertEquals(936, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(stop, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertEquals(935, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testMultiplicityArgument() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = mappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1003, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgument2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArgument();

    // Assert
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    MappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    MappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    MappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = mappingParserGrammar
        .multiplicityArgument();

    // Assert
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    MappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = mappingParserGrammar
        .multiplicityArgument();

    // Assert
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.stop;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    MappingParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = mappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1003, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgument8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = mappingParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.depth());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1003, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgumentContextAccept() {
    // Arrange
    MappingParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new MappingParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextAccept2() {
    // Arrange
    MappingParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new MappingParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextDOT_DOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).DOT_DOT());
  }

  @Test
  public void testMultiplicityArgumentContextFromMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).fromMultiplicity());
  }

  @Test
  public void testMultiplicityArgumentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(98, (new MappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testMultiplicityArgumentContextToMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).toMultiplicity());
  }

  @Test
  public void testMultiplicityArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(988, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(start, identifierResult.getStop());
    assertEquals(996, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(988, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(start, identifierResult.getStop());
    assertEquals(996, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(988, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(start, identifierResult.getStop());
    assertEquals(996, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = mappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(988, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(start, identifierResult.getStop());
    assertEquals(996, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = mappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(988, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) getResult).depth());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertSame(start, identifierResult.getStop());
    assertEquals(996, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testMultiplicityArguments7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = mappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = mappingParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((MappingParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArgumentsContextAccept() {
    // Arrange
    MappingParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new MappingParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextAccept2() {
    // Arrange
    MappingParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new MappingParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplicityArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(97,
        (new MappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentsContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).multiplicityArgument()
            .isEmpty());
    assertNull(
        (new MappingParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).multiplicityArgument(1));
  }

  @Test
  public void testMultiplicityContextAccept() {
    // Arrange
    MappingParserGrammar.MultiplicityContext multiplicityContext = new MappingParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextAccept2() {
    // Arrange
    MappingParserGrammar.MultiplicityContext multiplicityContext = new MappingParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);
    multiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testMultiplicityContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(87, (new MappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).multiplicityArgument());
  }

  @Test
  public void testMultiplictyParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = mappingParserGrammar
        .multiplictyParameters();

    // Assert
    RecognitionException recognitionException = actualMultiplictyParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    assertNull(actualMultiplictyParametersResult.getParent());
    Token expectedStart = actualMultiplictyParametersResult.start;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplictyParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1013, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplictyParametersResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplictyParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplictyParameters();

    // Assert
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplictyParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMultiplictyParametersResult.getParent());
    Token token = actualMultiplictyParametersResult.stop;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplictyParametersResult.getStop());
    assertEquals("<missing '|'><EOF>", actualMultiplictyParametersResult.getText());
    assertEquals(2, actualMultiplictyParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((MappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertSame(actualMultiplictyParametersResult, parseTreeList.get(0).getParent());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testMultiplictyParametersContextAccept() {
    // Arrange
    MappingParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new MappingParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new MappingParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);
    multiplictyParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplictyParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(100,
        (new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplictyParametersContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue(
        (new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testMultiplictyParametersContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testNotExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.NotExpressionContext actualNotExpressionResult = mappingParserGrammar.notExpression();

    // Assert
    RecognitionException recognitionException = actualNotExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualNotExpressionResult.invokingState);
    assertNull(actualNotExpressionResult.getParent());
    Token expectedStart = actualNotExpressionResult.start;
    Token start = actualNotExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNotExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(776, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualNotExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testNotExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.NotExpressionContext actualNotExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).notExpression();

    // Assert
    assertEquals(-1, actualNotExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualNotExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNotExpressionResult.getParent());
    Token token = actualNotExpressionResult.stop;
    Token start = actualNotExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualNotExpressionResult.getStop());
    assertEquals("<missing '!'><EOF>", actualNotExpressionResult.getText());
    assertEquals(2, actualNotExpressionResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualNotExpressionResult.expression();
    assertEquals(777, expressionResult.invokingState);
    List<ParseTree> parseTreeList1 = expressionResult.children;
    assertEquals(1, parseTreeList1.size());
    assertEquals("([777] ([396 777] ([635 396 777] ([642 635 396 777] ([1027 642 635 396 777] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertSame(actualNotExpressionResult, parseTreeList.get(0).getParent());
    assertEquals(396, ((MappingParserGrammar.AtomicExpressionContext) parseTreeList1.get(0)).invokingState);
  }

  @Test
  public void testNotExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.NotExpressionContext notExpressionContext = new MappingParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.NotExpressionContext notExpressionContext = new MappingParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);
    notExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testNotExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(71, (new MappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testNotExpressionContextNOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).NOT());
  }

  @Test
  public void testPackagePath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.PackagePathContext actualPackagePathResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPackagePath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.PackagePathContext actualPackagePathResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((MappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertNull(getResult1.toString());
  }

  @Test
  public void testPackagePath3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.PackagePathContext actualPackagePathResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((MappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePath4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.PackagePathContext actualPackagePathResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [1029])", actualPackagePathResult.toStringTree());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(1029, ((MappingParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testPackagePath5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.PackagePathContext actualPackagePathResult = mappingParserGrammar.packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((MappingParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePathContextAccept() {
    // Arrange
    MappingParserGrammar.PackagePathContext packagePathContext = new MappingParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextAccept2() {
    // Arrange
    MappingParserGrammar.PackagePathContext packagePathContext = new MappingParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);
    packagePathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(102, (new MappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPackagePathContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new MappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testPackagePathContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR().isEmpty());
    assertNull((new MappingParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR(1));
  }

  @Test
  public void testParserName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.ParserNameContext actualParserNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).parserName();

    // Assert
    assertEquals(-1, actualParserNameResult.invokingState);
    assertEquals(1, actualParserNameResult.children.size());
    assertNull(actualParserNameResult.getParent());
    Token expectedStart = actualParserNameResult.start;
    Token start = actualParserNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualParserNameResult.getStop());
    assertEquals(1, actualParserNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualParserNameResult.identifier();
    assertEquals(310, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testParserName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ParserNameContext actualParserNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).parserName();

    // Assert
    assertEquals(-1, actualParserNameResult.invokingState);
    assertEquals(1, actualParserNameResult.children.size());
    assertNull(actualParserNameResult.getParent());
    Token token = actualParserNameResult.stop;
    assertSame(token, actualParserNameResult.getStart());
    Token stop = actualParserNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualParserNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualParserNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testParserName3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ParserNameContext actualParserNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).parserName();

    // Assert
    assertEquals(-1, actualParserNameResult.invokingState);
    assertEquals(1, actualParserNameResult.children.size());
    assertNull(actualParserNameResult.getParent());
    Token expectedStart = actualParserNameResult.stop;
    Token start = actualParserNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualParserNameResult.getStop());
    assertEquals(1, actualParserNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualParserNameResult.identifier();
    assertEquals(310, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testParserName4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ParserNameContext actualParserNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).parserName();

    // Assert
    assertEquals(-1, actualParserNameResult.invokingState);
    assertEquals(1, actualParserNameResult.children.size());
    assertNull(actualParserNameResult.getParent());
    Token expectedStart = actualParserNameResult.start;
    Token start = actualParserNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualParserNameResult.getStop());
    assertEquals(1, actualParserNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualParserNameResult.identifier();
    assertEquals(310, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testParserName5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ParserNameContext actualParserNameResult = mappingParserGrammar.parserName();

    // Assert
    assertEquals(-1, actualParserNameResult.invokingState);
    assertEquals(1, actualParserNameResult.children.size());
    assertNull(actualParserNameResult.getParent());
    Token expectedStart = actualParserNameResult.stop;
    Token start = actualParserNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualParserNameResult.getStop());
    assertEquals(1, actualParserNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualParserNameResult.identifier();
    assertEquals(310, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testParserNameContextAccept() {
    // Arrange
    MappingParserGrammar.ParserNameContext parserNameContext = new MappingParserGrammar.ParserNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(parserNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testParserNameContextAccept2() {
    // Arrange
    MappingParserGrammar.ParserNameContext parserNameContext = new MappingParserGrammar.ParserNameContext(
        new ParserRuleContext(), 1);
    parserNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(parserNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testParserNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(13, (new MappingParserGrammar.ParserNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testParserNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ParserNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testProgramLine() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(535, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(535, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((MappingParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(556, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStart());
    assertEquals(3, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    assertSame(start, ((MappingParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testProgramLine9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ProgramLineContext actualProgramLineResult = mappingParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(535, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLineContextAccept() {
    // Arrange
    MappingParserGrammar.ProgramLineContext programLineContext = new MappingParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextAccept2() {
    // Arrange
    MappingParserGrammar.ProgramLineContext programLineContext = new MappingParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);
    programLineContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testProgramLineContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(42, (new MappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testProgramLineContextLetExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).letExpression());
  }

  @Test
  public void testPropertyBracketExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = mappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyBracketExpressionResult.invokingState);
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.start;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyBracketExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(589, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyBracketExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = mappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(589, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(42));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = mappingParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(590, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new MappingParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new MappingParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);
    propertyBracketExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testPropertyBracketExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(52,
        (new MappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyBracketExpressionContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testPropertyBracketExpressionContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testPropertyExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = mappingParserGrammar
        .propertyExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    assertNull(actualPropertyExpressionResult.getParent());
    Token expectedStart = actualPropertyExpressionResult.start;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(583, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualPropertyExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testPropertyExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyExpression();

    // Assert
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualPropertyExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPropertyExpressionResult.getParent());
    Token token = actualPropertyExpressionResult.stop;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualPropertyExpressionResult.getStop());
    assertEquals("<missing '.'><EOF>", actualPropertyExpressionResult.getText());
    assertEquals(2, actualPropertyExpressionResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualPropertyExpressionResult.identifier();
    assertEquals(584, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualPropertyExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testPropertyExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.PropertyExpressionContext propertyExpressionContext = new MappingParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.PropertyExpressionContext propertyExpressionContext = new MappingParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);
    propertyExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionLatestMilestoningDateParameter() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionLatestMilestoningDateParameter());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters());
  }

  @Test
  public void testPropertyExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(51, (new MappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyOrFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.PropertyOrFunctionExpressionContext actualPropertyOrFunctionExpressionResult = mappingParserGrammar
        .propertyOrFunctionExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyOrFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyOrFunctionExpressionResult.invokingState);
    assertNull(actualPropertyOrFunctionExpressionResult.getParent());
    Token expectedStart = actualPropertyOrFunctionExpressionResult.start;
    Token start = actualPropertyOrFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyOrFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(581, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyOrFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new MappingParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new MappingParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);
    propertyOrFunctionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextFunctionExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
        .functionExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(50,
        (new MappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyBracketExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
        .propertyBracketExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
        .propertyExpression());
  }

  @Test
  public void testPropertyReturnType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    assertNull(actualPropertyReturnTypeResult.getStop());
    assertEquals(-1, start.getType());
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertSame(start, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertNull(multiplicityResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    MappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertFalse(typeResult.isEmpty());
    assertNull(typeResult.getStop());
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
  }

  @Test
  public void testPropertyReturnType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.stop;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    assertSame(start, actualPropertyReturnTypeResult.getStop());
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertTrue(multiplicityResult.getStart() instanceof CommonToken);
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(start, multiplicityResult.getStop());
    MappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(2, typeResult.depth());
    assertEquals(518, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    Interval expectedSourceInterval = actualPropertyReturnTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, typeResult.getSourceInterval());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testPropertyReturnType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    Token stop = actualPropertyReturnTypeResult.getStop();
    assertSame(expectedStop, stop);
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertEquals("([519] <missing '['> ([935 519] ([996 935 519] <EOF>)) <missing ']'>)",
        multiplicityResult.toStringTree());
    assertEquals("<missing '['><EOF><missing ']'>", multiplicityResult.getText());
    assertSame(stop, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(stop, multiplicityResult.getStop());
    assertEquals(3, multiplicityResult.getChildCount());
    MappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(518, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    assertEquals(2, typeResult.depth());
  }

  @Test
  public void testPropertyReturnType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    CommonToken commonToken = new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1);
    tokenList.add(commonToken);
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    Token stop = actualPropertyReturnTypeResult.getStop();
    assertSame(expectedStop, stop);
    MappingParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertEquals("<missing '['><EOF>null", multiplicityResult.getText());
    assertSame(commonToken, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertFalse(multiplicityResult.isEmpty());
    assertSame(stop, multiplicityResult.getStop());
    assertEquals(3, multiplicityResult.getChildCount());
    MappingParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(518, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertNull(typeResult.type());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, typeResult.depth());
  }

  @Test
  public void testPropertyReturnTypeContextAccept() {
    // Arrange
    MappingParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new MappingParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextAccept2() {
    // Arrange
    MappingParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new MappingParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);
    propertyReturnTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(40, (new MappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyReturnTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testPropertyReturnTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testQualifiedName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = mappingParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1025, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = mappingParserGrammar.qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = mappingParserGrammar.qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = mappingParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1025, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.QualifiedNameContext actualQualifiedNameResult = mappingParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1025, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedNameContextAccept() {
    // Arrange
    MappingParserGrammar.QualifiedNameContext qualifiedNameContext = new MappingParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextAccept2() {
    // Arrange
    MappingParserGrammar.QualifiedNameContext qualifiedNameContext = new MappingParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);
    qualifiedNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(101, (new MappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testQualifiedNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testQualifiedNameContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testQualifiedNameContextPackagePath() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).packagePath());
  }

  @Test
  public void testSignedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.SignedExpressionContext actualSignedExpressionResult = mappingParserGrammar.signedExpression();

    // Assert
    RecognitionException recognitionException = actualSignedExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertNull(actualSignedExpressionResult.getParent());
    Token expectedStart = actualSignedExpressionResult.start;
    Token start = actualSignedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSignedExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(779, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualSignedExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSignedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.SignedExpressionContext actualSignedExpressionResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).signedExpression();

    // Assert
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertEquals(1, actualSignedExpressionResult.children.size());
    assertNull(actualSignedExpressionResult.getParent());
    Token expectedStart = actualSignedExpressionResult.stop;
    Token start = actualSignedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSignedExpressionResult.getStop());
    assertEquals(1, actualSignedExpressionResult.getChildCount());
    MappingParserGrammar.ExpressionContext expressionResult = actualSignedExpressionResult.expression();
    assertEquals(780, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([780] ([396 780] ([635 396 780] ([642 635 396 780] ([1027 642 635 396 780] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(396, ((MappingParserGrammar.AtomicExpressionContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testSignedExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.SignedExpressionContext signedExpressionContext = new MappingParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.SignedExpressionContext signedExpressionContext = new MappingParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);
    signedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testSignedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(72, (new MappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSignedExpressionContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testSignedExpressionContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testSliceExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.SliceExpressionContext actualSliceExpressionResult = mappingParserGrammar.sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSliceExpressionResult.invokingState);
    assertNull(actualSliceExpressionResult.getParent());
    Token expectedStart = actualSliceExpressionResult.start;
    Token start = actualSliceExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSliceExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(759, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSliceExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.SliceExpressionContext actualSliceExpressionResult = mappingParserGrammar.sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualSliceExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualSliceExpressionResult.getParent());
    Token token = actualSliceExpressionResult.stop;
    assertSame(token, actualSliceExpressionResult.getStart());
    Token stop = actualSliceExpressionResult.getStop();
    assertSame(token, stop);
    assertEquals("<missing '['><EOF>", actualSliceExpressionResult.getText());
    assertEquals(2, actualSliceExpressionResult.getChildCount());
    assertTrue(actualSliceExpressionResult.isEmpty());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(772, recognitionException.getOffendingState());
    assertSame(stop, ((NoViableAltException) recognitionException).getStartToken());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals(0, stop.getTokenIndex());
    assertSame(actualSliceExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testSliceExpressionContextAccept() {
    // Arrange
    MappingParserGrammar.SliceExpressionContext sliceExpressionContext = new MappingParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextAccept2() {
    // Arrange
    MappingParserGrammar.SliceExpressionContext sliceExpressionContext = new MappingParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);
    sliceExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testSliceExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testSliceExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON().isEmpty());
    assertNull((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON(1));
  }

  @Test
  public void testSliceExpressionContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testSliceExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(70, (new MappingParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSourceStore() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.start;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceStore2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.stop;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(271, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testSourceStore3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.stop;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(271, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testSourceStore4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.stop;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(271, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testSourceStore5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = mappingParserGrammar.sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.stop;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(271, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testSourceStore6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = mappingParserGrammar.sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.stop;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(271, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testSourceStore7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = mappingParserGrammar.sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.start;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceStore8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.SourceStoreContext actualSourceStoreResult = mappingParserGrammar.sourceStore();

    // Assert
    assertEquals(-1, actualSourceStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualSourceStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSourceStoreResult.getParent());
    Token expectedStart = actualSourceStoreResult.start;
    Token start = actualSourceStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSourceStoreResult.getStop());
    assertEquals(1, actualSourceStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testSourceStoreContextAccept() {
    // Arrange
    MappingParserGrammar.SourceStoreContext sourceStoreContext = new MappingParserGrammar.SourceStoreContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sourceStoreContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceStoreContextAccept2() {
    // Arrange
    MappingParserGrammar.SourceStoreContext sourceStoreContext = new MappingParserGrammar.SourceStoreContext(
        new ParserRuleContext(), 1);
    sourceStoreContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sourceStoreContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSourceStoreContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(7, (new MappingParserGrammar.SourceStoreContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSourceStoreContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SourceStoreContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testStereotypeReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = mappingParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeReferenceResult.getStop());
    assertEquals(1, actualStereotypeReferenceResult.getChildCount());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    assertEquals("([] [510])", actualStereotypeReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(511, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(510, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testStereotypeReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = mappingParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.stop;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypeReferenceResult.getStop());
    assertEquals("null", actualStereotypeReferenceResult.getText());
    assertEquals(1, actualStereotypeReferenceResult.getChildCount());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(511, recognitionException.getOffendingState());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(510, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).stereotypeReference();

    // Assert
    assertEquals(-1, actualStereotypeReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualStereotypeReferenceResult.stop;
    Token stop = actualStereotypeReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '@'><EOF>", actualStereotypeReferenceResult.getText());
    assertEquals(3, actualStereotypeReferenceResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualStereotypeReferenceResult.identifier();
    assertEquals(512, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(510, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReferenceContextAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testStereotypeReferenceContextAccept() {
    // Arrange
    MappingParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new MappingParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextAccept2() {
    // Arrange
    MappingParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new MappingParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);
    stereotypeReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(38, (new MappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotypeReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testStereotypeReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testStoreSubPath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.StoreSubPathContext actualStoreSubPathResult = mappingParserGrammar.storeSubPath();

    // Assert
    RecognitionException recognitionException = actualStoreSubPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStoreSubPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStoreSubPathResult.getParent());
    Token expectedStart = actualStoreSubPathResult.start;
    Token start = actualStoreSubPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStoreSubPathResult.getStop());
    assertEquals("", actualStoreSubPathResult.getText());
    assertEquals(1, actualStoreSubPathResult.getChildCount());
    assertTrue(actualStoreSubPathResult.isEmpty());
    assertEquals("([] ([267] [271 267]))", actualStoreSubPathResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertSame(actualStoreSubPathResult, recognitionException.getCtx());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertEquals(0, inputStream.index());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(267, ((MappingParserGrammar.SourceStoreContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStoreSubPath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.StoreSubPathContext actualStoreSubPathResult = mappingParserGrammar.storeSubPath();

    // Assert
    RecognitionException recognitionException = actualStoreSubPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStoreSubPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStoreSubPathResult.getParent());
    Token expectedStart = actualStoreSubPathResult.stop;
    Token start = actualStoreSubPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStoreSubPathResult.getStop());
    assertEquals("null", actualStoreSubPathResult.getText());
    assertEquals(1, actualStoreSubPathResult.getChildCount());
    assertTrue(actualStoreSubPathResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(268, recognitionException.getOffendingState());
    assertSame(actualStoreSubPathResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(2, inputStream.size());
    assertEquals(267, ((MappingParserGrammar.SourceStoreContext) parseTreeList.get(0)).invokingState);
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testStoreSubPath3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.StoreSubPathContext actualStoreSubPathResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).storeSubPath();

    // Assert
    assertEquals(-1, actualStoreSubPathResult.invokingState);
    List<ParseTree> parseTreeList = actualStoreSubPathResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualStoreSubPathResult.getParent());
    Token expectedStart = actualStoreSubPathResult.start;
    Token start = actualStoreSubPathResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualStoreSubPathResult.stop;
    Token stop = actualStoreSubPathResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '->'><EOF>", actualStoreSubPathResult.getText());
    assertEquals(3, actualStoreSubPathResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(267, ((MappingParserGrammar.SourceStoreContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(stop, ((MappingParserGrammar.TargetStoreContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("[269]", getResult.toString());
    assertEquals(269, ((MappingParserGrammar.TargetStoreContext) getResult).invokingState);
  }

  @Test
  public void testStoreSubPathContextARROW() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StoreSubPathContext(new ParserRuleContext(), 1)).ARROW());
  }

  @Test
  public void testStoreSubPathContextAccept() {
    // Arrange
    MappingParserGrammar.StoreSubPathContext storeSubPathContext = new MappingParserGrammar.StoreSubPathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(storeSubPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStoreSubPathContextAccept2() {
    // Arrange
    MappingParserGrammar.StoreSubPathContext storeSubPathContext = new MappingParserGrammar.StoreSubPathContext(
        new ParserRuleContext(), 1);
    storeSubPathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(storeSubPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStoreSubPathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(6, (new MappingParserGrammar.StoreSubPathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStoreSubPathContextSourceStore() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StoreSubPathContext(new ParserRuleContext(), 1)).sourceStore());
  }

  @Test
  public void testStoreSubPathContextTargetStore() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.StoreSubPathContext(new ParserRuleContext(), 1)).targetStore());
  }

  @Test
  public void testSuperClassMappingId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.start;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([312] [314 312])", getResult.toStringTree());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertTrue(wordResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(314, wordResult.invokingState);
  }

  @Test
  public void testSuperClassMappingId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.stop;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(3, wordResult.depth());
    assertSame(start, wordResult.getStop());
    assertEquals(1, wordResult.getChildCount());
    Interval expectedSourceInterval = actualSuperClassMappingIdResult.getSourceInterval();
    assertSame(expectedSourceInterval, wordResult.getSourceInterval());
  }

  @Test
  public void testSuperClassMappingId3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.stop;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(3, wordResult.depth());
    assertSame(start, wordResult.getStop());
    assertEquals(1, wordResult.getChildCount());
    Interval expectedSourceInterval = actualSuperClassMappingIdResult.getSourceInterval();
    assertSame(expectedSourceInterval, wordResult.getSourceInterval());
  }

  @Test
  public void testSuperClassMappingId4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.stop;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(3, wordResult.depth());
    assertSame(start, wordResult.getStop());
    assertEquals(1, wordResult.getChildCount());
    Interval expectedSourceInterval = actualSuperClassMappingIdResult.getSourceInterval();
    assertSame(expectedSourceInterval, wordResult.getSourceInterval());
  }

  @Test
  public void testSuperClassMappingId5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = mappingParserGrammar
        .superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.stop;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(3, wordResult.depth());
    assertSame(start, wordResult.getStop());
    assertEquals(1, wordResult.getChildCount());
    Interval expectedSourceInterval = actualSuperClassMappingIdResult.getSourceInterval();
    assertSame(expectedSourceInterval, wordResult.getSourceInterval());
  }

  @Test
  public void testSuperClassMappingId6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = mappingParserGrammar
        .superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.stop;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertEquals(314, wordResult.invokingState);
    assertEquals(3, wordResult.depth());
    assertSame(start, wordResult.getStop());
    assertEquals(1, wordResult.getChildCount());
    Interval expectedSourceInterval = actualSuperClassMappingIdResult.getSourceInterval();
    assertSame(expectedSourceInterval, wordResult.getSourceInterval());
  }

  @Test
  public void testSuperClassMappingId7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = mappingParserGrammar
        .superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.start;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([312] [314 312])", getResult.toStringTree());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertTrue(wordResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(314, wordResult.invokingState);
  }

  @Test
  public void testSuperClassMappingId8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.SuperClassMappingIdContext actualSuperClassMappingIdResult = mappingParserGrammar
        .superClassMappingId();

    // Assert
    assertEquals(-1, actualSuperClassMappingIdResult.invokingState);
    List<ParseTree> parseTreeList = actualSuperClassMappingIdResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSuperClassMappingIdResult.getParent());
    Token expectedStart = actualSuperClassMappingIdResult.start;
    Token start = actualSuperClassMappingIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSuperClassMappingIdResult.getStop());
    assertEquals(1, actualSuperClassMappingIdResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.MappingElementIdContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.MappingElementIdContext) getResult).depth());
    assertFalse(((MappingParserGrammar.MappingElementIdContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.MappingElementIdContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.MappingElementIdContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([312] [314 312])", getResult.toStringTree());
    MappingParserGrammar.WordContext wordResult = ((MappingParserGrammar.MappingElementIdContext) getResult).word();
    assertTrue(wordResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(314, wordResult.invokingState);
  }

  @Test
  public void testSuperClassMappingIdContextAccept() {
    // Arrange
    MappingParserGrammar.SuperClassMappingIdContext superClassMappingIdContext = new MappingParserGrammar.SuperClassMappingIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(superClassMappingIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSuperClassMappingIdContextAccept2() {
    // Arrange
    MappingParserGrammar.SuperClassMappingIdContext superClassMappingIdContext = new MappingParserGrammar.SuperClassMappingIdContext(
        new ParserRuleContext(), 1);
    superClassMappingIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(superClassMappingIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSuperClassMappingIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(14, (new MappingParserGrammar.SuperClassMappingIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSuperClassMappingIdContextMappingElementId() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.SuperClassMappingIdContext(new ParserRuleContext(), 1)).mappingElementId());
  }

  @Test
  public void testTagReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TagReferenceContext actualTagReferenceResult = mappingParserGrammar.tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTagReferenceResult.getStop());
    assertEquals(1, actualTagReferenceResult.getChildCount());
    assertTrue(actualTagReferenceResult.isEmpty());
    assertEquals("([] [514])", actualTagReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(515, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(514, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testTagReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TagReferenceContext actualTagReferenceResult = mappingParserGrammar.tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.stop;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTagReferenceResult.getStop());
    assertEquals("null", actualTagReferenceResult.getText());
    assertEquals(1, actualTagReferenceResult.getChildCount());
    assertTrue(actualTagReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(515, recognitionException.getOffendingState());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(514, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.TagReferenceContext actualTagReferenceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).tagReference();

    // Assert
    assertEquals(-1, actualTagReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualTagReferenceResult.stop;
    Token stop = actualTagReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '%'><EOF>", actualTagReferenceResult.getText());
    assertEquals(3, actualTagReferenceResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTagReferenceResult.identifier();
    assertEquals(516, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(514, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReferenceContextAccept() {
    // Arrange
    MappingParserGrammar.TagReferenceContext tagReferenceContext = new MappingParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextAccept2() {
    // Arrange
    MappingParserGrammar.TagReferenceContext tagReferenceContext = new MappingParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);
    tagReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(39, (new MappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTagReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTagReferenceContextPERCENT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).PERCENT());
  }

  @Test
  public void testTagReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTargetStore() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.start;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetStore2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.stop;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(273, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTargetStore3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.stop;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(273, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTargetStore4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.stop;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(273, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTargetStore5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = mappingParserGrammar.targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.stop;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(273, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTargetStore6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = mappingParserGrammar.targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.stop;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(273, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTargetStore7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = mappingParserGrammar.targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.start;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetStore8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.TargetStoreContext actualTargetStoreResult = mappingParserGrammar.targetStore();

    // Assert
    assertEquals(-1, actualTargetStoreResult.invokingState);
    List<ParseTree> parseTreeList = actualTargetStoreResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTargetStoreResult.getParent());
    Token expectedStart = actualTargetStoreResult.start;
    Token start = actualTargetStoreResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTargetStoreResult.getStop());
    assertEquals(1, actualTargetStoreResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTargetStoreContextAccept() {
    // Arrange
    MappingParserGrammar.TargetStoreContext targetStoreContext = new MappingParserGrammar.TargetStoreContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(targetStoreContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTargetStoreContextAccept2() {
    // Arrange
    MappingParserGrammar.TargetStoreContext targetStoreContext = new MappingParserGrammar.TargetStoreContext(
        new ParserRuleContext(), 1);
    targetStoreContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(targetStoreContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTargetStoreContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(8, (new MappingParserGrammar.TargetStoreContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTargetStoreContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TargetStoreContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTest() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestContext actualTestResult = mappingParserGrammar.test();

    // Assert
    RecognitionException recognitionException = actualTestResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTestResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestResult.getParent());
    Token expectedStart = actualTestResult.start;
    Token start = actualTestResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestResult.getStop());
    assertEquals("", actualTestResult.getText());
    assertEquals(1, actualTestResult.getChildCount());
    assertTrue(actualTestResult.isEmpty());
    assertEquals("([] ([330] [360 330]))", actualTestResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(331, recognitionException.getOffendingState());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertSame(actualTestResult, recognitionException.getCtx());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertEquals(0, inputStream.index());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(330, ((MappingParserGrammar.TestNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTest2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestContext actualTestResult = mappingParserGrammar.test();

    // Assert
    RecognitionException recognitionException = actualTestResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTestResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestResult.getParent());
    Token expectedStart = actualTestResult.stop;
    Token start = actualTestResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestResult.getStop());
    assertEquals("null", actualTestResult.getText());
    assertEquals(1, actualTestResult.getChildCount());
    assertTrue(actualTestResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(331, recognitionException.getOffendingState());
    assertSame(actualTestResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(2, inputStream.size());
    assertEquals(330, ((MappingParserGrammar.TestNameContext) parseTreeList.get(0)).invokingState);
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testTest3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestContext actualTestResult = mappingParserGrammar.test();

    // Assert
    RecognitionException recognitionException = actualTestResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTestResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestResult.getParent());
    Token expectedStart = actualTestResult.stop;
    Token start = actualTestResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestResult.getStop());
    assertEquals("null", actualTestResult.getText());
    assertEquals(1, actualTestResult.getChildCount());
    assertTrue(actualTestResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(331, recognitionException.getOffendingState());
    assertSame(actualTestResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(2, inputStream.size());
    assertEquals(330, ((MappingParserGrammar.TestNameContext) parseTreeList.get(0)).invokingState);
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testTestAssert() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestAssertContext actualTestAssertResult = mappingParserGrammar.testAssert();

    // Assert
    RecognitionException recognitionException = actualTestAssertResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestAssertResult.invokingState);
    assertNull(actualTestAssertResult.getParent());
    Token expectedStart = actualTestAssertResult.start;
    Token start = actualTestAssertResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestAssertResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(352, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestAssertResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTestAssert2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestAssertContext actualTestAssertResult = mappingParserGrammar.testAssert();

    // Assert
    RecognitionException recognitionException = actualTestAssertResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestAssertResult.children.size());
    assertNull(actualTestAssertResult.getParent());
    Token expectedStart = actualTestAssertResult.stop;
    Token start = actualTestAssertResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestAssertResult.getStop());
    assertEquals("null", actualTestAssertResult.getText());
    assertEquals(1, actualTestAssertResult.getChildCount());
    assertTrue(actualTestAssertResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(352, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestAssertResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestAssert3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(8));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestAssertContext actualTestAssertResult = mappingParserGrammar.testAssert();

    // Assert
    RecognitionException recognitionException = actualTestAssertResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestAssertResult.children.size());
    assertNull(actualTestAssertResult.getParent());
    Token expectedStart = actualTestAssertResult.stop;
    Token start = actualTestAssertResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestAssertResult.getStop());
    assertEquals("null", actualTestAssertResult.getText());
    assertEquals(1, actualTestAssertResult.getChildCount());
    assertTrue(actualTestAssertResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(353, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTestAssertResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestAssertContextAccept() {
    // Arrange
    MappingParserGrammar.TestAssertContext testAssertContext = new MappingParserGrammar.TestAssertContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testAssertContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestAssertContextAccept2() {
    // Arrange
    MappingParserGrammar.TestAssertContext testAssertContext = new MappingParserGrammar.TestAssertContext(
        new ParserRuleContext(), 1);
    testAssertContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testAssertContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestAssertContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testTestAssertContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testTestAssertContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(20, (new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestAssertContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testTestAssertContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testTestAssertContextTEST_ASSERT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestAssertContext(new ParserRuleContext(), 1)).TEST_ASSERT());
  }

  @Test
  public void testTestContextAccept() {
    // Arrange
    MappingParserGrammar.TestContext testContext = new MappingParserGrammar.TestContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestContextAccept2() {
    // Arrange
    MappingParserGrammar.TestContext testContext = new MappingParserGrammar.TestContext(new ParserRuleContext(), 1);
    testContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(17, (new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testTestContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testTestContextTestAssert() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testAssert().isEmpty());
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testAssert(1));
  }

  @Test
  public void testTestContextTestInputData() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testInputData().isEmpty());
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testInputData(1));
  }

  @Test
  public void testTestContextTestName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testName());
  }

  @Test
  public void testTestContextTestQuery() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testQuery().isEmpty());
    assertNull((new MappingParserGrammar.TestContext(new ParserRuleContext(), 1)).testQuery(1));
  }

  @Test
  public void testTestInput() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputContext actualTestInputResult = mappingParserGrammar.testInput();

    // Assert
    RecognitionException recognitionException = actualTestInputResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestInputResult.invokingState);
    assertNull(actualTestInputResult.getParent());
    Token expectedStart = actualTestInputResult.start;
    Token start = actualTestInputResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(362, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestInputResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTestInputContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputContext testInputContext = new MappingParserGrammar.TestInputContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputContext testInputContext = new MappingParserGrammar.TestInputContext(
        new ParserRuleContext(), 1);
    testInputContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testTestInputContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testTestInputContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTestInputContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(22, (new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputContextTestInputElement() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).testInputElement().isEmpty());
    assertNull((new MappingParserGrammar.TestInputContext(new ParserRuleContext(), 1)).testInputElement(1));
  }

  @Test
  public void testTestInputData() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputDataContext actualTestInputDataResult = mappingParserGrammar.testInputData();

    // Assert
    RecognitionException recognitionException = actualTestInputDataResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestInputDataResult.invokingState);
    assertNull(actualTestInputDataResult.getParent());
    Token expectedStart = actualTestInputDataResult.start;
    Token start = actualTestInputDataResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputDataResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(347, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestInputDataResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTestInputData2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputDataContext actualTestInputDataResult = mappingParserGrammar.testInputData();

    // Assert
    RecognitionException recognitionException = actualTestInputDataResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestInputDataResult.children.size());
    assertNull(actualTestInputDataResult.getParent());
    Token expectedStart = actualTestInputDataResult.stop;
    Token start = actualTestInputDataResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputDataResult.getStop());
    assertEquals("null", actualTestInputDataResult.getText());
    assertEquals(1, actualTestInputDataResult.getChildCount());
    assertTrue(actualTestInputDataResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(347, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestInputDataResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestInputData3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(7));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputDataContext actualTestInputDataResult = mappingParserGrammar.testInputData();

    // Assert
    RecognitionException recognitionException = actualTestInputDataResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestInputDataResult.children.size());
    assertNull(actualTestInputDataResult.getParent());
    Token expectedStart = actualTestInputDataResult.stop;
    Token start = actualTestInputDataResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputDataResult.getStop());
    assertEquals("null", actualTestInputDataResult.getText());
    assertEquals(1, actualTestInputDataResult.getChildCount());
    assertTrue(actualTestInputDataResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(348, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTestInputDataResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestInputDataContent() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputDataContent();

    // Assert
    assertEquals(-1, actualTestInputDataContentResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputDataContentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.start;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputDataContentResult.getStop());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualTestInputDataContentResult, getResult.getParent());
    assertEquals("<missing STRING>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing STRING>',<19>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(19, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing STRING>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testTestInputDataContent2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = mappingParserGrammar
        .testInputDataContent();

    // Assert
    RecognitionException recognitionException = actualTestInputDataContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestInputDataContentResult.children.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.stop;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputDataContentResult.getStop());
    assertEquals("null", actualTestInputDataContentResult.getText());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertTrue(actualTestInputDataContentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(393, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestInputDataContentResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestInputDataContent3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = mappingParserGrammar
        .testInputDataContent();

    // Assert
    RecognitionException recognitionException = actualTestInputDataContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestInputDataContentResult.children.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.stop;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputDataContentResult.getStop());
    assertEquals("Input", actualTestInputDataContentResult.getText());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertTrue(actualTestInputDataContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(393, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualTestInputDataContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testTestInputDataContent4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).testInputDataContent();

    // Assert
    assertEquals(-1, actualTestInputDataContentResult.invokingState);
    assertEquals(1, actualTestInputDataContentResult.children.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.start;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputDataContentResult.getStop());
    assertEquals("<missing STRING>", actualTestInputDataContentResult.getText());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testTestInputDataContent5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = mappingParserGrammar
        .testInputDataContent();

    // Assert
    RecognitionException recognitionException = actualTestInputDataContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestInputDataContentResult.children.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.stop;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputDataContentResult.getStop());
    assertEquals("Input", actualTestInputDataContentResult.getText());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertTrue(actualTestInputDataContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(393, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualTestInputDataContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testTestInputDataContent6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputDataContentContext actualTestInputDataContentResult = mappingParserGrammar
        .testInputDataContent();

    // Assert
    assertEquals(-1, actualTestInputDataContentResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputDataContentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputDataContentResult.getParent());
    Token expectedStart = actualTestInputDataContentResult.start;
    Token start = actualTestInputDataContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputDataContentResult.getStop());
    assertEquals(1, actualTestInputDataContentResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualTestInputDataContentResult, getResult.getParent());
    assertEquals("<missing STRING>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing STRING>',<19>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(19, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing STRING>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testTestInputDataContentContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputDataContentContext testInputDataContentContext = new MappingParserGrammar.TestInputDataContentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputDataContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputDataContentContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputDataContentContext testInputDataContentContext = new MappingParserGrammar.TestInputDataContentContext(
        new ParserRuleContext(), 1);
    testInputDataContentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputDataContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputDataContentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(27, (new MappingParserGrammar.TestInputDataContentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputDataContentContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputDataContentContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testTestInputDataContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputDataContext testInputDataContext = new MappingParserGrammar.TestInputDataContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputDataContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputDataContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputDataContext testInputDataContext = new MappingParserGrammar.TestInputDataContext(
        new ParserRuleContext(), 1);
    testInputDataContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputDataContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputDataContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputDataContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testTestInputDataContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(19, (new MappingParserGrammar.TestInputDataContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputDataContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputDataContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testTestInputDataContextTEST_INPUT_DATA() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputDataContext(new ParserRuleContext(), 1)).TEST_INPUT_DATA());
  }

  @Test
  public void testTestInputDataContextTestInput() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputDataContext(new ParserRuleContext(), 1)).testInput());
  }

  @Test
  public void testTestInputElement() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputElementContext actualTestInputElementResult = mappingParserGrammar.testInputElement();

    // Assert
    RecognitionException recognitionException = actualTestInputElementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestInputElementResult.invokingState);
    assertNull(actualTestInputElementResult.getParent());
    Token expectedStart = actualTestInputElementResult.start;
    Token start = actualTestInputElementResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputElementResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(375, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestInputElementResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTestInputElement2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestInputElementContext actualTestInputElementResult = mappingParserGrammar.testInputElement();

    // Assert
    RecognitionException recognitionException = actualTestInputElementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTestInputElementResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTestInputElementResult.getParent());
    Token expectedStart = actualTestInputElementResult.stop;
    Token start = actualTestInputElementResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputElementResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTestInputElementResult.getText());
    assertEquals(2, actualTestInputElementResult.getChildCount());
    assertTrue(actualTestInputElementResult.isEmpty());
    assertEquals("([] <missing '<'> ([376] ([387 376] <EOF>)))", actualTestInputElementResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(379, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTestInputElementResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(376, ((MappingParserGrammar.TestInputTypeContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTestInputElementContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputElementContext testInputElementContext = new MappingParserGrammar.TestInputElementContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputElementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputElementContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputElementContext testInputElementContext = new MappingParserGrammar.TestInputElementContext(
        new ParserRuleContext(), 1);
    testInputElementContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputElementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputElementContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTestInputElementContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTestInputElementContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(23, (new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputElementContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTestInputElementContextTestInputDataContent() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).testInputDataContent());
  }

  @Test
  public void testTestInputElementContextTestInputFormat() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).testInputFormat());
  }

  @Test
  public void testTestInputElementContextTestInputSrc() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).testInputSrc());
  }

  @Test
  public void testTestInputElementContextTestInputType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputElementContext(new ParserRuleContext(), 1)).testInputType());
  }

  @Test
  public void testTestInputFormat() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TestInputFormatContext actualTestInputFormatResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputFormat();

    // Assert
    assertEquals(-1, actualTestInputFormatResult.invokingState);
    assertEquals(1, actualTestInputFormatResult.children.size());
    assertNull(actualTestInputFormatResult.getParent());
    Token expectedStart = actualTestInputFormatResult.start;
    Token start = actualTestInputFormatResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputFormatResult.getStop());
    assertEquals(1, actualTestInputFormatResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputFormatResult.identifier();
    assertEquals(389, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTestInputFormat2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TestInputFormatContext actualTestInputFormatResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).testInputFormat();

    // Assert
    assertEquals(-1, actualTestInputFormatResult.invokingState);
    assertEquals(1, actualTestInputFormatResult.children.size());
    assertNull(actualTestInputFormatResult.getParent());
    Token token = actualTestInputFormatResult.stop;
    assertSame(token, actualTestInputFormatResult.getStart());
    Token stop = actualTestInputFormatResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTestInputFormatResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputFormatResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTestInputFormat3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestInputFormatContext actualTestInputFormatResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).testInputFormat();

    // Assert
    assertEquals(-1, actualTestInputFormatResult.invokingState);
    assertEquals(1, actualTestInputFormatResult.children.size());
    assertNull(actualTestInputFormatResult.getParent());
    Token expectedStart = actualTestInputFormatResult.stop;
    Token start = actualTestInputFormatResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputFormatResult.getStop());
    assertEquals(1, actualTestInputFormatResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputFormatResult.identifier();
    assertEquals(389, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestInputFormat4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestInputFormatContext actualTestInputFormatResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).testInputFormat();

    // Assert
    assertEquals(-1, actualTestInputFormatResult.invokingState);
    assertEquals(1, actualTestInputFormatResult.children.size());
    assertNull(actualTestInputFormatResult.getParent());
    Token expectedStart = actualTestInputFormatResult.start;
    Token start = actualTestInputFormatResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputFormatResult.getStop());
    assertEquals(1, actualTestInputFormatResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputFormatResult.identifier();
    assertEquals(389, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testTestInputFormat5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputFormatContext actualTestInputFormatResult = mappingParserGrammar.testInputFormat();

    // Assert
    assertEquals(-1, actualTestInputFormatResult.invokingState);
    assertEquals(1, actualTestInputFormatResult.children.size());
    assertNull(actualTestInputFormatResult.getParent());
    Token expectedStart = actualTestInputFormatResult.stop;
    Token start = actualTestInputFormatResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputFormatResult.getStop());
    assertEquals(1, actualTestInputFormatResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputFormatResult.identifier();
    assertEquals(389, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestInputFormatContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputFormatContext testInputFormatContext = new MappingParserGrammar.TestInputFormatContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputFormatContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputFormatContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputFormatContext testInputFormatContext = new MappingParserGrammar.TestInputFormatContext(
        new ParserRuleContext(), 1);
    testInputFormatContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputFormatContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputFormatContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(25, (new MappingParserGrammar.TestInputFormatContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputFormatContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputFormatContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTestInputSrc() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.start;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTestInputSrc2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.stop;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(391, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTestInputSrc3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.stop;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(391, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTestInputSrc4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.stop;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(391, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTestInputSrc5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = mappingParserGrammar.testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.stop;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(391, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTestInputSrc6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = mappingParserGrammar.testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.stop;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(391, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTestInputSrc7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = mappingParserGrammar.testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.start;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTestInputSrc8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.TestInputSrcContext actualTestInputSrcResult = mappingParserGrammar.testInputSrc();

    // Assert
    assertEquals(-1, actualTestInputSrcResult.invokingState);
    List<ParseTree> parseTreeList = actualTestInputSrcResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTestInputSrcResult.getParent());
    Token expectedStart = actualTestInputSrcResult.start;
    Token start = actualTestInputSrcResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputSrcResult.getStop());
    assertEquals(1, actualTestInputSrcResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testTestInputSrcContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputSrcContext testInputSrcContext = new MappingParserGrammar.TestInputSrcContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputSrcContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputSrcContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputSrcContext testInputSrcContext = new MappingParserGrammar.TestInputSrcContext(
        new ParserRuleContext(), 1);
    testInputSrcContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputSrcContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputSrcContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(26, (new MappingParserGrammar.TestInputSrcContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputSrcContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputSrcContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTestInputType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TestInputTypeContext actualTestInputTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testInputType();

    // Assert
    assertEquals(-1, actualTestInputTypeResult.invokingState);
    assertEquals(1, actualTestInputTypeResult.children.size());
    assertNull(actualTestInputTypeResult.getParent());
    Token expectedStart = actualTestInputTypeResult.start;
    Token start = actualTestInputTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputTypeResult.getStop());
    assertEquals(1, actualTestInputTypeResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputTypeResult.identifier();
    assertEquals(387, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTestInputType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TestInputTypeContext actualTestInputTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).testInputType();

    // Assert
    assertEquals(-1, actualTestInputTypeResult.invokingState);
    assertEquals(1, actualTestInputTypeResult.children.size());
    assertNull(actualTestInputTypeResult.getParent());
    Token token = actualTestInputTypeResult.stop;
    assertSame(token, actualTestInputTypeResult.getStart());
    Token stop = actualTestInputTypeResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTestInputTypeResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputTypeResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTestInputType3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestInputTypeContext actualTestInputTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).testInputType();

    // Assert
    assertEquals(-1, actualTestInputTypeResult.invokingState);
    assertEquals(1, actualTestInputTypeResult.children.size());
    assertNull(actualTestInputTypeResult.getParent());
    Token expectedStart = actualTestInputTypeResult.stop;
    Token start = actualTestInputTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputTypeResult.getStop());
    assertEquals(1, actualTestInputTypeResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputTypeResult.identifier();
    assertEquals(387, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestInputType4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestInputTypeContext actualTestInputTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).testInputType();

    // Assert
    assertEquals(-1, actualTestInputTypeResult.invokingState);
    assertEquals(1, actualTestInputTypeResult.children.size());
    assertNull(actualTestInputTypeResult.getParent());
    Token expectedStart = actualTestInputTypeResult.start;
    Token start = actualTestInputTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestInputTypeResult.getStop());
    assertEquals(1, actualTestInputTypeResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputTypeResult.identifier();
    assertEquals(387, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testTestInputType5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestInputTypeContext actualTestInputTypeResult = mappingParserGrammar.testInputType();

    // Assert
    assertEquals(-1, actualTestInputTypeResult.invokingState);
    assertEquals(1, actualTestInputTypeResult.children.size());
    assertNull(actualTestInputTypeResult.getParent());
    Token expectedStart = actualTestInputTypeResult.stop;
    Token start = actualTestInputTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestInputTypeResult.getStop());
    assertEquals(1, actualTestInputTypeResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestInputTypeResult.identifier();
    assertEquals(387, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestInputTypeContextAccept() {
    // Arrange
    MappingParserGrammar.TestInputTypeContext testInputTypeContext = new MappingParserGrammar.TestInputTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testInputTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputTypeContextAccept2() {
    // Arrange
    MappingParserGrammar.TestInputTypeContext testInputTypeContext = new MappingParserGrammar.TestInputTypeContext(
        new ParserRuleContext(), 1);
    testInputTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testInputTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestInputTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(24, (new MappingParserGrammar.TestInputTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestInputTypeContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestInputTypeContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTestName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TestNameContext actualTestNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).testName();

    // Assert
    assertEquals(-1, actualTestNameResult.invokingState);
    assertEquals(1, actualTestNameResult.children.size());
    assertNull(actualTestNameResult.getParent());
    Token expectedStart = actualTestNameResult.start;
    Token start = actualTestNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestNameResult.getStop());
    assertEquals(1, actualTestNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestNameResult.identifier();
    assertEquals(360, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTestName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TestNameContext actualTestNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).testName();

    // Assert
    assertEquals(-1, actualTestNameResult.invokingState);
    assertEquals(1, actualTestNameResult.children.size());
    assertNull(actualTestNameResult.getParent());
    Token token = actualTestNameResult.stop;
    assertSame(token, actualTestNameResult.getStart());
    Token stop = actualTestNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTestNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTestName3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestNameContext actualTestNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).testName();

    // Assert
    assertEquals(-1, actualTestNameResult.invokingState);
    assertEquals(1, actualTestNameResult.children.size());
    assertNull(actualTestNameResult.getParent());
    Token expectedStart = actualTestNameResult.stop;
    Token start = actualTestNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestNameResult.getStop());
    assertEquals(1, actualTestNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestNameResult.identifier();
    assertEquals(360, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestName4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TestNameContext actualTestNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).testName();

    // Assert
    assertEquals(-1, actualTestNameResult.invokingState);
    assertEquals(1, actualTestNameResult.children.size());
    assertNull(actualTestNameResult.getParent());
    Token expectedStart = actualTestNameResult.start;
    Token start = actualTestNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestNameResult.getStop());
    assertEquals(1, actualTestNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestNameResult.identifier();
    assertEquals(360, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testTestName5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TestNameContext actualTestNameResult = mappingParserGrammar.testName();

    // Assert
    assertEquals(-1, actualTestNameResult.invokingState);
    assertEquals(1, actualTestNameResult.children.size());
    assertNull(actualTestNameResult.getParent());
    Token expectedStart = actualTestNameResult.stop;
    Token start = actualTestNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestNameResult.getStop());
    assertEquals(1, actualTestNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTestNameResult.identifier();
    assertEquals(360, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTestNameContextAccept() {
    // Arrange
    MappingParserGrammar.TestNameContext testNameContext = new MappingParserGrammar.TestNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestNameContextAccept2() {
    // Arrange
    MappingParserGrammar.TestNameContext testNameContext = new MappingParserGrammar.TestNameContext(
        new ParserRuleContext(), 1);
    testNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(21, (new MappingParserGrammar.TestNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTestQuery() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestQueryContext actualTestQueryResult = mappingParserGrammar.testQuery();

    // Assert
    RecognitionException recognitionException = actualTestQueryResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestQueryResult.invokingState);
    assertNull(actualTestQueryResult.getParent());
    Token expectedStart = actualTestQueryResult.start;
    Token start = actualTestQueryResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestQueryResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(342, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestQueryResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTestQuery2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestQueryContext actualTestQueryResult = mappingParserGrammar.testQuery();

    // Assert
    RecognitionException recognitionException = actualTestQueryResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestQueryResult.children.size());
    assertNull(actualTestQueryResult.getParent());
    Token expectedStart = actualTestQueryResult.stop;
    Token start = actualTestQueryResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestQueryResult.getStop());
    assertEquals("null", actualTestQueryResult.getText());
    assertEquals(1, actualTestQueryResult.getChildCount());
    assertTrue(actualTestQueryResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(342, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestQueryResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestQuery3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(6));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestQueryContext actualTestQueryResult = mappingParserGrammar.testQuery();

    // Assert
    RecognitionException recognitionException = actualTestQueryResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestQueryResult.children.size());
    assertNull(actualTestQueryResult.getParent());
    Token expectedStart = actualTestQueryResult.stop;
    Token start = actualTestQueryResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestQueryResult.getStop());
    assertEquals("null", actualTestQueryResult.getText());
    assertEquals(1, actualTestQueryResult.getChildCount());
    assertTrue(actualTestQueryResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(343, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTestQueryResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestQueryContextAccept() {
    // Arrange
    MappingParserGrammar.TestQueryContext testQueryContext = new MappingParserGrammar.TestQueryContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testQueryContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestQueryContextAccept2() {
    // Arrange
    MappingParserGrammar.TestQueryContext testQueryContext = new MappingParserGrammar.TestQueryContext(
        new ParserRuleContext(), 1);
    testQueryContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testQueryContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestQueryContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestQueryContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testTestQueryContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestQueryContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testTestQueryContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(18, (new MappingParserGrammar.TestQueryContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestQueryContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestQueryContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testTestQueryContextTEST_QUERY() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestQueryContext(new ParserRuleContext(), 1)).TEST_QUERY());
  }

  @Test
  public void testTests() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestsContext actualTestsResult = mappingParserGrammar.tests();

    // Assert
    RecognitionException recognitionException = actualTestsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTestsResult.invokingState);
    assertNull(actualTestsResult.getParent());
    Token expectedStart = actualTestsResult.start;
    Token start = actualTestsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTestsResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(316, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestsResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTests2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestsContext actualTestsResult = mappingParserGrammar.tests();

    // Assert
    RecognitionException recognitionException = actualTestsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestsResult.children.size());
    assertNull(actualTestsResult.getParent());
    Token expectedStart = actualTestsResult.stop;
    Token start = actualTestsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestsResult.getStop());
    assertEquals("null", actualTestsResult.getText());
    assertEquals(1, actualTestsResult.getChildCount());
    assertTrue(actualTestsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(316, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTestsResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTests3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(4));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TestsContext actualTestsResult = mappingParserGrammar.tests();

    // Assert
    RecognitionException recognitionException = actualTestsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTestsResult.children.size());
    assertNull(actualTestsResult.getParent());
    Token expectedStart = actualTestsResult.stop;
    Token start = actualTestsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTestsResult.getStop());
    assertEquals("null", actualTestsResult.getText());
    assertEquals(1, actualTestsResult.getChildCount());
    assertTrue(actualTestsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(317, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTestsResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testTestsContextAccept() {
    // Arrange
    MappingParserGrammar.TestsContext testsContext = new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(testsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestsContextAccept2() {
    // Arrange
    MappingParserGrammar.TestsContext testsContext = new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1);
    testsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(testsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTestsContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testTestsContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testTestsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTestsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(16, (new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTestsContextTESTS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).TESTS());
  }

  @Test
  public void testTestsContextTest() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).test().isEmpty());
    assertNull((new MappingParserGrammar.TestsContext(new ParserRuleContext(), 1)).test(1));
  }

  @Test
  public void testToMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = mappingParserGrammar.toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testToMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = mappingParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("null", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(940, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testToMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = mappingParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(940, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testToMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = mappingParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(940, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.ToMultiplicityContext actualToMultiplicityResult = mappingParserGrammar.toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(mappingParserGrammar.getRuleContext());
    assertEquals(-1, mappingParserGrammar.getState());
  }

  @Test
  public void testToMultiplicityContextAccept() {
    // Arrange
    MappingParserGrammar.ToMultiplicityContext toMultiplicityContext = new MappingParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextAccept2() {
    // Arrange
    MappingParserGrammar.ToMultiplicityContext toMultiplicityContext = new MappingParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);
    toMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(89, (new MappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testToMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testToMultiplicityContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(932, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.getParent());
    assertNull(actualTypeResult.type());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.QualifiedNameContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.QualifiedNameContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1027 903]", identifierResult.toString());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testType8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(932, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testType9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeContext actualTypeResult = mappingParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(932, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = mappingParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.start;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(945, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = mappingParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.stop;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([946] ([965 946] ([973 965 946] <EOF>))))",
        actualTypeAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(948, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(946, ((MappingParserGrammar.TypeParametersContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept() {
    // Arrange
    MappingParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new MappingParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new MappingParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeAndMultiplicityParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(91,
        (new MappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
        .multiplictyParameters());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextTypeParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new MappingParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).typeParameters());
  }

  @Test
  public void testTypeArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((MappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = mappingParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = mappingParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = mappingParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStart());
    assertNull(((MappingParserGrammar.TypeContext) getResult).type());
    assertEquals(2, ((MappingParserGrammar.TypeContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((MappingParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 1005]", getResult1.toString());
    assertEquals(903, ((MappingParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new CommonTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = mappingParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((MappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    mappingParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    MappingParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = mappingParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((MappingParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((MappingParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArgumentsContextAccept() {
    // Arrange
    MappingParserGrammar.TypeArgumentsContext typeArgumentsContext = new MappingParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeArgumentsContext typeArgumentsContext = new MappingParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);
    typeArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(99, (new MappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeArgumentsContextType() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type().isEmpty());
    assertNull((new MappingParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type(1));
  }

  @Test
  public void testTypeContextARROW() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).ARROW());
  }

  @Test
  public void testTypeContextAccept() {
    // Arrange
    MappingParserGrammar.TypeContext typeContext = new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeContext typeContext = new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1);
    typeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testTypeContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testTypeContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeContextFunctionTypePureType() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType().isEmpty());
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType(1));
  }

  @Test
  public void testTypeContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(86, (new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testTypeContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testTypeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testTypeContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testTypeContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testTypeContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(973, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token token = actualTypeParameterResult.stop;
    assertSame(token, actualTypeParameterResult.getStart());
    Token stop = actualTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTypeParameter3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.stop;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(973, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameter4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TypeParameterContext actualTypeParameterResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(973, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testTypeParameter5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeParameterContext actualTypeParameterResult = mappingParserGrammar.typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.stop;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(973, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(start.getInputStream());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameterContextAccept() {
    // Arrange
    MappingParserGrammar.TypeParameterContext typeParameterContext = new MappingParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeParameterContext typeParameterContext = new MappingParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);
    typeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(94, (new MappingParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((MappingParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertNull(((MappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((MappingParserGrammar.TypeParameterContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([965] [973 965])", getResult.toStringTree());
    assertEquals(973, ((MappingParserGrammar.TypeParameterContext) getResult).identifier().invokingState);
  }

  @Test
  public void testTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertEquals(965, ((MappingParserGrammar.TypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.TypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTypeParameters3() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertEquals(965, ((MappingParserGrammar.TypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.TypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTypeParameters4() throws RecognitionException {
    // Arrange and Act
    MappingParserGrammar.TypeParametersContext actualTypeParametersResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] ([965] [973 965]))", actualTypeParametersResult.toStringTree());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals("", actualTypeParametersResult.getText());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(965, ((MappingParserGrammar.TypeParameterContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testTypeParameters5() throws RecognitionException {
    // Arrange
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.TypeParametersContext actualTypeParametersResult = mappingParserGrammar.typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertEquals(965, ((MappingParserGrammar.TypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(2, ((MappingParserGrammar.TypeParameterContext) getResult).depth());
    assertSame(start, ((MappingParserGrammar.TypeParameterContext) getResult).getStart());
    MappingParserGrammar.IdentifierContext identifierResult = ((MappingParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(start, identifierResult.getStop());
  }

  @Test
  public void testTypeParametersContextAccept() {
    // Arrange
    MappingParserGrammar.TypeParametersContext typeParametersContext = new MappingParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeParametersContext typeParametersContext = new MappingParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);
    typeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new MappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(93, (new MappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersContextTypeParameter() {
    // Arrange, Act and Assert
    assertTrue((new MappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter().isEmpty());
    assertNull((new MappingParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter(1));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = mappingParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.start;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(955, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = mappingParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.stop;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([956] ([975 956] ([986 975 956] <EOF>))))",
        actualTypeParametersWithContravarianceAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(958, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(956, ((MappingParserGrammar.ContravarianceTypeParametersContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept() {
    // Arrange
    MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept2() {
    // Arrange
    MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeParametersWithContravarianceAndMultiplicityParametersContext
        .<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextContravarianceTypeParameters() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).contravarianceTypeParameters());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(92, (new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).multiplictyParameters());
  }

  @Test
  public void testUnitInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    MappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceResult.getStop());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(467, ((MappingParserGrammar.UnitNameContext) getResult).invokingState);
    assertEquals("([467] [469 467])", getResult.toStringTree());
    assertNull(((MappingParserGrammar.UnitNameContext) getResult).identifier());
    assertSame(start, ((MappingParserGrammar.UnitNameContext) getResult).getStart());
    assertEquals(2, ((MappingParserGrammar.UnitNameContext) getResult).depth());
    assertNull(((MappingParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(1, tokenSource.getLine());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals(466, ((MappingParserGrammar.UnitInstanceLiteralContext) getResult1).invokingState);
    assertTrue(
        ((MappingParserGrammar.UnitNameContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[466]", getResult1.toString());
    assertTrue(
        ((MappingParserGrammar.UnitInstanceLiteralContext) getResult1).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testUnitInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.stop;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceResult.getStop());
    assertEquals("null", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(2, ((MappingParserGrammar.UnitNameContext) getResult).depth());
    assertFalse(((MappingParserGrammar.UnitNameContext) getResult).isEmpty());
    assertSame(start, ((MappingParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(466, ((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    assertSame(start, ((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).depth());
    assertNull(((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStop());
    assertTrue(((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(
        ((MappingParserGrammar.UnitNameContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, ((MappingParserGrammar.UnitNameContext) getResult).getStart());
  }

  @Test
  public void testUnitInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitInstanceResult.stop;
    Token stop = actualUnitInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(466, ((MappingParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(1);
    assertSame(stop, ((MappingParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(3, getResult.getChildCount());
    assertEquals(467, ((MappingParserGrammar.UnitNameContext) getResult).invokingState);
    assertEquals(2, ((MappingParserGrammar.UnitNameContext) getResult).depth());
  }

  @Test
  public void testUnitInstanceContextAccept() {
    // Arrange
    MappingParserGrammar.UnitInstanceContext unitInstanceContext = new MappingParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextAccept2() {
    // Arrange
    MappingParserGrammar.UnitInstanceContext unitInstanceContext = new MappingParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);
    unitInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(30, (new MappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitInstanceContextUnitInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).unitInstanceLiteral());
  }

  @Test
  public void testUnitInstanceContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testUnitInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = mappingParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualUnitInstanceLiteralResult.invokingState);
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.start;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(828, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testUnitInstanceLiteral2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = mappingParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualUnitInstanceLiteralResult.children.size());
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.stop;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceLiteralResult.getStop());
    assertEquals("null", actualUnitInstanceLiteralResult.getText());
    assertEquals(1, actualUnitInstanceLiteralResult.getChildCount());
    assertTrue(actualUnitInstanceLiteralResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(828, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testUnitInstanceLiteralContextAccept() {
    // Arrange
    MappingParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new MappingParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextAccept2() {
    // Arrange
    MappingParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new MappingParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);
    unitInstanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testUnitInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testUnitInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(78, (new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testUnitInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testUnitInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testUnitName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.UnitNameContext actualUnitNameResult = mappingParserGrammar.unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitNameResult.getStop());
    assertEquals(1, actualUnitNameResult.getChildCount());
    assertTrue(actualUnitNameResult.isEmpty());
    assertEquals("([] [469])", actualUnitNameResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(470, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(469, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((MappingParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testUnitName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.UnitNameContext actualUnitNameResult = mappingParserGrammar.unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.stop;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitNameResult.getStop());
    assertEquals("null", actualUnitNameResult.getText());
    assertEquals(1, actualUnitNameResult.getChildCount());
    assertTrue(actualUnitNameResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(470, recognitionException.getOffendingState());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(469, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.UnitNameContext actualUnitNameResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitName();

    // Assert
    assertEquals(-1, actualUnitNameResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitNameResult.stop;
    Token stop = actualUnitNameResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitNameResult.getText());
    assertEquals(3, actualUnitNameResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualUnitNameResult.identifier();
    assertEquals(471, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(469, ((MappingParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitNameContextAccept() {
    // Arrange
    MappingParserGrammar.UnitNameContext unitNameContext = new MappingParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextAccept2() {
    // Arrange
    MappingParserGrammar.UnitNameContext unitNameContext = new MappingParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);
    unitNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(31, (new MappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testUnitNameContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testUnitNameContextTILDE() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).TILDE());
  }

  @Test
  public void testVariable() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.VariableContext actualVariableResult = mappingParserGrammar.variable();

    // Assert
    RecognitionException recognitionException = actualVariableResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualVariableResult.invokingState);
    assertNull(actualVariableResult.getParent());
    Token expectedStart = actualVariableResult.start;
    Token start = actualVariableResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualVariableResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(663, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualVariableResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testVariable2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    MappingParserGrammar.VariableContext actualVariableResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).variable();

    // Assert
    assertEquals(-1, actualVariableResult.invokingState);
    List<ParseTree> parseTreeList = actualVariableResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualVariableResult.getParent());
    Token token = actualVariableResult.stop;
    Token start = actualVariableResult.getStart();
    assertSame(token, start);
    assertSame(token, actualVariableResult.getStop());
    assertEquals("<missing '$'><EOF>", actualVariableResult.getText());
    assertEquals(2, actualVariableResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualVariableResult.identifier();
    assertEquals(664, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualVariableResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testVariableContextAccept() {
    // Arrange
    MappingParserGrammar.VariableContext variableContext = new MappingParserGrammar.VariableContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextAccept2() {
    // Arrange
    MappingParserGrammar.VariableContext variableContext = new MappingParserGrammar.VariableContext(
        new ParserRuleContext(), 1);
    variableContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextDOLLAR() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).DOLLAR());
  }

  @Test
  public void testVariableContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(59, (new MappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testVariableContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.VariableContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testWord() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1040, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    MappingParserGrammar.WordContext actualWordResult = (new MappingParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new CodeLexerGrammar(new ANTLRInputStream()));
    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(bufferedTokenStream);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1040, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getStartIndex());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((CodeLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((CodeLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((CodeLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((CodeLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((CodeLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testWord4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.WordContext actualWordResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    MappingParserGrammar.WordContext actualWordResult = (new MappingParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setBuildParseTree(true);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    MappingParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(commonTokenStream);
    mappingParserGrammar.setTrace(true);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1040, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    MappingParserGrammar mappingParserGrammar = new MappingParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    mappingParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    MappingParserGrammar.WordContext actualWordResult = mappingParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1040, recognitionException.getOffendingState());
    assertSame(mappingParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWordContextAccept() {
    // Arrange
    MappingParserGrammar.WordContext wordContext = new MappingParserGrammar.WordContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextAccept2() {
    // Arrange
    MappingParserGrammar.WordContext wordContext = new MappingParserGrammar.WordContext(new ParserRuleContext(), 1);
    wordContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.WordContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testWordContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(103, (new MappingParserGrammar.WordContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testWordContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.WordContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testWordContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new MappingParserGrammar.WordContext(new ParserRuleContext(), 1)).identifier());
  }
}

