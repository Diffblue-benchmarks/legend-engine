package org.finos.legend.engine.language.pure.grammar.from.antlr4.domain;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;
import java.util.ArrayList;
import java.util.List;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.BailErrorStrategy;
import org.antlr.v4.runtime.BufferedTokenStream;
import org.antlr.v4.runtime.CharStream;
import org.antlr.v4.runtime.CommonToken;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.IntStream;
import org.antlr.v4.runtime.InterpreterRuleContext;
import org.antlr.v4.runtime.ListTokenSource;
import org.antlr.v4.runtime.NoViableAltException;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.RecognitionException;
import org.antlr.v4.runtime.Recognizer;
import org.antlr.v4.runtime.RuleContext;
import org.antlr.v4.runtime.Token;
import org.antlr.v4.runtime.TokenSource;
import org.antlr.v4.runtime.atn.ParserATNSimulator;
import org.antlr.v4.runtime.atn.PredictionContextCache;
import org.antlr.v4.runtime.atn.PredictionMode;
import org.antlr.v4.runtime.misc.Interval;
import org.antlr.v4.runtime.misc.Pair;
import org.antlr.v4.runtime.tree.ParseTree;
import org.antlr.v4.runtime.tree.xpath.XPathLexer;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.CodeParserGrammarBaseVisitor;
import org.finos.legend.engine.language.pure.grammar.from.antlr4.connection.ConnectionLexerGrammar;
import org.junit.Test;

public class DomainParserGrammarDiffblueTest {
  @Test
  public void testAggregation() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AggregationContext actualAggregationResult = domainParserGrammar.aggregation();

    // Assert
    RecognitionException recognitionException = actualAggregationResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAggregationResult.invokingState);
    assertNull(actualAggregationResult.getParent());
    Token expectedStart = actualAggregationResult.start;
    Token start = actualAggregationResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAggregationResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(387, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAggregationResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAggregationContextAccept() {
    // Arrange
    DomainParserGrammar.AggregationContext aggregationContext = new DomainParserGrammar.AggregationContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(aggregationContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAggregationContextAccept2() {
    // Arrange
    DomainParserGrammar.AggregationContext aggregationContext = new DomainParserGrammar.AggregationContext(
        new ParserRuleContext(), 1);
    aggregationContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(aggregationContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAggregationContextAggregationType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AggregationContext(new ParserRuleContext(), 1)).aggregationType());
  }

  @Test
  public void testAggregationContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(11, (new DomainParserGrammar.AggregationContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAggregationContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AggregationContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAggregationContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AggregationContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAggregationType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = domainParserGrammar.aggregationType();

    // Assert
    assertEquals(-1, actualAggregationTypeResult.invokingState);
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.start;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAggregationTypeResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testAggregationType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = domainParserGrammar.aggregationType();

    // Assert
    RecognitionException recognitionException = actualAggregationTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAggregationTypeResult.children.size());
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.stop;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAggregationTypeResult.getStop());
    assertEquals("null", actualAggregationTypeResult.getText());
    assertEquals(1, actualAggregationTypeResult.getChildCount());
    assertTrue(actualAggregationTypeResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(391, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAggregationTypeResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAggregationType3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = domainParserGrammar.aggregationType();

    // Assert
    RecognitionException recognitionException = actualAggregationTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAggregationTypeResult.children.size());
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.stop;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAggregationTypeResult.getStop());
    assertEquals("Input", actualAggregationTypeResult.getText());
    assertEquals(1, actualAggregationTypeResult.getChildCount());
    assertTrue(actualAggregationTypeResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(391, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualAggregationTypeResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testAggregationType4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).aggregationType();

    // Assert
    assertEquals(-1, actualAggregationTypeResult.invokingState);
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.start;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAggregationTypeResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testAggregationType5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = domainParserGrammar.aggregationType();

    // Assert
    RecognitionException recognitionException = actualAggregationTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAggregationTypeResult.children.size());
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.stop;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAggregationTypeResult.getStop());
    assertEquals("Input", actualAggregationTypeResult.getText());
    assertEquals(1, actualAggregationTypeResult.getChildCount());
    assertTrue(actualAggregationTypeResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(391, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualAggregationTypeResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testAggregationType6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.AggregationTypeContext actualAggregationTypeResult = domainParserGrammar.aggregationType();

    // Assert
    assertEquals(-1, actualAggregationTypeResult.invokingState);
    assertNull(actualAggregationTypeResult.getParent());
    Token expectedStart = actualAggregationTypeResult.start;
    Token start = actualAggregationTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAggregationTypeResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testAggregationTypeContextAGGREGATION_TYPE_COMPOSITE() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.AggregationTypeContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_COMPOSITE());
  }

  @Test
  public void testAggregationTypeContextAGGREGATION_TYPE_NONE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AggregationTypeContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_NONE());
  }

  @Test
  public void testAggregationTypeContextAGGREGATION_TYPE_SHARED() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AggregationTypeContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_SHARED());
  }

  @Test
  public void testAggregationTypeContextAccept() {
    // Arrange
    DomainParserGrammar.AggregationTypeContext aggregationTypeContext = new DomainParserGrammar.AggregationTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(aggregationTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAggregationTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.AggregationTypeContext aggregationTypeContext = new DomainParserGrammar.AggregationTypeContext(
        new ParserRuleContext(), 1);
    aggregationTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(aggregationTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAggregationTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(12, (new DomainParserGrammar.AggregationTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAlias() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AliasContext actualAliasResult = domainParserGrammar.alias();

    // Assert
    RecognitionException recognitionException = actualAliasResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAliasResult.invokingState);
    assertNull(actualAliasResult.getParent());
    Token expectedStart = actualAliasResult.start;
    Token start = actualAliasResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAliasResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(723, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualAliasResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testAlias2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.AliasContext actualAliasResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).alias();

    // Assert
    assertEquals(-1, actualAliasResult.invokingState);
    List<ParseTree> parseTreeList = actualAliasResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualAliasResult.getParent());
    Token token = actualAliasResult.stop;
    Token start = actualAliasResult.getStart();
    assertSame(token, start);
    assertSame(token, actualAliasResult.getStop());
    assertEquals("<missing 'as'><EOF>", actualAliasResult.getText());
    assertEquals(2, actualAliasResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualAliasResult.identifier();
    assertEquals(724, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualAliasResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testAliasContextAS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AliasContext(new ParserRuleContext(), 1)).AS());
  }

  @Test
  public void testAliasContextAccept() {
    // Arrange
    DomainParserGrammar.AliasContext aliasContext = new DomainParserGrammar.AliasContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(aliasContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAliasContextAccept2() {
    // Arrange
    DomainParserGrammar.AliasContext aliasContext = new DomainParserGrammar.AliasContext(new ParserRuleContext(), 1);
    aliasContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(aliasContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAliasContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(51, (new DomainParserGrammar.AliasContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAliasContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AliasContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testAllFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionContext actualAllFunctionResult = domainParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionResult.invokingState);
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.start;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1077, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionContext actualAllFunctionResult = domainParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1077, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(62));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionContext actualAllFunctionResult = domainParserGrammar.allFunction();

    // Assert
    RecognitionException recognitionException = actualAllFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionResult.children.size());
    assertNull(actualAllFunctionResult.getParent());
    Token expectedStart = actualAllFunctionResult.stop;
    Token start = actualAllFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionResult.getStop());
    assertEquals("null", actualAllFunctionResult.getText());
    assertEquals(1, actualAllFunctionResult.getChildCount());
    assertTrue(actualAllFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1078, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionContextALL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testAllFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.AllFunctionContext allFunctionContext = new DomainParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.AllFunctionContext allFunctionContext = new DomainParserGrammar.AllFunctionContext(
        new ParserRuleContext(), 1);
    allFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(91, (new DomainParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllFunctionWithMilestoning() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = domainParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllFunctionWithMilestoningResult.invokingState);
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.start;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllFunctionWithMilestoningResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1095, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllFunctionWithMilestoning2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = domainParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1095, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoning3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(62));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllFunctionWithMilestoningContext actualAllFunctionWithMilestoningResult = domainParserGrammar
        .allFunctionWithMilestoning();

    // Assert
    RecognitionException recognitionException = actualAllFunctionWithMilestoningResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllFunctionWithMilestoningResult.children.size());
    assertNull(actualAllFunctionWithMilestoningResult.getParent());
    Token expectedStart = actualAllFunctionWithMilestoningResult.stop;
    Token start = actualAllFunctionWithMilestoningResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllFunctionWithMilestoningResult.getStop());
    assertEquals("null", actualAllFunctionWithMilestoningResult.getText());
    assertEquals(1, actualAllFunctionWithMilestoningResult.getChildCount());
    assertTrue(actualAllFunctionWithMilestoningResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1096, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllFunctionWithMilestoningResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllFunctionWithMilestoningContextALL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept() {
    // Arrange
    DomainParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new DomainParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextAccept2() {
    // Arrange
    DomainParserGrammar.AllFunctionWithMilestoningContext allFunctionWithMilestoningContext = new DomainParserGrammar.AllFunctionWithMilestoningContext(
        new ParserRuleContext(), 1);
    allFunctionWithMilestoningContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allFunctionWithMilestoningContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllFunctionWithMilestoningContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllFunctionWithMilestoningContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testAllFunctionWithMilestoningContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllFunctionWithMilestoningContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(94,
        (new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllFunctionWithMilestoningContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllFunctionWithMilestoningContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllOrFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllOrFunctionContext actualAllOrFunctionResult = domainParserGrammar.allOrFunction();

    // Assert
    RecognitionException recognitionException = actualAllOrFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllOrFunctionResult.invokingState);
    assertNull(actualAllOrFunctionResult.getParent());
    Token expectedStart = actualAllOrFunctionResult.start;
    Token start = actualAllOrFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllOrFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1075, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllOrFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllOrFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.AllOrFunctionContext allOrFunctionContext = new DomainParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.AllOrFunctionContext allOrFunctionContext = new DomainParserGrammar.AllOrFunctionContext(
        new ParserRuleContext(), 1);
    allOrFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allOrFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllOrFunctionContextAllFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allFunction());
  }

  @Test
  public void testAllOrFunctionContextAllFunctionWithMilestoning() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allFunctionWithMilestoning());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allVersionsFunction());
  }

  @Test
  public void testAllOrFunctionContextAllVersionsInRangeFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).allVersionsInRangeFunction());
  }

  @Test
  public void testAllOrFunctionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).functionExpressionParameters());
  }

  @Test
  public void testAllOrFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(90, (new DomainParserGrammar.AllOrFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = domainParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsFunctionResult.invokingState);
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.start;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1082, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = domainParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1082, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(62));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsFunctionContext actualAllVersionsFunctionResult = domainParserGrammar
        .allVersionsFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsFunctionResult.children.size());
    assertNull(actualAllVersionsFunctionResult.getParent());
    Token expectedStart = actualAllVersionsFunctionResult.stop;
    Token start = actualAllVersionsFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsFunctionResult.getStop());
    assertEquals("null", actualAllVersionsFunctionResult.getText());
    assertEquals(1, actualAllVersionsFunctionResult.getChildCount());
    assertTrue(actualAllVersionsFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1083, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsFunctionContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).ALL_VERSIONS());
  }

  @Test
  public void testAllVersionsFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new DomainParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.AllVersionsFunctionContext allVersionsFunctionContext = new DomainParserGrammar.AllVersionsFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllVersionsFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(92, (new DomainParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testAllVersionsInRangeFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = domainParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAllVersionsInRangeFunctionResult.invokingState);
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.start;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1087, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAllVersionsInRangeFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = domainParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1087, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(62));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AllVersionsInRangeFunctionContext actualAllVersionsInRangeFunctionResult = domainParserGrammar
        .allVersionsInRangeFunction();

    // Assert
    RecognitionException recognitionException = actualAllVersionsInRangeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualAllVersionsInRangeFunctionResult.children.size());
    assertNull(actualAllVersionsInRangeFunctionResult.getParent());
    Token expectedStart = actualAllVersionsInRangeFunctionResult.stop;
    Token start = actualAllVersionsInRangeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAllVersionsInRangeFunctionResult.getStop());
    assertEquals("null", actualAllVersionsInRangeFunctionResult.getText());
    assertEquals(1, actualAllVersionsInRangeFunctionResult.getChildCount());
    assertTrue(actualAllVersionsInRangeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1088, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualAllVersionsInRangeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new DomainParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.AllVersionsInRangeFunctionContext allVersionsInRangeFunctionContext = new DomainParserGrammar.AllVersionsInRangeFunctionContext(
        new ParserRuleContext(), 1);
    allVersionsInRangeFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(allVersionsInRangeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextBuildMilestoningVariableExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression()
        .isEmpty());
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1))
        .buildMilestoningVariableExpression(1));
  }

  @Test
  public void testAllVersionsInRangeFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(93,
        (new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testAllVersionsInRangeFunctionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AllVersionsInRangeFunctionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testArithmeticPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ArithmeticPartContext actualArithmeticPartResult = domainParserGrammar.arithmeticPart();

    // Assert
    RecognitionException recognitionException = actualArithmeticPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualArithmeticPartResult.invokingState);
    assertNull(actualArithmeticPartResult.getParent());
    Token expectedStart = actualArithmeticPartResult.start;
    Token start = actualArithmeticPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualArithmeticPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1278, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualArithmeticPartResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testArithmeticPartContextAccept() {
    // Arrange
    DomainParserGrammar.ArithmeticPartContext arithmeticPartContext = new DomainParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextAccept2() {
    // Arrange
    DomainParserGrammar.ArithmeticPartContext arithmeticPartContext = new DomainParserGrammar.ArithmeticPartContext(
        new ParserRuleContext(), 1);
    arithmeticPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(arithmeticPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testArithmeticPartContextDIVIDE() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE().isEmpty());
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).DIVIDE(1));
  }

  @Test
  public void testArithmeticPartContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testArithmeticPartContextGREATER_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).GREATER_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testArithmeticPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(109, (new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testArithmeticPartContextLESS_OR_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_OR_EQUAL());
  }

  @Test
  public void testArithmeticPartContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testArithmeticPartContextMINUS() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS().isEmpty());
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).MINUS(1));
  }

  @Test
  public void testArithmeticPartContextPLUS() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS().isEmpty());
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).PLUS(1));
  }

  @Test
  public void testArithmeticPartContextSTAR() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR().isEmpty());
    assertNull((new DomainParserGrammar.ArithmeticPartContext(new ParserRuleContext(), 1)).STAR(1));
  }

  @Test
  public void testAssociation() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AssociationContext actualAssociationResult = domainParserGrammar.association();

    // Assert
    RecognitionException recognitionException = actualAssociationResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAssociationResult.invokingState);
    assertEquals(1, actualAssociationResult.depth());
    Token expectedStart = actualAssociationResult.start;
    Token start = actualAssociationResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAssociationResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(417, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAssociationResult, recognitionException.getCtx());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testAssociation2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AssociationContext actualAssociationResult = domainParserGrammar.association();

    // Assert
    assertNull(actualAssociationResult.stereotypes());
    RecognitionException recognitionException = actualAssociationResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualAssociationResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualAssociationResult.depth());
    Token expectedStart = actualAssociationResult.stop;
    Token start = actualAssociationResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAssociationResult.getStop());
    assertEquals("<missing 'Association'><EOF>", actualAssociationResult.getText());
    assertTrue(actualAssociationResult.isEmpty());
    assertEquals("([] <missing 'Association'> ([424] ([1431 424] <EOF>)))", actualAssociationResult.toStringTree());
    assertSame(actualAssociationResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(427, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(424, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("<missing 'Association'>", getResult.toString());
    assertSame(actualAssociationResult, getResult.getParent());
  }

  @Test
  public void testAssociationBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AssociationBodyContext actualAssociationBodyResult = domainParserGrammar.associationBody();

    // Assert
    RecognitionException recognitionException = actualAssociationBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAssociationBodyResult.invokingState);
    assertNull(actualAssociationBodyResult.getParent());
    Token expectedStart = actualAssociationBodyResult.start;
    Token start = actualAssociationBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAssociationBodyResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(429, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualAssociationBodyResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testAssociationBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    // Act
    DomainParserGrammar.AssociationBodyContext actualAssociationBodyResult = (new DomainParserGrammar(
        bufferedTokenStream)).associationBody();

    // Assert
    assertEquals(-1, actualAssociationBodyResult.invokingState);
    assertEquals(3, actualAssociationBodyResult.children.size());
    assertNull(actualAssociationBodyResult.getParent());
    Token token = actualAssociationBodyResult.stop;
    Token start = actualAssociationBodyResult.getStart();
    assertSame(token, start);
    assertSame(token, actualAssociationBodyResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF><missing BRACE_CLOSE>", actualAssociationBodyResult.getText());
    assertEquals(3, actualAssociationBodyResult.getChildCount());
    DomainParserGrammar.PropertiesContext propertiesResult = actualAssociationBodyResult.properties();
    RecognitionException recognitionException = propertiesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.NoViableAltException);
    assertEquals(0, start.getTokenIndex());
    assertEquals(430, propertiesResult.invokingState);
    assertEquals("<EOF>", propertiesResult.getText());
    assertSame(start, propertiesResult.getStart());
    assertEquals(2, propertiesResult.depth());
    assertSame(start, propertiesResult.getStop());
    assertEquals(1, propertiesResult.getChildCount());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(propertiesResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
  }

  @Test
  public void testAssociationBodyContextAccept() {
    // Arrange
    DomainParserGrammar.AssociationBodyContext associationBodyContext = new DomainParserGrammar.AssociationBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(associationBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationBodyContextAccept2() {
    // Arrange
    DomainParserGrammar.AssociationBodyContext associationBodyContext = new DomainParserGrammar.AssociationBodyContext(
        new ParserRuleContext(), 1);
    associationBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(associationBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationBodyContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationBodyContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testAssociationBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testAssociationBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(17, (new DomainParserGrammar.AssociationBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAssociationBodyContextProperties() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationBodyContext(new ParserRuleContext(), 1)).properties());
  }

  @Test
  public void testAssociationContextASSOCIATION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).ASSOCIATION());
  }

  @Test
  public void testAssociationContextAccept() {
    // Arrange
    DomainParserGrammar.AssociationContext associationContext = new DomainParserGrammar.AssociationContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(associationContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationContextAccept2() {
    // Arrange
    DomainParserGrammar.AssociationContext associationContext = new DomainParserGrammar.AssociationContext(
        new ParserRuleContext(), 1);
    associationContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(associationContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationContextAssociationBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).associationBody());
  }

  @Test
  public void testAssociationContextAssociationProjection() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).associationProjection());
  }

  @Test
  public void testAssociationContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(16, (new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAssociationContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testAssociationContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testAssociationContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testAssociationProjection() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AssociationProjectionContext actualAssociationProjectionResult = domainParserGrammar
        .associationProjection();

    // Assert
    RecognitionException recognitionException = actualAssociationProjectionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAssociationProjectionResult.invokingState);
    assertNull(actualAssociationProjectionResult.getParent());
    Token expectedStart = actualAssociationProjectionResult.start;
    Token start = actualAssociationProjectionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualAssociationProjectionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(433, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualAssociationProjectionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAssociationProjection2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AssociationProjectionContext actualAssociationProjectionResult = domainParserGrammar
        .associationProjection();

    // Assert
    RecognitionException recognitionException = actualAssociationProjectionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualAssociationProjectionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualAssociationProjectionResult.getParent());
    Token expectedStart = actualAssociationProjectionResult.stop;
    Token start = actualAssociationProjectionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualAssociationProjectionResult.getStop());
    assertEquals("<missing 'projects'><EOF>", actualAssociationProjectionResult.getText());
    assertEquals(2, actualAssociationProjectionResult.getChildCount());
    assertTrue(actualAssociationProjectionResult.isEmpty());
    assertEquals("([] <missing 'projects'> ([434] ([1431 434] <EOF>)))",
        actualAssociationProjectionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(435, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualAssociationProjectionResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(434, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testAssociationProjectionContextAccept() {
    // Arrange
    DomainParserGrammar.AssociationProjectionContext associationProjectionContext = new DomainParserGrammar.AssociationProjectionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(associationProjectionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationProjectionContextAccept2() {
    // Arrange
    DomainParserGrammar.AssociationProjectionContext associationProjectionContext = new DomainParserGrammar.AssociationProjectionContext(
        new ParserRuleContext(), 1);
    associationProjectionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(associationProjectionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAssociationProjectionContextCOMMA() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).COMMA());
  }

  @Test
  public void testAssociationProjectionContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testAssociationProjectionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(18, (new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAssociationProjectionContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testAssociationProjectionContextPROJECTS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).PROJECTS());
  }

  @Test
  public void testAssociationProjectionContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).qualifiedName().isEmpty());
    assertNull((new DomainParserGrammar.AssociationProjectionContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testAtomicExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertNull(actualAtomicExpressionResult.getParent());
    assertNull(actualAtomicExpressionResult.getStop());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1043, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualAtomicExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualAtomicExpressionResult.type());
    assertNull(actualAtomicExpressionResult.getParent());
    Token token = actualAtomicExpressionResult.stop;
    Token stop = actualAtomicExpressionResult.getStop();
    assertSame(token, stop);
    assertSame(token, actualAtomicExpressionResult.getStart());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceReferenceContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceReferenceContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1046 1039]", getResult1.toString());
    assertEquals(1046, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualAtomicExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testAtomicExpression8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertNull(actualAtomicExpressionResult.getParent());
    assertNull(actualAtomicExpressionResult.getStop());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1043, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpression9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.AtomicExpressionContext actualAtomicExpressionResult = domainParserGrammar.atomicExpression();

    // Assert
    RecognitionException recognitionException = actualAtomicExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualAtomicExpressionResult.invokingState);
    assertNull(actualAtomicExpressionResult.getParent());
    assertNull(actualAtomicExpressionResult.getStop());
    Token expectedStart = actualAtomicExpressionResult.start;
    Token start = actualAtomicExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualAtomicExpressionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1043, recognitionException.getOffendingState());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testAtomicExpressionContextAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testAtomicExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.AtomicExpressionContext atomicExpressionContext = new DomainParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.AtomicExpressionContext atomicExpressionContext = new DomainParserGrammar.AtomicExpressionContext(
        new ParserRuleContext(), 1);
    atomicExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(atomicExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testAtomicExpressionContextDsl() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).dsl());
  }

  @Test
  public void testAtomicExpressionContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).expressionInstance());
  }

  @Test
  public void testAtomicExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(86, (new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testAtomicExpressionContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).instanceLiteralToken());
  }

  @Test
  public void testAtomicExpressionContextInstanceReference() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).instanceReference());
  }

  @Test
  public void testAtomicExpressionContextLambdaFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaFunction());
  }

  @Test
  public void testAtomicExpressionContextLambdaParam() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaParam());
  }

  @Test
  public void testAtomicExpressionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testAtomicExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testAtomicExpressionContextUnitInstance() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).unitInstance());
  }

  @Test
  public void testAtomicExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.AtomicExpressionContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testBooleanPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.BooleanPartContext actualBooleanPartResult = domainParserGrammar.booleanPart();

    // Assert
    RecognitionException recognitionException = actualBooleanPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBooleanPartResult.invokingState);
    assertNull(actualBooleanPartResult.getParent());
    Token expectedStart = actualBooleanPartResult.start;
    Token start = actualBooleanPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBooleanPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1285, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualBooleanPartResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBooleanPartContextAND() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).AND());
  }

  @Test
  public void testBooleanPartContextAccept() {
    // Arrange
    DomainParserGrammar.BooleanPartContext booleanPartContext = new DomainParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextAccept2() {
    // Arrange
    DomainParserGrammar.BooleanPartContext booleanPartContext = new DomainParserGrammar.BooleanPartContext(
        new ParserRuleContext(), 1);
    booleanPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(booleanPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBooleanPartContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testBooleanPartContextExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testBooleanPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(110, (new DomainParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testBooleanPartContextOR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.BooleanPartContext(new ParserRuleContext(), 1)).OR());
  }

  @Test
  public void testBuildMilestoningVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.BuildMilestoningVariableExpressionContext actualBuildMilestoningVariableExpressionResult = domainParserGrammar
        .buildMilestoningVariableExpression();

    // Assert
    RecognitionException recognitionException = actualBuildMilestoningVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualBuildMilestoningVariableExpressionResult.invokingState);
    assertNull(actualBuildMilestoningVariableExpressionResult.getParent());
    Token expectedStart = actualBuildMilestoningVariableExpressionResult.start;
    Token start = actualBuildMilestoningVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualBuildMilestoningVariableExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1108, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualBuildMilestoningVariableExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new DomainParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.BuildMilestoningVariableExpressionContext buildMilestoningVariableExpressionContext = new DomainParserGrammar.BuildMilestoningVariableExpressionContext(
        new ParserRuleContext(), 1);
    buildMilestoningVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(buildMilestoningVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextDATE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(95,
        (new DomainParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).LATEST_DATE());
  }

  @Test
  public void testBuildMilestoningVariableExpressionContextVariable() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.BuildMilestoningVariableExpressionContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testCanonicalExpr() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.CanonicalExprContext actualCanonicalExprResult = domainParserGrammar.canonicalExpr();

    // Assert
    RecognitionException recognitionException = actualCanonicalExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualCanonicalExprResult.invokingState);
    assertNull(actualCanonicalExprResult.getParent());
    Token expectedStart = actualCanonicalExprResult.start;
    Token start = actualCanonicalExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCanonicalExprResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(574, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualCanonicalExprResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testCanonicalExpr2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.CanonicalExprContext actualCanonicalExprResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).canonicalExpr();

    // Assert
    assertEquals(-1, actualCanonicalExprResult.invokingState);
    List<ParseTree> parseTreeList = actualCanonicalExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualCanonicalExprResult.getParent());
    Token token = actualCanonicalExprResult.stop;
    Token start = actualCanonicalExprResult.getStart();
    assertSame(token, start);
    assertSame(token, actualCanonicalExprResult.getStop());
    assertEquals(2, actualCanonicalExprResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MeasureExprContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.MeasureExprContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MeasureExprContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MeasureExprContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '*'>", getResult1.toString());
    assertTrue(
        ((DomainParserGrammar.MeasureExprContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("([575] ([577 575] ([1431 577 575] <EOF>)))", getResult.toStringTree());
    assertSame(actualCanonicalExprResult, getResult1.getParent());
  }

  @Test
  public void testCanonicalExprContextAccept() {
    // Arrange
    DomainParserGrammar.CanonicalExprContext canonicalExprContext = new DomainParserGrammar.CanonicalExprContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(canonicalExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCanonicalExprContextAccept2() {
    // Arrange
    DomainParserGrammar.CanonicalExprContext canonicalExprContext = new DomainParserGrammar.CanonicalExprContext(
        new ParserRuleContext(), 1);
    canonicalExprContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(canonicalExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCanonicalExprContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(30, (new DomainParserGrammar.CanonicalExprContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCanonicalExprContextMeasureExpr() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.CanonicalExprContext(new ParserRuleContext(), 1)).measureExpr());
  }

  @Test
  public void testCanonicalExprContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.CanonicalExprContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testClassBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ClassBodyContext actualClassBodyResult = domainParserGrammar.classBody();

    // Assert
    RecognitionException recognitionException = actualClassBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualClassBodyResult.invokingState);
    assertNull(actualClassBodyResult.getParent());
    Token expectedStart = actualClassBodyResult.start;
    Token start = actualClassBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualClassBodyResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(331, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualClassBodyResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testClassBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    // Act
    DomainParserGrammar.ClassBodyContext actualClassBodyResult = (new DomainParserGrammar(bufferedTokenStream))
        .classBody();

    // Assert
    assertEquals(-1, actualClassBodyResult.invokingState);
    assertEquals(3, actualClassBodyResult.children.size());
    assertNull(actualClassBodyResult.getParent());
    Token token = actualClassBodyResult.stop;
    Token start = actualClassBodyResult.getStart();
    assertSame(token, start);
    assertSame(token, actualClassBodyResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF><missing BRACE_CLOSE>", actualClassBodyResult.getText());
    assertEquals(3, actualClassBodyResult.getChildCount());
    DomainParserGrammar.PropertiesContext propertiesResult = actualClassBodyResult.properties();
    RecognitionException recognitionException = propertiesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.NoViableAltException);
    assertEquals(0, start.getTokenIndex());
    assertEquals(332, propertiesResult.invokingState);
    assertEquals("<EOF>", propertiesResult.getText());
    assertSame(start, propertiesResult.getStart());
    assertEquals(2, propertiesResult.depth());
    assertSame(start, propertiesResult.getStop());
    assertEquals(1, propertiesResult.getChildCount());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(propertiesResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
  }

  @Test
  public void testClassBodyContextAccept() {
    // Arrange
    DomainParserGrammar.ClassBodyContext classBodyContext = new DomainParserGrammar.ClassBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(classBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testClassBodyContextAccept2() {
    // Arrange
    DomainParserGrammar.ClassBodyContext classBodyContext = new DomainParserGrammar.ClassBodyContext(
        new ParserRuleContext(), 1);
    classBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(classBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testClassBodyContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassBodyContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testClassBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testClassBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(6, (new DomainParserGrammar.ClassBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testClassBodyContextProperties() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassBodyContext(new ParserRuleContext(), 1)).properties());
  }

  @Test
  public void testClassDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ClassDefinitionContext actualClassDefinitionResult = domainParserGrammar.classDefinition();

    // Assert
    RecognitionException recognitionException = actualClassDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualClassDefinitionResult.invokingState);
    assertEquals(1, actualClassDefinitionResult.depth());
    Token expectedStart = actualClassDefinitionResult.start;
    Token start = actualClassDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualClassDefinitionResult.getStop());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualClassDefinitionResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(301, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testClassDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ClassDefinitionContext actualClassDefinitionResult = domainParserGrammar.classDefinition();

    // Assert
    assertNull(actualClassDefinitionResult.stereotypes());
    RecognitionException recognitionException = actualClassDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualClassDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertTrue(actualClassDefinitionResult.isEmpty());
    assertEquals("([] <missing 'Class'> ([308] ([1431 308] <EOF>)))", actualClassDefinitionResult.toStringTree());
    assertEquals(1, actualClassDefinitionResult.depth());
    Token expectedStart = actualClassDefinitionResult.stop;
    Token start = actualClassDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualClassDefinitionResult.getStop());
    assertEquals("<missing 'Class'><EOF>", actualClassDefinitionResult.getText());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualClassDefinitionResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(310, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(308, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testClassDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.ClassDefinitionContext classDefinitionContext = new DomainParserGrammar.ClassDefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(classDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testClassDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.ClassDefinitionContext classDefinitionContext = new DomainParserGrammar.ClassDefinitionContext(
        new ParserRuleContext(), 1);
    classDefinitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(classDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testClassDefinitionContextCLASS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).CLASS());
  }

  @Test
  public void testClassDefinitionContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testClassDefinitionContextClassBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).classBody());
  }

  @Test
  public void testClassDefinitionContextConstraints() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).constraints());
  }

  @Test
  public void testClassDefinitionContextEXTENDS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).EXTENDS());
  }

  @Test
  public void testClassDefinitionContextPROJECTS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).PROJECTS());
  }

  @Test
  public void testClassDefinitionContextProjection() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).projection());
  }

  @Test
  public void testClassDefinitionContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testClassDefinitionContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testClassDefinitionContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testClassDefinitionContextType() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).type().isEmpty());
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1)).type(1));
  }

  @Test
  public void testClassDefinitionContextTypeParametersWithContravarianceAndMultiplicityParameters() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ClassDefinitionContext(new ParserRuleContext(), 1))
        .typeParametersWithContravarianceAndMultiplicityParameters());
  }

  @Test
  public void testCodeBlock() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = domainParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlock2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(72));

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertNull(((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([925] ([937 925] ([960 937 925] [967 960 937 925])))", getResult.toStringTree());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertNull(((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals("[937 925]", getResult1.toString());
  }

  @Test
  public void testCodeBlock4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = domainParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = domainParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = domainParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.stop;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ProgramLineContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(937, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testCodeBlock9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CodeBlockContext actualCodeBlockResult = domainParserGrammar.codeBlock();

    // Assert
    assertEquals(-1, actualCodeBlockResult.invokingState);
    List<ParseTree> parseTreeList = actualCodeBlockResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCodeBlockResult.getParent());
    Token expectedStart = actualCodeBlockResult.start;
    Token start = actualCodeBlockResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCodeBlockResult.getStop());
    assertEquals(1, actualCodeBlockResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ProgramLineContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ProgramLineContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testCodeBlockContextAccept() {
    // Arrange
    DomainParserGrammar.CodeBlockContext codeBlockContext = new DomainParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextAccept2() {
    // Arrange
    DomainParserGrammar.CodeBlockContext codeBlockContext = new DomainParserGrammar.CodeBlockContext(
        new ParserRuleContext(), 1);
    codeBlockContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(codeBlockContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCodeBlockContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(71, (new DomainParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCodeBlockContextProgramLine() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine().isEmpty());
    assertNull((new DomainParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).programLine(1));
  }

  @Test
  public void testCodeBlockContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON().isEmpty());
    assertNull((new DomainParserGrammar.CodeBlockContext(new ParserRuleContext(), 1)).SEMI_COLON(1));
  }

  @Test
  public void testCombinedArithmeticOnly() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 944]", expressionResult.toString());
  }

  @Test
  public void testCombinedArithmeticOnly10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = domainParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 944]", expressionResult.toString());
  }

  @Test
  public void testCombinedArithmeticOnly2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(78));

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = domainParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = domainParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = domainParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.stop;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedArithmeticOnly9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CombinedArithmeticOnlyContext actualCombinedArithmeticOnlyResult = domainParserGrammar
        .combinedArithmeticOnly();

    // Assert
    assertEquals(-1, actualCombinedArithmeticOnlyResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedArithmeticOnlyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedArithmeticOnlyResult.getParent());
    Token expectedStart = actualCombinedArithmeticOnlyResult.start;
    Token start = actualCombinedArithmeticOnlyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedArithmeticOnlyResult.getStop());
    assertEquals(1, actualCombinedArithmeticOnlyResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 944]", expressionResult.toString());
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept() {
    // Arrange
    DomainParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new DomainParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextAccept2() {
    // Arrange
    DomainParserGrammar.CombinedArithmeticOnlyContext combinedArithmeticOnlyContext = new DomainParserGrammar.CombinedArithmeticOnlyContext(
        new ParserRuleContext(), 1);
    combinedArithmeticOnlyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedArithmeticOnlyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedArithmeticOnlyContextArithmeticPart() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).arithmeticPart().isEmpty());
    assertNull((new DomainParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).arithmeticPart(1));
  }

  @Test
  public void testCombinedArithmeticOnlyContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1))
        .expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedArithmeticOnlyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(74,
        (new DomainParserGrammar.CombinedArithmeticOnlyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testCombinedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 960]", expressionResult.toString());
  }

  @Test
  public void testCombinedExpression10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = domainParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 960]", expressionResult.toString());
  }

  @Test
  public void testCombinedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(78));

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = domainParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = domainParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = domainParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.stop;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertSame(start, expressionResult.getStart());
    assertEquals(967, expressionResult.invokingState);
    assertSame(start, expressionResult.getStop());
    assertEquals(3, expressionResult.depth());
    assertEquals(1, expressionResult.getChildCount());
  }

  @Test
  public void testCombinedExpression9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.CombinedExpressionContext actualCombinedExpressionResult = domainParserGrammar
        .combinedExpression();

    // Assert
    assertEquals(-1, actualCombinedExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualCombinedExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualCombinedExpressionResult.getParent());
    Token expectedStart = actualCombinedExpressionResult.start;
    Token start = actualCombinedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualCombinedExpressionResult.getStop());
    assertEquals(1, actualCombinedExpressionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).isEmpty());
    assertEquals(1, tokenSource.getLine());
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult)
        .expression();
    assertEquals(967, expressionResult.invokingState);
    assertTrue(expressionResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[967 960]", expressionResult.toString());
  }

  @Test
  public void testCombinedExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.CombinedExpressionContext combinedExpressionContext = new DomainParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.CombinedExpressionContext combinedExpressionContext = new DomainParserGrammar.CombinedExpressionContext(
        new ParserRuleContext(), 1);
    combinedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(combinedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testCombinedExpressionContextExpressionOrExpressionGroup() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionOrExpressionGroup());
  }

  @Test
  public void testCombinedExpressionContextExpressionPart() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionPart().isEmpty());
    assertNull((new DomainParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).expressionPart(1));
  }

  @Test
  public void testCombinedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(77, (new DomainParserGrammar.CombinedExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testComplexConstraint() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ComplexConstraintContext actualComplexConstraintResult = domainParserGrammar
        .complexConstraint();

    // Assert
    RecognitionException recognitionException = actualComplexConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualComplexConstraintResult.children.size());
    assertNull(actualComplexConstraintResult.getParent());
    Token expectedStart = actualComplexConstraintResult.start;
    Token start = actualComplexConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualComplexConstraintResult.getStop());
    assertEquals(1, actualComplexConstraintResult.getChildCount());
    assertTrue(actualComplexConstraintResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualComplexConstraintResult.identifier();
    assertEquals(652, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(653, recognitionException.getOffendingState());
    assertSame(actualComplexConstraintResult, recognitionException.getCtx());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
  }

  @Test
  public void testComplexConstraint2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ComplexConstraintContext actualComplexConstraintResult = domainParserGrammar
        .complexConstraint();

    // Assert
    RecognitionException recognitionException = actualComplexConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualComplexConstraintResult.children.size());
    assertNull(actualComplexConstraintResult.getParent());
    Token expectedStart = actualComplexConstraintResult.stop;
    Token start = actualComplexConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualComplexConstraintResult.getStop());
    assertEquals("null", actualComplexConstraintResult.getText());
    assertEquals(1, actualComplexConstraintResult.getChildCount());
    assertTrue(actualComplexConstraintResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualComplexConstraintResult.identifier();
    assertEquals(652, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(653, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualComplexConstraintResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testComplexConstraint3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ComplexConstraintContext actualComplexConstraintResult = domainParserGrammar
        .complexConstraint();

    // Assert
    RecognitionException recognitionException = actualComplexConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualComplexConstraintResult.children.size());
    assertNull(actualComplexConstraintResult.getParent());
    Token expectedStart = actualComplexConstraintResult.stop;
    Token start = actualComplexConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualComplexConstraintResult.getStop());
    assertEquals("null", actualComplexConstraintResult.getText());
    assertEquals(1, actualComplexConstraintResult.getChildCount());
    assertTrue(actualComplexConstraintResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualComplexConstraintResult.identifier();
    assertEquals(652, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(653, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualComplexConstraintResult, recognitionException.getCtx());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testComplexConstraintContextAccept() {
    // Arrange
    DomainParserGrammar.ComplexConstraintContext complexConstraintContext = new DomainParserGrammar.ComplexConstraintContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(complexConstraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testComplexConstraintContextAccept2() {
    // Arrange
    DomainParserGrammar.ComplexConstraintContext complexConstraintContext = new DomainParserGrammar.ComplexConstraintContext(
        new ParserRuleContext(), 1);
    complexConstraintContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(complexConstraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testComplexConstraintContextConstraintEnforcementLevel() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).constraintEnforcementLevel());
  }

  @Test
  public void testComplexConstraintContextConstraintExternalId() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).constraintExternalId());
  }

  @Test
  public void testComplexConstraintContextConstraintFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).constraintFunction());
  }

  @Test
  public void testComplexConstraintContextConstraintMessage() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).constraintMessage());
  }

  @Test
  public void testComplexConstraintContextConstraintOwner() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).constraintOwner());
  }

  @Test
  public void testComplexConstraintContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(40, (new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testComplexConstraintContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testComplexConstraintContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testComplexConstraintContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexConstraintContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testComplexProperty() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.ComplexPropertyContext actualComplexPropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).complexProperty();

    // Assert
    assertNull(actualComplexPropertyResult.stereotypes());
    assertEquals(-1, actualComplexPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualComplexPropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualComplexPropertyResult.getParent());
    Token expectedStart = actualComplexPropertyResult.start;
    Token start = actualComplexPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualComplexPropertyResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(748, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertEquals("([748] [778 748])", getResult.toStringTree());
    assertEquals(1, tokenSource.getLine());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    assertNull(((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals(778, ((DomainParserGrammar.PropertyRefContext) getResult).identifier().invokingState);
  }

  @Test
  public void testComplexProperty2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ComplexPropertyContext actualComplexPropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).complexProperty();

    // Assert
    assertNull(actualComplexPropertyResult.stereotypes());
    assertEquals(-1, actualComplexPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualComplexPropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualComplexPropertyResult.getParent());
    Token token = actualComplexPropertyResult.stop;
    assertSame(token, actualComplexPropertyResult.getStart());
    Token stop = actualComplexPropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(748, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertEquals(778, identifierResult.invokingState);
    Interval expectedSourceInterval = actualComplexPropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[778 748]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testComplexProperty3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ComplexPropertyContext actualComplexPropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).complexProperty();

    // Assert
    assertNull(actualComplexPropertyResult.stereotypes());
    assertEquals(-1, actualComplexPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualComplexPropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualComplexPropertyResult.getParent());
    Token token = actualComplexPropertyResult.stop;
    assertSame(token, actualComplexPropertyResult.getStart());
    Token stop = actualComplexPropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    assertEquals("Input", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(0, stop.getStartIndex());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    assertEquals(1, stop.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(748, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("Input", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertEquals(778, identifierResult.invokingState);
    assertEquals("[778 748]", identifierResult.toString());
    Interval expectedSourceInterval = actualComplexPropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testComplexProperty4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ComplexPropertyContext actualComplexPropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).complexProperty();

    // Assert
    assertNull(actualComplexPropertyResult.stereotypes());
    assertEquals(-1, actualComplexPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualComplexPropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualComplexPropertyResult.getParent());
    Token expectedStart = actualComplexPropertyResult.start;
    Token start = actualComplexPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualComplexPropertyResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(748, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals("([748] [778 748])", getResult.toStringTree());
    assertSame(start, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    assertNull(((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(778, ((DomainParserGrammar.PropertyRefContext) getResult).identifier().invokingState);
  }

  @Test
  public void testComplexProperty5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ComplexPropertyContext actualComplexPropertyResult = domainParserGrammar.complexProperty();

    // Assert
    assertNull(actualComplexPropertyResult.stereotypes());
    assertEquals(-1, actualComplexPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualComplexPropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualComplexPropertyResult.getParent());
    Token token = actualComplexPropertyResult.stop;
    assertSame(token, actualComplexPropertyResult.getStart());
    Token stop = actualComplexPropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    assertEquals("Input", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(0, stop.getStartIndex());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    assertEquals(1, stop.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(748, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("Input", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertEquals(778, identifierResult.invokingState);
    assertEquals("[778 748]", identifierResult.toString());
    Interval expectedSourceInterval = actualComplexPropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testComplexPropertyContextAccept() {
    // Arrange
    DomainParserGrammar.ComplexPropertyContext complexPropertyContext = new DomainParserGrammar.ComplexPropertyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(complexPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testComplexPropertyContextAccept2() {
    // Arrange
    DomainParserGrammar.ComplexPropertyContext complexPropertyContext = new DomainParserGrammar.ComplexPropertyContext(
        new ParserRuleContext(), 1);
    complexPropertyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(complexPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testComplexPropertyContextAlias() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).alias());
  }

  @Test
  public void testComplexPropertyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(54, (new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testComplexPropertyContextPropertyRef() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).propertyRef());
  }

  @Test
  public void testComplexPropertyContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testComplexPropertyContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testComplexPropertyContextTreePathClassBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ComplexPropertyContext(new ParserRuleContext(), 1)).treePathClassBody());
  }

  @Test
  public void testConstraint() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    RecognitionException recognitionException = actualConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintResult.invokingState);
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.start;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(645, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraint10() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    RecognitionException recognitionException = actualConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintResult.invokingState);
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.start;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(645, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraint11() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    RecognitionException recognitionException = actualConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintResult.invokingState);
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.start;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(645, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraint2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(38));

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(78));

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint6() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraint9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintContext actualConstraintResult = domainParserGrammar.constraint();

    // Assert
    assertEquals(-1, actualConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualConstraintResult.getParent());
    Token expectedStart = actualConstraintResult.stop;
    Token start = actualConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintResult.getStop());
    assertEquals(1, actualConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.SimpleConstraintContext) getResult).depth());
    assertFalse(((DomainParserGrammar.SimpleConstraintContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.SimpleConstraintContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.SimpleConstraintContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(650, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testConstraintContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintContext constraintContext = new DomainParserGrammar.ConstraintContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintContext constraintContext = new DomainParserGrammar.ConstraintContext(
        new ParserRuleContext(), 1);
    constraintContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintContextComplexConstraint() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintContext(new ParserRuleContext(), 1)).complexConstraint());
  }

  @Test
  public void testConstraintContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(38, (new DomainParserGrammar.ConstraintContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintContextSimpleConstraint() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintContext(new ParserRuleContext(), 1)).simpleConstraint());
  }

  @Test
  public void testConstraintEnforcementLevel() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelContext actualConstraintEnforcementLevelResult = domainParserGrammar
        .constraintEnforcementLevel();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintEnforcementLevelResult.invokingState);
    assertNull(actualConstraintEnforcementLevelResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelResult.start;
    Token start = actualConstraintEnforcementLevelResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintEnforcementLevelResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(681, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintEnforcementLevelResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraintEnforcementLevel2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelContext actualConstraintEnforcementLevelResult = domainParserGrammar
        .constraintEnforcementLevel();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintEnforcementLevelResult.children.size());
    assertNull(actualConstraintEnforcementLevelResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelResult.stop;
    Token start = actualConstraintEnforcementLevelResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintEnforcementLevelResult.getStop());
    assertEquals("null", actualConstraintEnforcementLevelResult.getText());
    assertEquals(1, actualConstraintEnforcementLevelResult.getChildCount());
    assertTrue(actualConstraintEnforcementLevelResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(681, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintEnforcementLevelResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintEnforcementLevel3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(15));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelContext actualConstraintEnforcementLevelResult = domainParserGrammar
        .constraintEnforcementLevel();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintEnforcementLevelResult.children.size());
    assertNull(actualConstraintEnforcementLevelResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelResult.stop;
    Token start = actualConstraintEnforcementLevelResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintEnforcementLevelResult.getStop());
    assertEquals("null", actualConstraintEnforcementLevelResult.getText());
    assertEquals(1, actualConstraintEnforcementLevelResult.getChildCount());
    assertTrue(actualConstraintEnforcementLevelResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(682, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualConstraintEnforcementLevelResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintEnforcementLevelContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintEnforcementLevelContext constraintEnforcementLevelContext = new DomainParserGrammar.ConstraintEnforcementLevelContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintEnforcementLevelContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintEnforcementLevelContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintEnforcementLevelContext constraintEnforcementLevelContext = new DomainParserGrammar.ConstraintEnforcementLevelContext(
        new ParserRuleContext(), 1);
    constraintEnforcementLevelContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintEnforcementLevelContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintEnforcementLevelContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintEnforcementLevelContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintEnforcementLevelContextCONSTRAINT_ENFORCEMENT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintEnforcementLevelContext(new ParserRuleContext(), 1))
        .CONSTRAINT_ENFORCEMENT());
  }

  @Test
  public void testConstraintEnforcementLevelContextConstraintEnforcementLevelType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintEnforcementLevelContext(new ParserRuleContext(), 1))
        .constraintEnforcementLevelType());
  }

  @Test
  public void testConstraintEnforcementLevelContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(44,
        (new DomainParserGrammar.ConstraintEnforcementLevelContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintEnforcementLevelType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = domainParserGrammar
        .constraintEnforcementLevelType();

    // Assert
    assertEquals(-1, actualConstraintEnforcementLevelTypeResult.invokingState);
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.start;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testConstraintEnforcementLevelType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = domainParserGrammar
        .constraintEnforcementLevelType();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.children.size());
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.stop;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("null", actualConstraintEnforcementLevelTypeResult.getText());
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.getChildCount());
    assertTrue(actualConstraintEnforcementLevelTypeResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(685, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintEnforcementLevelTypeResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintEnforcementLevelType3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = domainParserGrammar
        .constraintEnforcementLevelType();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.children.size());
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.stop;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("Input", actualConstraintEnforcementLevelTypeResult.getText());
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.getChildCount());
    assertTrue(actualConstraintEnforcementLevelTypeResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(685, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualConstraintEnforcementLevelTypeResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testConstraintEnforcementLevelType4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).constraintEnforcementLevelType();

    // Assert
    assertEquals(-1, actualConstraintEnforcementLevelTypeResult.invokingState);
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.start;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testConstraintEnforcementLevelType5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = domainParserGrammar
        .constraintEnforcementLevelType();

    // Assert
    RecognitionException recognitionException = actualConstraintEnforcementLevelTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.children.size());
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.stop;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("Input", actualConstraintEnforcementLevelTypeResult.getText());
    assertEquals(1, actualConstraintEnforcementLevelTypeResult.getChildCount());
    assertTrue(actualConstraintEnforcementLevelTypeResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(685, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualConstraintEnforcementLevelTypeResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testConstraintEnforcementLevelType6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext actualConstraintEnforcementLevelTypeResult = domainParserGrammar
        .constraintEnforcementLevelType();

    // Assert
    assertEquals(-1, actualConstraintEnforcementLevelTypeResult.invokingState);
    assertNull(actualConstraintEnforcementLevelTypeResult.getParent());
    Token expectedStart = actualConstraintEnforcementLevelTypeResult.start;
    Token start = actualConstraintEnforcementLevelTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintEnforcementLevelTypeResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testConstraintEnforcementLevelTypeContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext constraintEnforcementLevelTypeContext = new DomainParserGrammar.ConstraintEnforcementLevelTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintEnforcementLevelTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintEnforcementLevelTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintEnforcementLevelTypeContext constraintEnforcementLevelTypeContext = new DomainParserGrammar.ConstraintEnforcementLevelTypeContext(
        new ParserRuleContext(), 1);
    constraintEnforcementLevelTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintEnforcementLevelTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintEnforcementLevelTypeContextCONSTRAINT_ENFORCEMENT_LEVEL_ERROR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintEnforcementLevelTypeContext(new ParserRuleContext(), 1))
        .CONSTRAINT_ENFORCEMENT_LEVEL_ERROR());
  }

  @Test
  public void testConstraintEnforcementLevelTypeContextCONSTRAINT_ENFORCEMENT_LEVEL_WARN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintEnforcementLevelTypeContext(new ParserRuleContext(), 1))
        .CONSTRAINT_ENFORCEMENT_LEVEL_WARN());
  }

  @Test
  public void testConstraintEnforcementLevelTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(45,
        (new DomainParserGrammar.ConstraintEnforcementLevelTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintExternalId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintExternalIdContext actualConstraintExternalIdResult = domainParserGrammar
        .constraintExternalId();

    // Assert
    RecognitionException recognitionException = actualConstraintExternalIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintExternalIdResult.invokingState);
    assertNull(actualConstraintExternalIdResult.getParent());
    Token expectedStart = actualConstraintExternalIdResult.start;
    Token start = actualConstraintExternalIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintExternalIdResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(673, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintExternalIdResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraintExternalId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintExternalIdContext actualConstraintExternalIdResult = domainParserGrammar
        .constraintExternalId();

    // Assert
    RecognitionException recognitionException = actualConstraintExternalIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintExternalIdResult.children.size());
    assertNull(actualConstraintExternalIdResult.getParent());
    Token expectedStart = actualConstraintExternalIdResult.stop;
    Token start = actualConstraintExternalIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintExternalIdResult.getStop());
    assertEquals("null", actualConstraintExternalIdResult.getText());
    assertEquals(1, actualConstraintExternalIdResult.getChildCount());
    assertTrue(actualConstraintExternalIdResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(673, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintExternalIdResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintExternalId3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(12));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintExternalIdContext actualConstraintExternalIdResult = domainParserGrammar
        .constraintExternalId();

    // Assert
    RecognitionException recognitionException = actualConstraintExternalIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintExternalIdResult.children.size());
    assertNull(actualConstraintExternalIdResult.getParent());
    Token expectedStart = actualConstraintExternalIdResult.stop;
    Token start = actualConstraintExternalIdResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintExternalIdResult.getStop());
    assertEquals("null", actualConstraintExternalIdResult.getText());
    assertEquals(1, actualConstraintExternalIdResult.getChildCount());
    assertTrue(actualConstraintExternalIdResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(674, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualConstraintExternalIdResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintExternalIdContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintExternalIdContext constraintExternalIdContext = new DomainParserGrammar.ConstraintExternalIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintExternalIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintExternalIdContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintExternalIdContext constraintExternalIdContext = new DomainParserGrammar.ConstraintExternalIdContext(
        new ParserRuleContext(), 1);
    constraintExternalIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintExternalIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintExternalIdContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintExternalIdContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintExternalIdContextCONSTRAINT_EXTERNAL_ID() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.ConstraintExternalIdContext(new ParserRuleContext(), 1)).CONSTRAINT_EXTERNAL_ID());
  }

  @Test
  public void testConstraintExternalIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(42, (new DomainParserGrammar.ConstraintExternalIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintExternalIdContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintExternalIdContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testConstraintFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintFunctionContext actualConstraintFunctionResult = domainParserGrammar
        .constraintFunction();

    // Assert
    RecognitionException recognitionException = actualConstraintFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintFunctionResult.invokingState);
    assertNull(actualConstraintFunctionResult.getParent());
    Token expectedStart = actualConstraintFunctionResult.start;
    Token start = actualConstraintFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(677, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraintFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintFunctionContext actualConstraintFunctionResult = domainParserGrammar
        .constraintFunction();

    // Assert
    RecognitionException recognitionException = actualConstraintFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintFunctionResult.children.size());
    assertNull(actualConstraintFunctionResult.getParent());
    Token expectedStart = actualConstraintFunctionResult.stop;
    Token start = actualConstraintFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintFunctionResult.getStop());
    assertEquals("null", actualConstraintFunctionResult.getText());
    assertEquals(1, actualConstraintFunctionResult.getChildCount());
    assertTrue(actualConstraintFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(677, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(13));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintFunctionContext actualConstraintFunctionResult = domainParserGrammar
        .constraintFunction();

    // Assert
    RecognitionException recognitionException = actualConstraintFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintFunctionResult.children.size());
    assertNull(actualConstraintFunctionResult.getParent());
    Token expectedStart = actualConstraintFunctionResult.stop;
    Token start = actualConstraintFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintFunctionResult.getStop());
    assertEquals("null", actualConstraintFunctionResult.getText());
    assertEquals(1, actualConstraintFunctionResult.getChildCount());
    assertTrue(actualConstraintFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(678, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualConstraintFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintFunctionContext constraintFunctionContext = new DomainParserGrammar.ConstraintFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintFunctionContext constraintFunctionContext = new DomainParserGrammar.ConstraintFunctionContext(
        new ParserRuleContext(), 1);
    constraintFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintFunctionContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintFunctionContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintFunctionContextCONSTRAINT_FUNCTION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintFunctionContext(new ParserRuleContext(), 1)).CONSTRAINT_FUNCTION());
  }

  @Test
  public void testConstraintFunctionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintFunctionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testConstraintFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(43, (new DomainParserGrammar.ConstraintFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintId() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintIdResult.getStop());
    assertEquals("<missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    RecognitionException recognitionException = identifierResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(identifierResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
  }

  @Test
  public void testConstraintId2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    RecognitionException recognitionException = actualConstraintIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualConstraintIdResult.stop;
    Token stop = actualConstraintIdResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    assertTrue(actualConstraintIdResult.isEmpty());
    assertEquals(691, actualConstraintIdResult.identifier().invokingState);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(692, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertSame(actualConstraintIdResult, recognitionException.getCtx());
    assertEquals("[@1,0:0='<no text>',<1>,0:-1]", stop.toString());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testConstraintId3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintIdResult.getStop());
    assertEquals("<missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    RecognitionException recognitionException = identifierResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getType());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertSame(identifierResult, recognitionException.getCtx());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
  }

  @Test
  public void testConstraintId4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    RecognitionException recognitionException = actualConstraintIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualConstraintIdResult.stop;
    Token stop = actualConstraintIdResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    assertTrue(actualConstraintIdResult.isEmpty());
    assertEquals(691, actualConstraintIdResult.identifier().invokingState);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(692, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertSame(actualConstraintIdResult, recognitionException.getCtx());
    assertEquals("[@1,0:0='<no text>',<0>,0:-1]", stop.toString());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testConstraintId5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    RecognitionException recognitionException = actualConstraintIdResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualConstraintIdResult.stop;
    Token stop = actualConstraintIdResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    assertTrue(actualConstraintIdResult.isEmpty());
    assertEquals(691, actualConstraintIdResult.identifier().invokingState);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(692, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertSame(actualConstraintIdResult, recognitionException.getCtx());
    assertEquals("[@1,0:0='<no text>',<1>,0:-1]", stop.toString());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testConstraintId6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    List<ParseTree> parseTreeList = actualConstraintIdResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualConstraintIdResult.getParent());
    Token token = actualConstraintIdResult.stop;
    Token start = actualConstraintIdResult.getStart();
    assertSame(token, start);
    assertSame(token, actualConstraintIdResult.getStop());
    assertEquals("<EOF><missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualConstraintIdResult, parseTreeList.get(1).getParent());
  }

  @Test
  public void testConstraintId7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintIdResult.getStop());
    assertEquals("<missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    RecognitionException recognitionException = identifierResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(identifierResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
  }

  @Test
  public void testConstraintId8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintIdResult.getStop());
    assertEquals("<missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    RecognitionException recognitionException = identifierResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(identifierResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
  }

  @Test
  public void testConstraintId9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.ConstraintIdContext actualConstraintIdResult = domainParserGrammar.constraintId();

    // Assert
    assertEquals(-1, actualConstraintIdResult.invokingState);
    assertEquals(2, actualConstraintIdResult.children.size());
    assertNull(actualConstraintIdResult.getParent());
    Token expectedStart = actualConstraintIdResult.start;
    Token start = actualConstraintIdResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintIdResult.getStop());
    assertEquals("<missing ':'>", actualConstraintIdResult.getText());
    assertEquals(2, actualConstraintIdResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualConstraintIdResult.identifier();
    RecognitionException recognitionException = identifierResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(691, identifierResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource1, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(identifierResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(268, recognitionException.getOffendingState());
  }

  @Test
  public void testConstraintIdContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintIdContext constraintIdContext = new DomainParserGrammar.ConstraintIdContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintIdContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintIdContext constraintIdContext = new DomainParserGrammar.ConstraintIdContext(
        new ParserRuleContext(), 1);
    constraintIdContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintIdContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintIdContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintIdContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintIdContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(47, (new DomainParserGrammar.ConstraintIdContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintIdContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintIdContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testConstraintMessage() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintMessageContext actualConstraintMessageResult = domainParserGrammar
        .constraintMessage();

    // Assert
    RecognitionException recognitionException = actualConstraintMessageResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintMessageResult.invokingState);
    assertNull(actualConstraintMessageResult.getParent());
    Token expectedStart = actualConstraintMessageResult.start;
    Token start = actualConstraintMessageResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintMessageResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(687, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintMessageResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testConstraintMessage2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintMessageContext actualConstraintMessageResult = domainParserGrammar
        .constraintMessage();

    // Assert
    RecognitionException recognitionException = actualConstraintMessageResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintMessageResult.children.size());
    assertNull(actualConstraintMessageResult.getParent());
    Token expectedStart = actualConstraintMessageResult.stop;
    Token start = actualConstraintMessageResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintMessageResult.getStop());
    assertEquals("null", actualConstraintMessageResult.getText());
    assertEquals(1, actualConstraintMessageResult.getChildCount());
    assertTrue(actualConstraintMessageResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(687, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintMessageResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintMessage3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(14));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintMessageContext actualConstraintMessageResult = domainParserGrammar
        .constraintMessage();

    // Assert
    RecognitionException recognitionException = actualConstraintMessageResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintMessageResult.children.size());
    assertNull(actualConstraintMessageResult.getParent());
    Token expectedStart = actualConstraintMessageResult.stop;
    Token start = actualConstraintMessageResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintMessageResult.getStop());
    assertEquals("null", actualConstraintMessageResult.getText());
    assertEquals(1, actualConstraintMessageResult.getChildCount());
    assertTrue(actualConstraintMessageResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(688, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualConstraintMessageResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testConstraintMessageContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintMessageContext constraintMessageContext = new DomainParserGrammar.ConstraintMessageContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintMessageContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintMessageContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintMessageContext constraintMessageContext = new DomainParserGrammar.ConstraintMessageContext(
        new ParserRuleContext(), 1);
    constraintMessageContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintMessageContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintMessageContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintMessageContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintMessageContextCONSTRAINT_MESSAGE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintMessageContext(new ParserRuleContext(), 1)).CONSTRAINT_MESSAGE());
  }

  @Test
  public void testConstraintMessageContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintMessageContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testConstraintMessageContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(46, (new DomainParserGrammar.ConstraintMessageContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintOwner() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintOwnerContext actualConstraintOwnerResult = domainParserGrammar.constraintOwner();

    // Assert
    RecognitionException recognitionException = actualConstraintOwnerResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintOwnerResult.invokingState);
    assertNull(actualConstraintOwnerResult.getParent());
    Token expectedStart = actualConstraintOwnerResult.start;
    Token start = actualConstraintOwnerResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintOwnerResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(669, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualConstraintOwnerResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testConstraintOwner2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintOwnerContext actualConstraintOwnerResult = domainParserGrammar.constraintOwner();

    // Assert
    RecognitionException recognitionException = actualConstraintOwnerResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintOwnerResult.children.size());
    assertNull(actualConstraintOwnerResult.getParent());
    Token expectedStart = actualConstraintOwnerResult.stop;
    Token start = actualConstraintOwnerResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintOwnerResult.getStop());
    assertEquals("null", actualConstraintOwnerResult.getText());
    assertEquals(1, actualConstraintOwnerResult.getChildCount());
    assertTrue(actualConstraintOwnerResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(669, recognitionException.getOffendingState());
    assertSame(actualConstraintOwnerResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testConstraintOwner3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(11));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintOwnerContext actualConstraintOwnerResult = domainParserGrammar.constraintOwner();

    // Assert
    RecognitionException recognitionException = actualConstraintOwnerResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualConstraintOwnerResult.children.size());
    assertNull(actualConstraintOwnerResult.getParent());
    Token expectedStart = actualConstraintOwnerResult.stop;
    Token start = actualConstraintOwnerResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintOwnerResult.getStop());
    assertEquals("null", actualConstraintOwnerResult.getText());
    assertEquals(1, actualConstraintOwnerResult.getChildCount());
    assertTrue(actualConstraintOwnerResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(670, recognitionException.getOffendingState());
    assertSame(actualConstraintOwnerResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testConstraintOwnerContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintOwnerContext constraintOwnerContext = new DomainParserGrammar.ConstraintOwnerContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintOwnerContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintOwnerContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintOwnerContext constraintOwnerContext = new DomainParserGrammar.ConstraintOwnerContext(
        new ParserRuleContext(), 1);
    constraintOwnerContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintOwnerContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintOwnerContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintOwnerContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testConstraintOwnerContextCONSTRAINT_OWNER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintOwnerContext(new ParserRuleContext(), 1)).CONSTRAINT_OWNER());
  }

  @Test
  public void testConstraintOwnerContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(41, (new DomainParserGrammar.ConstraintOwnerContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstraintOwnerContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintOwnerContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testConstraints() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintsContext actualConstraintsResult = domainParserGrammar.constraints();

    // Assert
    RecognitionException recognitionException = actualConstraintsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualConstraintsResult.invokingState);
    assertNull(actualConstraintsResult.getParent());
    Token expectedStart = actualConstraintsResult.start;
    Token start = actualConstraintsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualConstraintsResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(632, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualConstraintsResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testConstraints2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ConstraintsContext actualConstraintsResult = domainParserGrammar.constraints();

    // Assert
    RecognitionException recognitionException = actualConstraintsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualConstraintsResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualConstraintsResult.getParent());
    Token expectedStart = actualConstraintsResult.stop;
    Token start = actualConstraintsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualConstraintsResult.getStop());
    assertEquals("<missing '['><EOF>", actualConstraintsResult.getText());
    assertEquals(2, actualConstraintsResult.getChildCount());
    assertTrue(actualConstraintsResult.isEmpty());
    assertEquals(
        "([] <missing '['> ([633] ([643 633] ([650 643 633] ([960 650 643 633] ([967 960 650 643 633] ([800 967"
            + " 960 650 643 633] ([1039 800 967 960 650 643 633] ([1046 1039 800 967 960 650 643 633] ([1431 1046"
            + " 1039 800 967 960 650 643 633] <EOF>))))))))))",
        actualConstraintsResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualConstraintsResult, recognitionException.getCtx());
    assertEquals(638, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(633, ((DomainParserGrammar.ConstraintContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("<missing '['>", getResult.toString());
    assertSame(actualConstraintsResult, getResult.getParent());
    assertEquals("<missing '['>", getResult.getText());
  }

  @Test
  public void testConstraintsContextAccept() {
    // Arrange
    DomainParserGrammar.ConstraintsContext constraintsContext = new DomainParserGrammar.ConstraintsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(constraintsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintsContextAccept2() {
    // Arrange
    DomainParserGrammar.ConstraintsContext constraintsContext = new DomainParserGrammar.ConstraintsContext(
        new ParserRuleContext(), 1);
    constraintsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(constraintsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testConstraintsContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testConstraintsContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testConstraintsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testConstraintsContextConstraint() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).constraint().isEmpty());
    assertNull((new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).constraint(1));
  }

  @Test
  public void testConstraintsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(37, (new DomainParserGrammar.ConstraintsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testConstructor() {
    // Arrange and Act
    DomainParserGrammar actualDomainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(new ArrayList<Token>())));

    // Assert
    assertNull(actualDomainParserGrammar.getParseInfo());
    assertEquals(0, actualDomainParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualDomainParserGrammar.isMatchedEOF());
    assertNull(actualDomainParserGrammar.getContext());
    assertTrue(actualDomainParserGrammar.getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualDomainParserGrammar.getPrecedence());
    assertEquals("List", actualDomainParserGrammar.getSourceName());
    assertFalse(actualDomainParserGrammar.isTrace());
    assertTrue(actualDomainParserGrammar.getBuildParseTree());
    assertEquals(-1, actualDomainParserGrammar.getState());
    assertTrue(actualDomainParserGrammar.getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualDomainParserGrammar.getInterpreter();
    assertSame(actualDomainParserGrammar, interpreter.getParser());
    assertEquals(164, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualDomainParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualDomainParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testConstructor2() {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar actualDomainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Assert
    assertNull(actualDomainParserGrammar.getParseInfo());
    assertEquals(0, actualDomainParserGrammar.getNumberOfSyntaxErrors());
    assertFalse(actualDomainParserGrammar.isMatchedEOF());
    assertNull(actualDomainParserGrammar.getContext());
    assertTrue(actualDomainParserGrammar.getErrorHandler() instanceof org.antlr.v4.runtime.DefaultErrorStrategy);
    assertEquals(0, actualDomainParserGrammar.getPrecedence());
    assertEquals("List", actualDomainParserGrammar.getSourceName());
    assertFalse(actualDomainParserGrammar.isTrace());
    assertTrue(actualDomainParserGrammar.getBuildParseTree());
    assertEquals(-1, actualDomainParserGrammar.getState());
    assertTrue(actualDomainParserGrammar.getErrorListenerDispatch() instanceof org.antlr.v4.runtime.ProxyErrorListener);
    ParserATNSimulator interpreter = actualDomainParserGrammar.getInterpreter();
    assertSame(actualDomainParserGrammar, interpreter.getParser());
    assertEquals(164, interpreter.decisionToDFA.length);
    assertEquals(PredictionMode.LL, interpreter.getPredictionMode());
    assertSame(actualDomainParserGrammar.getATN(), interpreter.atn);
    PredictionContextCache expectedSharedContextCache = actualDomainParserGrammar._sharedContextCache;
    assertSame(expectedSharedContextCache, interpreter.getSharedContextCache());
  }

  @Test
  public void testContravarianceTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = domainParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1388, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter4() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(
        new ConnectionLexerGrammar(new ANTLRInputStream()));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = domainParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1388, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getStartIndex());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testContravarianceTypeParameter5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = domainParserGrammar
        .contravarianceTypeParameter();

    // Assert
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertEquals(1, actualContravarianceTypeParameterResult.children.size());
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token token = actualContravarianceTypeParameterResult.stop;
    assertSame(token, actualContravarianceTypeParameterResult.getStart());
    Token stop = actualContravarianceTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualContravarianceTypeParameterResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualContravarianceTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testContravarianceTypeParameter7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ContravarianceTypeParameterContext actualContravarianceTypeParameterResult = domainParserGrammar
        .contravarianceTypeParameter();

    // Assert
    RecognitionException recognitionException = actualContravarianceTypeParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualContravarianceTypeParameterResult.invokingState);
    assertNull(actualContravarianceTypeParameterResult.getParent());
    Token expectedStart = actualContravarianceTypeParameterResult.start;
    Token start = actualContravarianceTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParameterResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1388, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualContravarianceTypeParameterResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testContravarianceTypeParameterContextAccept() {
    // Arrange
    DomainParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new DomainParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextAccept2() {
    // Arrange
    DomainParserGrammar.ContravarianceTypeParameterContext contravarianceTypeParameterContext = new DomainParserGrammar.ContravarianceTypeParameterContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(126,
        (new DomainParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testContravarianceTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testContravarianceTypeParameterContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ContravarianceTypeParameterContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testContravarianceTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1390, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualContravarianceTypeParametersResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testContravarianceTypeParameters3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1390, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualContravarianceTypeParametersResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testContravarianceTypeParameters4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [1379])", actualContravarianceTypeParametersResult.toStringTree());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertTrue(((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1379, ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testContravarianceTypeParameters5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1390, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualContravarianceTypeParametersResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testContravarianceTypeParameters6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(72));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = domainParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.stop;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.ContravarianceTypeParameterContext) getResult)
        .identifier();
    assertEquals(1390, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualContravarianceTypeParametersResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testContravarianceTypeParameters7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ContravarianceTypeParametersContext actualContravarianceTypeParametersResult = domainParserGrammar
        .contravarianceTypeParameters();

    // Assert
    assertEquals(-1, actualContravarianceTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualContravarianceTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualContravarianceTypeParametersResult.getParent());
    Token expectedStart = actualContravarianceTypeParametersResult.start;
    Token start = actualContravarianceTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualContravarianceTypeParametersResult.getStop());
    assertEquals(1, actualContravarianceTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ContravarianceTypeParameterContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testContravarianceTypeParametersContextAccept() {
    // Arrange
    DomainParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new DomainParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.ContravarianceTypeParametersContext contravarianceTypeParametersContext = new DomainParserGrammar.ContravarianceTypeParametersContext(
        new ParserRuleContext(), 1);
    contravarianceTypeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(contravarianceTypeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testContravarianceTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testContravarianceTypeParametersContextContravarianceTypeParameter() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
        .contravarianceTypeParameter()
        .isEmpty());
    assertNull((new DomainParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1))
        .contravarianceTypeParameter(1));
  }

  @Test
  public void testContravarianceTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(125,
        (new DomainParserGrammar.ContravarianceTypeParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDefaultValue() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DefaultValueContext actualDefaultValueResult = domainParserGrammar.defaultValue();

    // Assert
    RecognitionException recognitionException = actualDefaultValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDefaultValueResult.invokingState);
    assertNull(actualDefaultValueResult.getParent());
    Token expectedStart = actualDefaultValueResult.start;
    Token start = actualDefaultValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDefaultValueResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(393, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDefaultValueResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDefaultValue2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.DefaultValueContext actualDefaultValueResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).defaultValue();

    // Assert
    assertEquals(-1, actualDefaultValueResult.invokingState);
    List<ParseTree> parseTreeList = actualDefaultValueResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefaultValueResult.getParent());
    Token token = actualDefaultValueResult.stop;
    Token start = actualDefaultValueResult.getStart();
    assertSame(token, start);
    assertSame(token, actualDefaultValueResult.getStop());
    assertEquals(2, actualDefaultValueResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.DefaultValueExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '='>", getResult1.toString());
    assertEquals("([394] ([396 394] ([1046 396 394] ([1431 1046 396 394] <EOF>))) [397 394])",
        getResult.toStringTree());
    assertSame(actualDefaultValueResult, getResult1.getParent());
  }

  @Test
  public void testDefaultValueContextAccept() {
    // Arrange
    DomainParserGrammar.DefaultValueContext defaultValueContext = new DomainParserGrammar.DefaultValueContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(defaultValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueContextAccept2() {
    // Arrange
    DomainParserGrammar.DefaultValueContext defaultValueContext = new DomainParserGrammar.DefaultValueContext(
        new ParserRuleContext(), 1);
    defaultValueContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(defaultValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueContextDefaultValueExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefaultValueContext(new ParserRuleContext(), 1)).defaultValueExpression());
  }

  @Test
  public void testDefaultValueContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefaultValueContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testDefaultValueContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(13, (new DomainParserGrammar.DefaultValueContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDefaultValueExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DefaultValueExpressionContext actualDefaultValueExpressionResult = domainParserGrammar
        .defaultValueExpression();

    // Assert
    RecognitionException recognitionException = actualDefaultValueExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDefaultValueExpressionResult.invokingState);
    assertNull(actualDefaultValueExpressionResult.getParent());
    Token expectedStart = actualDefaultValueExpressionResult.start;
    Token start = actualDefaultValueExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDefaultValueExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(402, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDefaultValueExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDefaultValueExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.DefaultValueExpressionContext actualDefaultValueExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).defaultValueExpression();

    // Assert
    assertEquals(-1, actualDefaultValueExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefaultValueExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefaultValueExpressionResult.getParent());
    Token expectedStart = actualDefaultValueExpressionResult.stop;
    Token start = actualDefaultValueExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDefaultValueExpressionResult.getStop());
    assertEquals(2, actualDefaultValueExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(2, ((DomainParserGrammar.PropertyExpressionContext) parseTreeList.get(1)).depth());
    assertFalse(((DomainParserGrammar.PropertyExpressionContext) parseTreeList.get(1)).isEmpty());
    assertSame(start, ((DomainParserGrammar.PropertyExpressionContext) parseTreeList.get(1)).getStop());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(396, ((DomainParserGrammar.InstanceReferenceContext) getResult).invokingState);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceReferenceContext) getResult).depth());
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertTrue(((DomainParserGrammar.PropertyExpressionContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(
        ((DomainParserGrammar.PropertyExpressionContext) parseTreeList.get(1)).getStart() instanceof CommonToken);
  }

  @Test
  public void testDefaultValueExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.DefaultValueExpressionContext actualDefaultValueExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).defaultValueExpression();

    // Assert
    assertEquals(-1, actualDefaultValueExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefaultValueExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefaultValueExpressionResult.getParent());
    Token expectedStart = actualDefaultValueExpressionResult.start;
    Token start = actualDefaultValueExpressionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefaultValueExpressionResult.stop;
    Token stop = actualDefaultValueExpressionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualDefaultValueExpressionResult.getText());
    assertEquals(2, actualDefaultValueExpressionResult.getChildCount());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(396, ((DomainParserGrammar.InstanceReferenceContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(1);
    assertSame(stop, ((DomainParserGrammar.PropertyExpressionContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    assertEquals(397, ((DomainParserGrammar.PropertyExpressionContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.PropertyExpressionContext) getResult).depth());
  }

  @Test
  public void testDefaultValueExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.DefaultValueExpressionContext defaultValueExpressionContext = new DomainParserGrammar.DefaultValueExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(defaultValueExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.DefaultValueExpressionContext defaultValueExpressionContext = new DomainParserGrammar.DefaultValueExpressionContext(
        new ParserRuleContext(), 1);
    defaultValueExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(defaultValueExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueExpressionContextDefaultValueExpressionsArray() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1))
        .defaultValueExpressionsArray());
  }

  @Test
  public void testDefaultValueExpressionContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1)).expressionInstance());
  }

  @Test
  public void testDefaultValueExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(14,
        (new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDefaultValueExpressionContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1)).instanceLiteralToken());
  }

  @Test
  public void testDefaultValueExpressionContextInstanceReference() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1)).instanceReference());
  }

  @Test
  public void testDefaultValueExpressionContextPropertyExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.DefaultValueExpressionContext(new ParserRuleContext(), 1)).propertyExpression());
  }

  @Test
  public void testDefaultValueExpressionsArray() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DefaultValueExpressionsArrayContext actualDefaultValueExpressionsArrayResult = domainParserGrammar
        .defaultValueExpressionsArray();

    // Assert
    RecognitionException recognitionException = actualDefaultValueExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDefaultValueExpressionsArrayResult.invokingState);
    assertNull(actualDefaultValueExpressionsArrayResult.getParent());
    Token expectedStart = actualDefaultValueExpressionsArrayResult.start;
    Token start = actualDefaultValueExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDefaultValueExpressionsArrayResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(404, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDefaultValueExpressionsArrayResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDefaultValueExpressionsArray2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.DefaultValueExpressionsArrayContext actualDefaultValueExpressionsArrayResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).defaultValueExpressionsArray();

    // Assert
    assertEquals(-1, actualDefaultValueExpressionsArrayResult.invokingState);
    List<ParseTree> parseTreeList = actualDefaultValueExpressionsArrayResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '['> ([405] ([396 405] ([1046 396 405] ([1431 1046 396 405] <EOF>))) [397 405]) <missing"
        + " ']'>)", actualDefaultValueExpressionsArrayResult.toStringTree());
    assertNull(actualDefaultValueExpressionsArrayResult.getParent());
    Token token = actualDefaultValueExpressionsArrayResult.stop;
    Token start = actualDefaultValueExpressionsArrayResult.getStart();
    assertSame(token, start);
    assertSame(token, actualDefaultValueExpressionsArrayResult.getStop());
    assertEquals("<missing '['><EOF><missing ']'>", actualDefaultValueExpressionsArrayResult.getText());
    assertEquals(3, actualDefaultValueExpressionsArrayResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing ']'>", getResult1.getText());
    assertEquals("<missing ']'>", getResult1.toString());
    assertSame(actualDefaultValueExpressionsArrayResult, getResult1.getParent());
    assertSame(start, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).getStart());
    assertEquals(405, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.DefaultValueExpressionContext) getResult).depth());
  }

  @Test
  public void testDefaultValueExpressionsArrayContextAccept() {
    // Arrange
    DomainParserGrammar.DefaultValueExpressionsArrayContext defaultValueExpressionsArrayContext = new DomainParserGrammar.DefaultValueExpressionsArrayContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(defaultValueExpressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueExpressionsArrayContextAccept2() {
    // Arrange
    DomainParserGrammar.DefaultValueExpressionsArrayContext defaultValueExpressionsArrayContext = new DomainParserGrammar.DefaultValueExpressionsArrayContext(
        new ParserRuleContext(), 1);
    defaultValueExpressionsArrayContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(defaultValueExpressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefaultValueExpressionsArrayContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testDefaultValueExpressionsArrayContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testDefaultValueExpressionsArrayContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testDefaultValueExpressionsArrayContextDefaultValueExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1))
        .defaultValueExpression()
        .isEmpty());
    assertNull((new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1))
        .defaultValueExpression(1));
  }

  @Test
  public void testDefaultValueExpressionsArrayContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(15,
        (new DomainParserGrammar.DefaultValueExpressionsArrayContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token token = actualDefinitionResult.stop;
    Token start = actualDefinitionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualDefinitionResult.getStop());
    assertEquals(2, actualDefinitionResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertNull(((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).getStop());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(1, tokenSource.getLine());
    assertSame(actualDefinitionResult, getResult.getParent());
    assertSame(start, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).getStart());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).depth());
  }

  @Test
  public void testDefinition10() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(3));
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(2, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinition11() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(0));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnullEOF", actualDefinitionResult.getText());
    assertEquals(2, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(2, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertSame(actualDefinitionResult, getResult.getParent());
  }

  @Test
  public void testDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(2, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertSame(actualDefinitionResult, getResult.getParent());
  }

  @Test
  public void testDefinition3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnullEOF", actualDefinitionResult.getText());
    assertEquals(2, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getLine());
    assertEquals(2, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.toString());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertSame(actualDefinitionResult, getResult.getParent());
  }

  @Test
  public void testDefinition4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(2));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinition5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(4));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinition6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(6));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinition7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(3));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(1, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinition8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = domainParserGrammar.definition();

    // Assert
    RecognitionException recognitionException = actualDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertTrue(actualDefinitionResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(274, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualDefinitionResult, recognitionException.getCtx());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testDefinition9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(2));
    tokenList.add(new CommonToken(1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);

    // Act
    DomainParserGrammar.DefinitionContext actualDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).definition();

    // Assert
    assertEquals(-1, actualDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualDefinitionResult.getParent());
    Token expectedStart = actualDefinitionResult.start;
    Token start = actualDefinitionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualDefinitionResult.stop;
    Token stop = actualDefinitionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnullEOF", actualDefinitionResult.getText());
    assertEquals(3, actualDefinitionResult.getChildCount());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(1, stop.getStartIndex());
    assertEquals(0, stop.getStopIndex());
    TokenSource tokenSource = stop.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, stop.getChannel());
    assertEquals(-1, stop.getType());
    assertEquals(0, stop.getLine());
    assertEquals(0, start.getTokenIndex());
    assertNull(stop.getInputStream());
    assertEquals(2, stop.getTokenIndex());
    assertEquals("EOF", stop.getText());
    assertEquals(270, ((DomainParserGrammar.ImportsContext) parseTreeList.get(0)).invokingState);
    assertEquals(0, tokenSource.getLine());
    assertEquals(271, ((DomainParserGrammar.ElementDefinitionContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertSame(actualDefinitionResult, getResult.getParent());
    assertEquals("<EOF>", getResult.toString());
  }

  @Test
  public void testDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.DefinitionContext definitionContext = new DomainParserGrammar.DefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(definitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.DefinitionContext definitionContext = new DomainParserGrammar.DefinitionContext(
        new ParserRuleContext(), 1);
    definitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(definitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDefinitionContextEOF() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).EOF());
  }

  @Test
  public void testDefinitionContextElementDefinition() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).elementDefinition().isEmpty());
    assertNull((new DomainParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).elementDefinition(1));
  }

  @Test
  public void testDefinitionContextImports() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DefinitionContext(new ParserRuleContext(), 1)).imports());
  }

  @Test
  public void testDerivedProperty() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DerivedPropertyContext actualDerivedPropertyResult = domainParserGrammar.derivedProperty();

    // Assert
    RecognitionException recognitionException = actualDerivedPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDerivedPropertyResult.invokingState);
    assertEquals(1, actualDerivedPropertyResult.depth());
    Token expectedStart = actualDerivedPropertyResult.start;
    Token start = actualDerivedPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDerivedPropertyResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualDerivedPropertyResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(761, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testDerivedProperty2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DerivedPropertyContext actualDerivedPropertyResult = domainParserGrammar.derivedProperty();

    // Assert
    assertNull(actualDerivedPropertyResult.stereotypes());
    RecognitionException recognitionException = actualDerivedPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualDerivedPropertyResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualDerivedPropertyResult.depth());
    assertEquals(-1, actualDerivedPropertyResult.invokingState);
    Token expectedStart = actualDerivedPropertyResult.stop;
    Token start = actualDerivedPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDerivedPropertyResult.getStop());
    assertEquals("<missing '>'><EOF>", actualDerivedPropertyResult.getText());
    assertEquals("([] <missing '>'> ([762] ([778 762] <EOF>)))", actualDerivedPropertyResult.toStringTree());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(parseTreeList.get(1), recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(793, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(762, ((DomainParserGrammar.PropertyRefContext) parseTreeList.get(1)).invokingState);
    String expectedSourceName = String.join("", "<", System.getProperty("sun.os.patch.level"), ">");
    assertEquals(expectedSourceName, inputStream.getSourceName());
    assertEquals("<EOF>", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testDerivedPropertyContextAccept() {
    // Arrange
    DomainParserGrammar.DerivedPropertyContext derivedPropertyContext = new DomainParserGrammar.DerivedPropertyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(derivedPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDerivedPropertyContextAccept2() {
    // Arrange
    DomainParserGrammar.DerivedPropertyContext derivedPropertyContext = new DomainParserGrammar.DerivedPropertyContext(
        new ParserRuleContext(), 1);
    derivedPropertyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(derivedPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDerivedPropertyContextAlias() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).alias());
  }

  @Test
  public void testDerivedPropertyContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testDerivedPropertyContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testDerivedPropertyContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testDerivedPropertyContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testDerivedPropertyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(55, (new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDerivedPropertyContextPropertyRef() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).propertyRef());
  }

  @Test
  public void testDerivedPropertyContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testDerivedPropertyContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testDerivedPropertyContextTreePathClassBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DerivedPropertyContext(new ParserRuleContext(), 1)).treePathClassBody());
  }

  @Test
  public void testDsl() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslContext actualDslResult = domainParserGrammar.dsl();

    // Assert
    RecognitionException recognitionException = actualDslResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualDslResult.invokingState);
    assertNull(actualDslResult.getParent());
    Token expectedStart = actualDslResult.start;
    Token start = actualDslResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1294, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testDslContent() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.DslContentContext actualDslContentResult = domainParserGrammar.dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testDslContent2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslContentContext actualDslContentResult = domainParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("null", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1305, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslContent3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslContentContext actualDslContentResult = domainParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1305, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.DslContentContext actualDslContentResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testDslContent5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslContentContext actualDslContentResult = domainParserGrammar.dslContent();

    // Assert
    RecognitionException recognitionException = actualDslContentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslContentResult.children.size());
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.stop;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslContentResult.getStop());
    assertEquals("Input", actualDslContentResult.getText());
    assertEquals(1, actualDslContentResult.getChildCount());
    assertTrue(actualDslContentResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1305, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslContentResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslContent6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslContentContext actualDslContentResult = domainParserGrammar.dslContent();

    // Assert
    assertEquals(-1, actualDslContentResult.invokingState);
    assertNull(actualDslContentResult.getParent());
    Token expectedStart = actualDslContentResult.start;
    Token start = actualDslContentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslContentResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testDslContentContextAccept() {
    // Arrange
    DomainParserGrammar.DslContentContext dslContentContext = new DomainParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextAccept2() {
    // Arrange
    DomainParserGrammar.DslContentContext dslContentContext = new DomainParserGrammar.DslContentContext(
        new ParserRuleContext(), 1);
    dslContentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(115, (new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_CLOSE());
  }

  @Test
  public void testDslContentContextISLAND_BRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_BRACE_OPEN());
  }

  @Test
  public void testDslContentContextISLAND_CONTENT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_CONTENT());
  }

  @Test
  public void testDslContentContextISLAND_END() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_END());
  }

  @Test
  public void testDslContentContextISLAND_HASH() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_HASH());
  }

  @Test
  public void testDslContentContextISLAND_START() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContentContext(new ParserRuleContext(), 1)).ISLAND_START());
  }

  @Test
  public void testDslContextAccept() {
    // Arrange
    DomainParserGrammar.DslContext dslContext = new DomainParserGrammar.DslContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextAccept2() {
    // Arrange
    DomainParserGrammar.DslContext dslContext = new DomainParserGrammar.DslContext(new ParserRuleContext(), 1);
    dslContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslContextDslGraphFetch() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContext(new ParserRuleContext(), 1)).dslGraphFetch());
  }

  @Test
  public void testDslContextDslNavigationPath() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslContext(new ParserRuleContext(), 1)).dslNavigationPath());
  }

  @Test
  public void testDslContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(112, (new DomainParserGrammar.DslContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetch() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<32>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(32, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetch2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = domainParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("null", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1298, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslGraphFetch3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = domainParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1298, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals("<missing ISLAND_OPEN>", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslGraphFetch5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = domainParserGrammar.dslGraphFetch();

    // Assert
    RecognitionException recognitionException = actualDslGraphFetchResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslGraphFetchResult.children.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.stop;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslGraphFetchResult.getStop());
    assertEquals("Input", actualDslGraphFetchResult.getText());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertTrue(actualDslGraphFetchResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1298, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslGraphFetchResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslGraphFetch6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslGraphFetchContext actualDslGraphFetchResult = domainParserGrammar.dslGraphFetch();

    // Assert
    assertEquals(-1, actualDslGraphFetchResult.invokingState);
    List<ParseTree> parseTreeList = actualDslGraphFetchResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslGraphFetchResult.getParent());
    Token expectedStart = actualDslGraphFetchResult.start;
    Token start = actualDslGraphFetchResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslGraphFetchResult.getStop());
    assertEquals(1, actualDslGraphFetchResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslGraphFetchResult, getResult.getParent());
    assertEquals("<missing ISLAND_OPEN>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing ISLAND_OPEN>',<32>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(32, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing ISLAND_OPEN>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslGraphFetchContextAccept() {
    // Arrange
    DomainParserGrammar.DslGraphFetchContext dslGraphFetchContext = new DomainParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextAccept2() {
    // Arrange
    DomainParserGrammar.DslGraphFetchContext dslGraphFetchContext = new DomainParserGrammar.DslGraphFetchContext(
        new ParserRuleContext(), 1);
    dslGraphFetchContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslGraphFetchContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslGraphFetchContextDslContent() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent().isEmpty());
    assertNull((new DomainParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).dslContent(1));
  }

  @Test
  public void testDslGraphFetchContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(114, (new DomainParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslGraphFetchContextISLAND_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslGraphFetchContext(new ParserRuleContext(), 1)).ISLAND_OPEN());
  }

  @Test
  public void testDslNavigationPath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<28>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(28, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = domainParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("null", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1296, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testDslNavigationPath3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = domainParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1296, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testDslNavigationPath5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = domainParserGrammar
        .dslNavigationPath();

    // Assert
    RecognitionException recognitionException = actualDslNavigationPathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualDslNavigationPathResult.children.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.stop;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualDslNavigationPathResult.getStop());
    assertEquals("Input", actualDslNavigationPathResult.getText());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertTrue(actualDslNavigationPathResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1296, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualDslNavigationPathResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testDslNavigationPath6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.DslNavigationPathContext actualDslNavigationPathResult = domainParserGrammar
        .dslNavigationPath();

    // Assert
    assertEquals(-1, actualDslNavigationPathResult.invokingState);
    List<ParseTree> parseTreeList = actualDslNavigationPathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualDslNavigationPathResult.getParent());
    Token expectedStart = actualDslNavigationPathResult.start;
    Token start = actualDslNavigationPathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualDslNavigationPathResult.getStop());
    assertEquals(1, actualDslNavigationPathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualDslNavigationPathResult, getResult.getParent());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing NAVIGATION_PATH_BLOCK>',<28>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(28, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing NAVIGATION_PATH_BLOCK>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testDslNavigationPathContextAccept() {
    // Arrange
    DomainParserGrammar.DslNavigationPathContext dslNavigationPathContext = new DomainParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextAccept2() {
    // Arrange
    DomainParserGrammar.DslNavigationPathContext dslNavigationPathContext = new DomainParserGrammar.DslNavigationPathContext(
        new ParserRuleContext(), 1);
    dslNavigationPathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(dslNavigationPathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testDslNavigationPathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(113, (new DomainParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testDslNavigationPathContextNAVIGATION_PATH_BLOCK() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.DslNavigationPathContext(new ParserRuleContext(), 1)).NAVIGATION_PATH_BLOCK());
  }

  @Test
  public void testElementDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ElementDefinitionContext actualElementDefinitionResult = domainParserGrammar
        .elementDefinition();

    // Assert
    RecognitionException recognitionException = actualElementDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualElementDefinitionResult.invokingState);
    assertEquals(1, actualElementDefinitionResult.depth());
    Token expectedStart = actualElementDefinitionResult.start;
    Token start = actualElementDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualElementDefinitionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualElementDefinitionResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, start.getLine());
    assertEquals(299, recognitionException.getOffendingState());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testElementDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ElementDefinitionContext actualElementDefinitionResult = domainParserGrammar
        .elementDefinition();

    // Assert
    RecognitionException recognitionException = actualElementDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualElementDefinitionResult.children.size());
    assertNull(actualElementDefinitionResult.instance());
    assertTrue(actualElementDefinitionResult.isEmpty());
    assertEquals(1, actualElementDefinitionResult.depth());
    Token expectedStart = actualElementDefinitionResult.stop;
    Token start = actualElementDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals("null", actualElementDefinitionResult.getText());
    assertSame(start, actualElementDefinitionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(299, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualElementDefinitionResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
  }

  @Test
  public void testElementDefinition3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(4));

    // Act
    DomainParserGrammar.ElementDefinitionContext actualElementDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).elementDefinition();

    // Assert
    assertEquals(-1, actualElementDefinitionResult.invokingState);
    assertEquals(1, actualElementDefinitionResult.children.size());
    assertNull(actualElementDefinitionResult.instance());
    assertNull(actualElementDefinitionResult.getParent());
    Token expectedStart = actualElementDefinitionResult.stop;
    Token start = actualElementDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualElementDefinitionResult.getStop());
    DomainParserGrammar.ProfileContext profileResult = actualElementDefinitionResult.profile();
    assertEquals("null", profileResult.getText());
    assertSame(start, profileResult.getStart());
    assertEquals(2, profileResult.depth());
    assertFalse(profileResult.isEmpty());
    assertSame(start, profileResult.getStop());
    assertEquals(2, profileResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    List<ParseTree> parseTreeList = profileResult.children;
    assertEquals(2, parseTreeList.size());
    RecognitionException recognitionException = profileResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(443, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(profileResult, recognitionException.getCtx());
    assertEquals(442, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testElementDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.ElementDefinitionContext elementDefinitionContext = new DomainParserGrammar.ElementDefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(elementDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testElementDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.ElementDefinitionContext elementDefinitionContext = new DomainParserGrammar.ElementDefinitionContext(
        new ParserRuleContext(), 1);
    elementDefinitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(elementDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testElementDefinitionContextAssociation() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).association());
  }

  @Test
  public void testElementDefinitionContextClassDefinition() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).classDefinition());
  }

  @Test
  public void testElementDefinitionContextEnumDefinition() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).enumDefinition());
  }

  @Test
  public void testElementDefinitionContextFunctionDefinition() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).functionDefinition());
  }

  @Test
  public void testElementDefinitionContextInstance() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).instance());
  }

  @Test
  public void testElementDefinitionContextMeasureDefinition() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).measureDefinition());
  }

  @Test
  public void testElementDefinitionContextNativeFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).nativeFunction());
  }

  @Test
  public void testElementDefinitionContextProfile() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ElementDefinitionContext(new ParserRuleContext(), 1)).profile());
  }

  @Test
  public void testEnumDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumDefinitionContext actualEnumDefinitionResult = domainParserGrammar.enumDefinition();

    // Assert
    RecognitionException recognitionException = actualEnumDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEnumDefinitionResult.invokingState);
    assertEquals(1, actualEnumDefinitionResult.depth());
    Token expectedStart = actualEnumDefinitionResult.start;
    Token start = actualEnumDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumDefinitionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(518, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualEnumDefinitionResult, recognitionException.getCtx());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testEnumDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumDefinitionContext actualEnumDefinitionResult = domainParserGrammar.enumDefinition();

    // Assert
    assertNull(actualEnumDefinitionResult.stereotypes());
    RecognitionException recognitionException = actualEnumDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualEnumDefinitionResult.depth());
    Token expectedStart = actualEnumDefinitionResult.stop;
    Token start = actualEnumDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumDefinitionResult.getStop());
    assertEquals("<missing 'Enum'><EOF>", actualEnumDefinitionResult.getText());
    assertTrue(actualEnumDefinitionResult.isEmpty());
    assertEquals("([] <missing 'Enum'> ([525] ([1431 525] <EOF>)))", actualEnumDefinitionResult.toStringTree());
    assertSame(actualEnumDefinitionResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(526, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(525, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("<missing 'Enum'>", getResult.toString());
    assertSame(actualEnumDefinitionResult, getResult.getParent());
  }

  @Test
  public void testEnumDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.EnumDefinitionContext enumDefinitionContext = new DomainParserGrammar.EnumDefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(enumDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.EnumDefinitionContext enumDefinitionContext = new DomainParserGrammar.EnumDefinitionContext(
        new ParserRuleContext(), 1);
    enumDefinitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(enumDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumDefinitionContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testEnumDefinitionContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testEnumDefinitionContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testEnumDefinitionContextENUM() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).ENUM());
  }

  @Test
  public void testEnumDefinitionContextEnumValue() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).enumValue().isEmpty());
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).enumValue(1));
  }

  @Test
  public void testEnumDefinitionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(26, (new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEnumDefinitionContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testEnumDefinitionContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testEnumDefinitionContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumDefinitionContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testEnumReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumReferenceContext actualEnumReferenceResult = domainParserGrammar.enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumReferenceResult.getStop());
    assertEquals(1, actualEnumReferenceResult.getChildCount());
    assertTrue(actualEnumReferenceResult.isEmpty());
    assertEquals("([] [910])", actualEnumReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(911, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(910, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testEnumReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumReferenceContext actualEnumReferenceResult = domainParserGrammar.enumReference();

    // Assert
    RecognitionException recognitionException = actualEnumReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.stop;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumReferenceResult.getStop());
    assertEquals("null", actualEnumReferenceResult.getText());
    assertEquals(1, actualEnumReferenceResult.getChildCount());
    assertTrue(actualEnumReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(911, recognitionException.getOffendingState());
    assertSame(actualEnumReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(910, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.EnumReferenceContext actualEnumReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).enumReference();

    // Assert
    assertEquals(-1, actualEnumReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualEnumReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualEnumReferenceResult.getParent());
    Token expectedStart = actualEnumReferenceResult.start;
    Token start = actualEnumReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualEnumReferenceResult.stop;
    Token stop = actualEnumReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualEnumReferenceResult.getText());
    assertEquals(3, actualEnumReferenceResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumReferenceResult.identifier();
    assertEquals(912, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(910, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testEnumReferenceContextAccept() {
    // Arrange
    DomainParserGrammar.EnumReferenceContext enumReferenceContext = new DomainParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextAccept2() {
    // Arrange
    DomainParserGrammar.EnumReferenceContext enumReferenceContext = new DomainParserGrammar.EnumReferenceContext(
        new ParserRuleContext(), 1);
    enumReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(enumReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumReferenceContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testEnumReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(67, (new DomainParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEnumReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testEnumReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testEnumValue() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    RecognitionException recognitionException = actualEnumValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.start;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumValueResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualEnumValueResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(540, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testEnumValue2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).enumValue();

    // Assert
    assertNull(actualEnumValueResult.stereotypes());
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.children.size());
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.stop;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumValueResult.getStop());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumValueResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testEnumValue3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(74));

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).enumValue();

    // Assert
    assertNull(actualEnumValueResult.stereotypes());
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.children.size());
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.stop;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumValueResult.getStop());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumValueResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testEnumValue4() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(
        new ConnectionLexerGrammar(new ANTLRInputStream()));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    RecognitionException recognitionException = actualEnumValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.start;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumValueResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualEnumValueResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(540, recognitionException.getOffendingState());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getLine());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testEnumValue5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(74));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    RecognitionException recognitionException = actualEnumValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.start;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumValueResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualEnumValueResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(540, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testEnumValue6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(74));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).enumValue();

    // Assert
    assertNull(actualEnumValueResult.stereotypes());
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.children.size());
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.stop;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumValueResult.getStop());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumValueResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testEnumValue7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(74));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.enterRule(new ParserRuleContext(), 0, 1);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    assertNull(actualEnumValueResult.stereotypes());
    assertEquals(0, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.children.size());
    assertEquals(2, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.stop;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumValueResult.getStop());
    assertEquals(1, actualEnumValueResult.getParent().getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumValueResult.identifier();
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(3, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testEnumValue8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(74));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    assertNull(actualEnumValueResult.stereotypes());
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.children.size());
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.stop;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEnumValueResult.getStop());
    DomainParserGrammar.IdentifierContext identifierResult = actualEnumValueResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testEnumValue9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.EnumValueContext actualEnumValueResult = domainParserGrammar.enumValue();

    // Assert
    RecognitionException recognitionException = actualEnumValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEnumValueResult.invokingState);
    assertEquals(1, actualEnumValueResult.depth());
    Token expectedStart = actualEnumValueResult.start;
    Token start = actualEnumValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEnumValueResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualEnumValueResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(540, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testEnumValueContextAccept() {
    // Arrange
    DomainParserGrammar.EnumValueContext enumValueContext = new DomainParserGrammar.EnumValueContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(enumValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumValueContextAccept2() {
    // Arrange
    DomainParserGrammar.EnumValueContext enumValueContext = new DomainParserGrammar.EnumValueContext(
        new ParserRuleContext(), 1);
    enumValueContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(enumValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEnumValueContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(27, (new DomainParserGrammar.EnumValueContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEnumValueContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumValueContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testEnumValueContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumValueContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testEnumValueContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EnumValueContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testEqualNotEqual() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = domainParserGrammar.equalNotEqual();

    // Assert
    RecognitionException recognitionException = actualEqualNotEqualResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.start;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualEqualNotEqualResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(941, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualEqualNotEqualResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testEqualNotEqual2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.EqualNotEqualContext actualEqualNotEqualResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).equalNotEqual();

    // Assert
    assertEquals(-1, actualEqualNotEqualResult.invokingState);
    List<ParseTree> parseTreeList = actualEqualNotEqualResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualEqualNotEqualResult.getParent());
    Token expectedStart = actualEqualNotEqualResult.stop;
    Token start = actualEqualNotEqualResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualEqualNotEqualResult.getStop());
    assertEquals(1, actualEqualNotEqualResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.CombinedArithmeticOnlyContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedArithmeticOnlyContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedArithmeticOnlyContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedArithmeticOnlyContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([942] ([944 942] ([967 944 942] ([800 967 944 942] ([1039 800 967 944 942] ([1046 1039 800 967 944"
        + " 942] ([1431 1046 1039 800 967 944 942] <EOF>)))))))", getResult.toStringTree());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testEqualNotEqualContextAccept() {
    // Arrange
    DomainParserGrammar.EqualNotEqualContext equalNotEqualContext = new DomainParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextAccept2() {
    // Arrange
    DomainParserGrammar.EqualNotEqualContext equalNotEqualContext = new DomainParserGrammar.EqualNotEqualContext(
        new ParserRuleContext(), 1);
    equalNotEqualContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(equalNotEqualContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testEqualNotEqualContextCombinedArithmeticOnly() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).combinedArithmeticOnly());
  }

  @Test
  public void testEqualNotEqualContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(73, (new DomainParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testEqualNotEqualContextTEST_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_EQUAL());
  }

  @Test
  public void testEqualNotEqualContextTEST_NOT_EQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.EqualNotEqualContext(new ParserRuleContext(), 1)).TEST_NOT_EQUAL());
  }

  @Test
  public void testExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    assertEquals(-1, actualExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.stop;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionResult.getStop());
    assertEquals(1, actualExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStart());
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).dsl());
    assertEquals(2, ((DomainParserGrammar.AtomicExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.AtomicExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.AtomicExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1039 800]", getResult1.toString());
    assertEquals(1039, ((DomainParserGrammar.InstanceReferenceContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.InstanceReferenceContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testExpression8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpression9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionContext actualExpressionResult = domainParserGrammar.expression();

    // Assert
    RecognitionException recognitionException = actualExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionResult.invokingState);
    assertNull(actualExpressionResult.getParent());
    Token expectedStart = actualExpressionResult.start;
    Token start = actualExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionContext expressionContext = new DomainParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionContext expressionContext = new DomainParserGrammar.ExpressionContext(
        new ParserRuleContext(), 1);
    expressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionContextAtomicExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).atomicExpression());
  }

  @Test
  public void testExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testExpressionContextEqualNotEqual() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).equalNotEqual());
  }

  @Test
  public void testExpressionContextExpressionsArray() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).expressionsArray());
  }

  @Test
  public void testExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(58, (new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionContextNotExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).notExpression());
  }

  @Test
  public void testExpressionContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testExpressionContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionContextPropertyOrFunctionExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).propertyOrFunctionExpression()
        .isEmpty());
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).propertyOrFunctionExpression(1));
  }

  @Test
  public void testExpressionContextSignedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).signedExpression());
  }

  @Test
  public void testExpressionContextSliceExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionContext(new ParserRuleContext(), 1)).sliceExpression());
  }

  @Test
  public void testExpressionInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = domainParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceResult.invokingState);
    assertNull(actualExpressionInstanceResult.getParent());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1110, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testExpressionInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = domainParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.getParent());
    assertEquals(-1, actualExpressionInstanceResult.invokingState);
    Token token = actualExpressionInstanceResult.stop;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionInstanceResult.getStop());
    assertEquals(2, actualExpressionInstanceResult.getChildCount());
    assertEquals("<missing '^'><EOF>", actualExpressionInstanceResult.getText());
    assertEquals("([] <missing '^'> ([1112] ([1431 1112] <EOF>)))", actualExpressionInstanceResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(1124, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualExpressionInstanceResult, getResult.getParent());
    assertEquals(1112, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<missing '^'>", getResult.toStringTree());
    assertEquals("<missing '^'>", getResult.getText());
  }

  @Test
  public void testExpressionInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceContext actualExpressionInstanceResult = domainParserGrammar
        .expressionInstance();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualExpressionInstanceResult.getParent());
    Token expectedStart = actualExpressionInstanceResult.start;
    Token start = actualExpressionInstanceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualExpressionInstanceResult.stop;
    Token stop = actualExpressionInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals(3, actualExpressionInstanceResult.getChildCount());
    assertTrue(actualExpressionInstanceResult.isEmpty());
    assertEquals("<missing '^'><EOF>null", actualExpressionInstanceResult.getText());
    assertEquals(1126, actualExpressionInstanceResult.identifier().invokingState);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualExpressionInstanceResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(1129, recognitionException.getOffendingState());
    assertEquals("[@1,0:0='<no text>',<1>,0:-1]", stop.toString());
    assertEquals(1112, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1147, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.stop;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceAtomicRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualExpressionInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testExpressionInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1147, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext actualExpressionInstanceAtomicRightSideResult = domainParserGrammar
        .expressionInstanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionInstanceAtomicRightSideResult.invokingState);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceAtomicRightSideResult.start;
    Token start = actualExpressionInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceAtomicRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1147, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceAtomicRightSideContext expressionInstanceAtomicRightSideContext = new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .combinedExpression());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextExpressionInstance() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1))
        .expressionInstance());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(98,
        (new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.ExpressionInstanceAtomicRightSideContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceContext expressionInstanceContext = new DomainParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceContext expressionInstanceContext = new DomainParserGrammar.ExpressionInstanceContext(
        new ParserRuleContext(), 1);
    expressionInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionInstanceContextExpressionInstanceParserPropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment()
        .isEmpty());
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1))
        .expressionInstanceParserPropertyAssignment(1));
  }

  @Test
  public void testExpressionInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testExpressionInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(96, (new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testExpressionInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testExpressionInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testExpressionInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testExpressionInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testExpressionInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testExpressionInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testExpressionInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testExpressionInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testExpressionInstanceContextVariable() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceContext(new ParserRuleContext(), 1)).variable());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = domainParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.start;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    assertEquals("([] [1149])", actualExpressionInstanceParserPropertyAssignmentResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1160, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1149, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertTrue(((DomainParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = domainParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(1154, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1149, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext actualExpressionInstanceParserPropertyAssignmentResult = domainParserGrammar
        .expressionInstanceParserPropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualExpressionInstanceParserPropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionInstanceParserPropertyAssignmentResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceParserPropertyAssignmentResult.getParent());
    Token expectedStart = actualExpressionInstanceParserPropertyAssignmentResult.stop;
    Token start = actualExpressionInstanceParserPropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceParserPropertyAssignmentResult.getStop());
    assertEquals("null", actualExpressionInstanceParserPropertyAssignmentResult.getText());
    assertEquals(1, actualExpressionInstanceParserPropertyAssignmentResult.getChildCount());
    assertTrue(actualExpressionInstanceParserPropertyAssignmentResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertEquals(1160, recognitionException.getOffendingState());
    assertSame(actualExpressionInstanceParserPropertyAssignmentResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(1149, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(2, inputStream.size());
    assertTrue(((DomainParserGrammar.IdentifierContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext expressionInstanceParserPropertyAssignmentContext = new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(
        new ParserRuleContext(), 1);
    expressionInstanceParserPropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(
        expressionInstanceParserPropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextDOT() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1)).DOT()
            .isEmpty());
    assertNull(
        (new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1)).DOT(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .EQUAL());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextExpressionInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .expressionInstanceRightSide());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(99,
        (new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .identifier()
        .isEmpty());
    assertNull((new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1))
        .identifier(1));
  }

  @Test
  public void testExpressionInstanceParserPropertyAssignmentContextPLUS() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.ExpressionInstanceParserPropertyAssignmentContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testExpressionInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = domainParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = domainParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = domainParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.stop;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(1144, ((DomainParserGrammar.CombinedExpressionContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStart());
    assertEquals(3, ((DomainParserGrammar.CombinedExpressionContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
  }

  @Test
  public void testExpressionInstanceRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = domainParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.ExpressionInstanceRightSideContext actualExpressionInstanceRightSideResult = domainParserGrammar
        .expressionInstanceRightSide();

    // Assert
    assertEquals(-1, actualExpressionInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualExpressionInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualExpressionInstanceRightSideResult.getParent());
    Token expectedStart = actualExpressionInstanceRightSideResult.start;
    Token start = actualExpressionInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionInstanceRightSideResult.getStop());
    assertEquals(1, actualExpressionInstanceRightSideResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    RecognitionException recognitionException = ((DomainParserGrammar.ExpressionInstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(parseTreeList.get(0), recognitionException.getCtx());
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new DomainParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionInstanceRightSideContext expressionInstanceRightSideContext = new DomainParserGrammar.ExpressionInstanceRightSideContext(
        new ParserRuleContext(), 1);
    expressionInstanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionInstanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionInstanceRightSideContextExpressionInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1))
        .expressionInstanceAtomicRightSide());
  }

  @Test
  public void testExpressionInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(97,
        (new DomainParserGrammar.ExpressionInstanceRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionOrExpressionGroup() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(967, expressionResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertNull(expressionResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getType());
    assertNull(start.getInputStream());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroup10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = domainParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(967, expressionResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertNull(expressionResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource1, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getType());
    assertNull(start.getInputStream());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroup2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(78));

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = domainParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = domainParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = domainParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token token = actualExpressionOrExpressionGroupResult.stop;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(token, start);
    assertSame(token, actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    assertEquals(967, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("[800 967]", getResult.toString());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) getResult).invokingState);
    assertNull(((DomainParserGrammar.AtomicExpressionContext) getResult).variable());
    assertSame(start, ((DomainParserGrammar.AtomicExpressionContext) getResult).getStop());
    Interval expectedSourceInterval = actualExpressionOrExpressionGroupResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
  }

  @Test
  public void testExpressionOrExpressionGroup9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ExpressionOrExpressionGroupContext actualExpressionOrExpressionGroupResult = domainParserGrammar
        .expressionOrExpressionGroup();

    // Assert
    assertEquals(-1, actualExpressionOrExpressionGroupResult.invokingState);
    assertEquals(1, actualExpressionOrExpressionGroupResult.children.size());
    assertNull(actualExpressionOrExpressionGroupResult.getParent());
    Token expectedStart = actualExpressionOrExpressionGroupResult.start;
    Token start = actualExpressionOrExpressionGroupResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionOrExpressionGroupResult.getStop());
    assertEquals(1, actualExpressionOrExpressionGroupResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualExpressionOrExpressionGroupResult.expression();
    RecognitionException recognitionException = expressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(967, expressionResult.invokingState);
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertNull(expressionResult.getStop());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getType());
    assertNull(start.getInputStream());
    assertEquals(819, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(expressionResult, recognitionException.getCtx());
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new DomainParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionOrExpressionGroupContext expressionOrExpressionGroupContext = new DomainParserGrammar.ExpressionOrExpressionGroupContext(
        new ParserRuleContext(), 1);
    expressionOrExpressionGroupContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionOrExpressionGroupContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionOrExpressionGroupContextExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testExpressionOrExpressionGroupContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(78,
        (new DomainParserGrammar.ExpressionOrExpressionGroupContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionPart() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionPartContext actualExpressionPartResult = domainParserGrammar.expressionPart();

    // Assert
    RecognitionException recognitionException = actualExpressionPartResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionPartResult.invokingState);
    assertNull(actualExpressionPartResult.getParent());
    Token expectedStart = actualExpressionPartResult.start;
    Token start = actualExpressionPartResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionPartResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(953, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionPartResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testExpressionPartContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionPartContext expressionPartContext = new DomainParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionPartContext expressionPartContext = new DomainParserGrammar.ExpressionPartContext(
        new ParserRuleContext(), 1);
    expressionPartContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionPartContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionPartContextArithmeticPart() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).arithmeticPart());
  }

  @Test
  public void testExpressionPartContextBooleanPart() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).booleanPart());
  }

  @Test
  public void testExpressionPartContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(75, (new DomainParserGrammar.ExpressionPartContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testExpressionsArray() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = domainParserGrammar.expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualExpressionsArrayResult.invokingState);
    assertNull(actualExpressionsArrayResult.getParent());
    Token expectedStart = actualExpressionsArrayResult.start;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualExpressionsArrayResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(969, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testExpressionsArray2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ExpressionsArrayContext actualExpressionsArrayResult = domainParserGrammar.expressionsArray();

    // Assert
    RecognitionException recognitionException = actualExpressionsArrayResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualExpressionsArrayResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualExpressionsArrayResult.depth());
    Token expectedStart = actualExpressionsArrayResult.stop;
    Token start = actualExpressionsArrayResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(2, actualExpressionsArrayResult.getChildCount());
    assertSame(start, actualExpressionsArrayResult.getStop());
    assertEquals("<missing '['><EOF>", actualExpressionsArrayResult.getText());
    assertTrue(actualExpressionsArrayResult.isEmpty());
    assertEquals("([] <missing '['> ([970] ([800 970] ([1039 800 970] ([1046 1039 800 970] ([1431 1046 1039 800 970]"
        + " <EOF>))))))", actualExpressionsArrayResult.toStringTree());
    assertSame(actualExpressionsArrayResult, recognitionException.getCtx());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(975, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, offendingToken.getType());
    assertEquals(970, ((DomainParserGrammar.ExpressionContext) parseTreeList.get(1)).invokingState);
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(0, offendingToken.getChannel());
  }

  @Test
  public void testExpressionsArrayContextAccept() {
    // Arrange
    DomainParserGrammar.ExpressionsArrayContext expressionsArrayContext = new DomainParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextAccept2() {
    // Arrange
    DomainParserGrammar.ExpressionsArrayContext expressionsArrayContext = new DomainParserGrammar.ExpressionsArrayContext(
        new ParserRuleContext(), 1);
    expressionsArrayContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(expressionsArrayContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testExpressionsArrayContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testExpressionsArrayContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testExpressionsArrayContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testExpressionsArrayContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testExpressionsArrayContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(79, (new DomainParserGrammar.ExpressionsArrayContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<37>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(37, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = domainParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("null", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1342, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFromMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = domainParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1342, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals("<missing INTEGER>", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
  }

  @Test
  public void testFromMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = domainParserGrammar.fromMultiplicity();

    // Assert
    RecognitionException recognitionException = actualFromMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFromMultiplicityResult.children.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.stop;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFromMultiplicityResult.getStop());
    assertEquals("Input", actualFromMultiplicityResult.getText());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertTrue(actualFromMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1342, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualFromMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testFromMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.FromMultiplicityContext actualFromMultiplicityResult = domainParserGrammar.fromMultiplicity();

    // Assert
    assertEquals(-1, actualFromMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualFromMultiplicityResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualFromMultiplicityResult.getParent());
    Token expectedStart = actualFromMultiplicityResult.start;
    Token start = actualFromMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFromMultiplicityResult.getStop());
    assertEquals(1, actualFromMultiplicityResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFromMultiplicityResult, getResult.getParent());
    assertEquals("<missing INTEGER>", getResult.getText());
    assertEquals(1, tokenSource.getLine());
    Object payload = getResult.getPayload();
    assertEquals("[@-1,-1:-1='<missing INTEGER>',<37>,1:0]", payload.toString());
    assertNull(((CommonToken) payload).getInputStream());
    assertEquals(0, ((CommonToken) payload).getCharPositionInLine());
    assertEquals(37, ((CommonToken) payload).getType());
    assertEquals(0, ((CommonToken) payload).getChannel());
    assertEquals(-1, ((CommonToken) payload).getStopIndex());
    assertEquals("<missing INTEGER>", ((CommonToken) payload).getText());
    assertEquals(-1, ((CommonToken) payload).getStartIndex());
    assertSame(tokenSource, ((CommonToken) payload).getTokenSource());
  }

  @Test
  public void testFromMultiplicityContextAccept() {
    // Arrange
    DomainParserGrammar.FromMultiplicityContext fromMultiplicityContext = new DomainParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextAccept2() {
    // Arrange
    DomainParserGrammar.FromMultiplicityContext fromMultiplicityContext = new DomainParserGrammar.FromMultiplicityContext(
        new ParserRuleContext(), 1);
    fromMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(fromMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFromMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(118, (new DomainParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFromMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FromMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testFunctionDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionDefinitionContext actualFunctionDefinitionResult = domainParserGrammar
        .functionDefinition();

    // Assert
    RecognitionException recognitionException = actualFunctionDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionDefinitionResult.invokingState);
    assertEquals(1, actualFunctionDefinitionResult.depth());
    Token expectedStart = actualFunctionDefinitionResult.start;
    Token start = actualFunctionDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionDefinitionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualFunctionDefinitionResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(613, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testFunctionDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionDefinitionContext actualFunctionDefinitionResult = domainParserGrammar
        .functionDefinition();

    // Assert
    assertNull(actualFunctionDefinitionResult.stereotypes());
    RecognitionException recognitionException = actualFunctionDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualFunctionDefinitionResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualFunctionDefinitionResult.depth());
    assertEquals(-1, actualFunctionDefinitionResult.invokingState);
    Token expectedStart = actualFunctionDefinitionResult.stop;
    Token start = actualFunctionDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionDefinitionResult.getStop());
    assertEquals("<missing 'function'><EOF>", actualFunctionDefinitionResult.getText());
    assertEquals("([] <missing 'function'> ([620] ([1431 620] <EOF>)))", actualFunctionDefinitionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(actualFunctionDefinitionResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(622, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    String expectedSourceName = String.join("", "<", System.getProperty("sun.os.patch.level"), ">");
    assertEquals(expectedSourceName, inputStream.getSourceName());
    assertEquals(620, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<EOF>", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testFunctionDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionDefinitionContext functionDefinitionContext = new DomainParserGrammar.FunctionDefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionDefinitionContext functionDefinitionContext = new DomainParserGrammar.FunctionDefinitionContext(
        new ParserRuleContext(), 1);
    functionDefinitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionDefinitionContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testFunctionDefinitionContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testFunctionDefinitionContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testFunctionDefinitionContextConstraints() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).constraints());
  }

  @Test
  public void testFunctionDefinitionContextFUNCTION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).FUNCTION());
  }

  @Test
  public void testFunctionDefinitionContextFunctionTypeSignature() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).functionTypeSignature());
  }

  @Test
  public void testFunctionDefinitionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(36, (new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionDefinitionContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testFunctionDefinitionContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testFunctionDefinitionContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testFunctionDefinitionContextTypeAndMultiplicityParameters() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionDefinitionContext(new ParserRuleContext(), 1))
        .typeAndMultiplicityParameters());
  }

  @Test
  public void testFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = domainParserGrammar
        .functionExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    assertNull(actualFunctionExpressionResult.getParent());
    Token expectedStart = actualFunctionExpressionResult.start;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(997, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.FunctionExpressionContext actualFunctionExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionExpression();

    // Assert
    assertEquals(-1, actualFunctionExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualFunctionExpressionResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '->'> ([998] ([1431 998] <EOF>)) [999])", actualFunctionExpressionResult.toStringTree());
    assertNull(actualFunctionExpressionResult.getParent());
    Token token = actualFunctionExpressionResult.stop;
    Token start = actualFunctionExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualFunctionExpressionResult.getStop());
    assertEquals("<missing '->'><EOF>", actualFunctionExpressionResult.getText());
    assertEquals(3, actualFunctionExpressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(999, ((DomainParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).invokingState);
    assertTrue(((DomainParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2))
        .getStart() instanceof CommonToken);
    assertEquals(2, ((DomainParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).depth());
    assertSame(start, ((DomainParserGrammar.FunctionExpressionParametersContext) parseTreeList.get(2)).getStop());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    assertEquals(998, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    Interval expectedSourceInterval = actualFunctionExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertTrue(((DomainParserGrammar.FunctionExpressionParametersContext) parseTreeList
        .get(2)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[998]", getResult.toString());
  }

  @Test
  public void testFunctionExpressionContextARROW() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW().isEmpty());
    assertNull((new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).ARROW(1));
  }

  @Test
  public void testFunctionExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionExpressionContext functionExpressionContext = new DomainParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionExpressionContext functionExpressionContext = new DomainParserGrammar.FunctionExpressionContext(
        new ParserRuleContext(), 1);
    functionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).functionExpressionParameters()
            .isEmpty());
    assertNull((new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionParameters(1));
  }

  @Test
  public void testFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(83, (new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionExpressionContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).qualifiedName().isEmpty());
    assertNull((new DomainParserGrammar.FunctionExpressionContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = domainParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionLatestMilestoningDateParameterResult.invokingState);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.start;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1009, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = domainParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1009, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameter3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(59));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext actualFunctionExpressionLatestMilestoningDateParameterResult = domainParserGrammar
        .functionExpressionLatestMilestoningDateParameter();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionLatestMilestoningDateParameterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.children.size());
    assertNull(actualFunctionExpressionLatestMilestoningDateParameterResult.getParent());
    Token expectedStart = actualFunctionExpressionLatestMilestoningDateParameterResult.stop;
    Token start = actualFunctionExpressionLatestMilestoningDateParameterResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionLatestMilestoningDateParameterResult.getStop());
    assertEquals("null", actualFunctionExpressionLatestMilestoningDateParameterResult.getText());
    assertEquals(1, actualFunctionExpressionLatestMilestoningDateParameterResult.getChildCount());
    assertTrue(actualFunctionExpressionLatestMilestoningDateParameterResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1010, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionExpressionLatestMilestoningDateParameterResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext functionExpressionLatestMilestoningDateParameterContext = new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(
        new ParserRuleContext(), 1);
    functionExpressionLatestMilestoningDateParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionLatestMilestoningDateParameterContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextCOMMA() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .COMMA());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(84,
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .getRuleIndex());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .LATEST_DATE()
            .isEmpty());
    assertNull(
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .LATEST_DATE(1));
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionLatestMilestoningDateParameterContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.FunctionExpressionLatestMilestoningDateParameterContext(new ParserRuleContext(), 1))
            .PAREN_OPEN());
  }

  @Test
  public void testFunctionExpressionParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = domainParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionExpressionParametersResult.invokingState);
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.start;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionExpressionParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1017, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testFunctionExpressionParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionExpressionParametersContext actualFunctionExpressionParametersResult = domainParserGrammar
        .functionExpressionParameters();

    // Assert
    RecognitionException recognitionException = actualFunctionExpressionParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualFunctionExpressionParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualFunctionExpressionParametersResult.getParent());
    Token expectedStart = actualFunctionExpressionParametersResult.stop;
    Token start = actualFunctionExpressionParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualFunctionExpressionParametersResult.getStop());
    assertEquals("<missing '('><EOF>", actualFunctionExpressionParametersResult.getText());
    assertEquals(2, actualFunctionExpressionParametersResult.getChildCount());
    assertTrue(actualFunctionExpressionParametersResult.isEmpty());
    assertEquals(
        "([] <missing '('> ([1018] ([960 1018] ([967 960 1018] ([800 967 960 1018] ([1039 800 967 960 1018]"
            + " ([1046 1039 800 967 960 1018] ([1431 1046 1039 800 967 960 1018] <EOF>))))))))",
        actualFunctionExpressionParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(1023, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualFunctionExpressionParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(1018, ((DomainParserGrammar.CombinedExpressionContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testFunctionExpressionParametersContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new DomainParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionExpressionParametersContext functionExpressionParametersContext = new DomainParserGrammar.FunctionExpressionParametersContext(
        new ParserRuleContext(), 1);
    functionExpressionParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionExpressionParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionExpressionParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testFunctionExpressionParametersContextCombinedExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).combinedExpression()
            .isEmpty());
    assertNull((new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1))
        .combinedExpression(1));
  }

  @Test
  public void testFunctionExpressionParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(85,
        (new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testFunctionExpressionParametersContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionExpressionParametersContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testFunctionTypePureType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionTypePureTypeResult.getStop());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertEquals(1347, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1346, typeResult.invokingState);
    assertEquals(2, typeResult.depth());
    assertNull(typeResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getType());
    assertSame(start, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertNull(multiplicityResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
  }

  @Test
  public void testFunctionTypePureType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token token = actualFunctionTypePureTypeResult.stop;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualFunctionTypePureTypeResult.getStop());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertEquals(1347, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[1347]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    DomainParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(1, typeResult.getChildCount());
    assertEquals(1346, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testFunctionTypePureType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    assertSame(expectedStop, actualFunctionTypePureTypeResult.getStop());
    assertEquals("null<missing '['><EOF><missing ']'>", actualFunctionTypePureTypeResult.getText());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    assertEquals(1347, actualFunctionTypePureTypeResult.multiplicity().invokingState);
    DomainParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(1346, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testFunctionTypePureType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.FunctionTypePureTypeContext actualFunctionTypePureTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionTypePureType();

    // Assert
    assertEquals(-1, actualFunctionTypePureTypeResult.invokingState);
    assertEquals(2, actualFunctionTypePureTypeResult.children.size());
    assertNull(actualFunctionTypePureTypeResult.getParent());
    Token expectedStart = actualFunctionTypePureTypeResult.start;
    Token start = actualFunctionTypePureTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualFunctionTypePureTypeResult.stop;
    assertSame(expectedStop, actualFunctionTypePureTypeResult.getStop());
    assertEquals("null<missing '['><EOF>null", actualFunctionTypePureTypeResult.getText());
    assertEquals(2, actualFunctionTypePureTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualFunctionTypePureTypeResult.multiplicity();
    assertEquals(1347, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualFunctionTypePureTypeResult.type();
    assertEquals(1346, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testFunctionTypePureTypeContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new DomainParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionTypePureTypeContext functionTypePureTypeContext = new DomainParserGrammar.FunctionTypePureTypeContext(
        new ParserRuleContext(), 1);
    functionTypePureTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionTypePureTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypePureTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(120, (new DomainParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionTypePureTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testFunctionTypePureTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypePureTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testFunctionTypeSignature() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionTypeSignatureContext actualFunctionTypeSignatureResult = domainParserGrammar
        .functionTypeSignature();

    // Assert
    RecognitionException recognitionException = actualFunctionTypeSignatureResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualFunctionTypeSignatureResult.invokingState);
    assertNull(actualFunctionTypeSignatureResult.getParent());
    Token expectedStart = actualFunctionTypeSignatureResult.start;
    Token start = actualFunctionTypeSignatureResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualFunctionTypeSignatureResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(domainParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualFunctionTypeSignatureResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(597, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testFunctionTypeSignature2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionTypeSignatureContext actualFunctionTypeSignatureResult = domainParserGrammar
        .functionTypeSignature();

    // Assert
    RecognitionException recognitionException = actualFunctionTypeSignatureResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualFunctionTypeSignatureResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualFunctionTypeSignatureResult.getParent());
    Token expectedStart = actualFunctionTypeSignatureResult.stop;
    Token start = actualFunctionTypeSignatureResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, actualFunctionTypeSignatureResult.invokingState);
    assertSame(start, actualFunctionTypeSignatureResult.getStop());
    assertEquals("<missing '('><EOF>", actualFunctionTypeSignatureResult.getText());
    assertEquals(2, actualFunctionTypeSignatureResult.getChildCount());
    assertEquals("([] <missing '('> ([598] ([1287 598] <EOF>)))", actualFunctionTypeSignatureResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualFunctionTypeSignatureResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(608, recognitionException.getOffendingState());
    assertEquals(0, start.getTokenIndex());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualFunctionTypeSignatureResult, getResult.getParent());
    assertEquals(598, ((DomainParserGrammar.FunctionVariableExpressionContext) parseTreeList.get(1)).invokingState);
    assertTrue(((DomainParserGrammar.FunctionVariableExpressionContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("<missing '('>", getResult.toString());
    assertEquals("<missing '('>", getResult.getText());
  }

  @Test
  public void testFunctionTypeSignatureContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionTypeSignatureContext functionTypeSignatureContext = new DomainParserGrammar.FunctionTypeSignatureContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionTypeSignatureContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypeSignatureContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionTypeSignatureContext functionTypeSignatureContext = new DomainParserGrammar.FunctionTypeSignatureContext(
        new ParserRuleContext(), 1);
    functionTypeSignatureContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionTypeSignatureContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionTypeSignatureContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testFunctionTypeSignatureContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testFunctionTypeSignatureContextFunctionVariableExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).functionVariableExpression()
            .isEmpty());
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1))
        .functionVariableExpression(1));
  }

  @Test
  public void testFunctionTypeSignatureContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(35, (new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionTypeSignatureContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testFunctionTypeSignatureContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testFunctionTypeSignatureContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testFunctionTypeSignatureContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionTypeSignatureContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testFunctionVariableExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = domainParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertNull(actualFunctionVariableExpressionResult.getStop());
    assertEquals(1, actualFunctionVariableExpressionResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult.identifier();
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1287, identifierResult.invokingState);
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertNull(start.getInputStream());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1288, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getStartIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getType());
  }

  @Test
  public void testFunctionVariableExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = domainParserGrammar
        .functionVariableExpression();

    // Assert
    RecognitionException recognitionException = actualFunctionVariableExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    Token expectedStart = actualFunctionVariableExpressionResult.stop;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertSame(start, actualFunctionVariableExpressionResult.getStop());
    assertEquals("null", actualFunctionVariableExpressionResult.getText());
    assertEquals(1, actualFunctionVariableExpressionResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualFunctionVariableExpressionResult.identifier();
    assertEquals(1287, identifierResult.invokingState);
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualFunctionVariableExpressionResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1288, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualFunctionVariableExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testFunctionVariableExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.FunctionVariableExpressionContext actualFunctionVariableExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).functionVariableExpression();

    // Assert
    assertEquals(-1, actualFunctionVariableExpressionResult.invokingState);
    assertEquals(4, actualFunctionVariableExpressionResult.children.size());
    assertNull(actualFunctionVariableExpressionResult.getParent());
    Token expectedStart = actualFunctionVariableExpressionResult.start;
    Token start = actualFunctionVariableExpressionResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualFunctionVariableExpressionResult.stop;
    Token stop = actualFunctionVariableExpressionResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing ':'><EOF>", actualFunctionVariableExpressionResult.getText());
    assertEquals(4, actualFunctionVariableExpressionResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualFunctionVariableExpressionResult.multiplicity();
    assertEquals(1290, multiplicityResult.invokingState);
    assertEquals(1287, actualFunctionVariableExpressionResult.identifier().invokingState);
    DomainParserGrammar.TypeContext typeResult = actualFunctionVariableExpressionResult.type();
    assertEquals(1289, typeResult.invokingState);
    assertEquals("([1289] ([1307 1289] ([1431 1307 1289] <EOF>)))", typeResult.toStringTree());
    assertNull(typeResult.type());
    assertEquals("<EOF>", typeResult.getText());
    assertSame(stop, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(stop, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testFunctionVariableExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new DomainParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.FunctionVariableExpressionContext functionVariableExpressionContext = new DomainParserGrammar.FunctionVariableExpressionContext(
        new ParserRuleContext(), 1);
    functionVariableExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(functionVariableExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testFunctionVariableExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testFunctionVariableExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(111,
        (new DomainParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testFunctionVariableExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testFunctionVariableExpressionContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testFunctionVariableExpressionContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.FunctionVariableExpressionContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testIdentifier() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.IdentifierContext actualIdentifierResult = domainParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testIdentifier2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Act
    DomainParserGrammar.IdentifierContext actualIdentifierResult = domainParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testIdentifier3() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));

    // Act
    DomainParserGrammar.IdentifierContext actualIdentifierResult = domainParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testIdentifier4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.IdentifierContext actualIdentifierResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.start;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualIdentifierResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testIdentifier5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.IdentifierContext actualIdentifierResult = domainParserGrammar.identifier();

    // Assert
    assertEquals(-1, actualIdentifierResult.invokingState);
    List<ParseTree> parseTreeList = actualIdentifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualIdentifierResult.getParent());
    Token expectedStart = actualIdentifierResult.stop;
    Token start = actualIdentifierResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualIdentifierResult.getStop());
    assertEquals(1, actualIdentifierResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("Input", getResult.getText());
    assertSame(actualIdentifierResult, getResult.getParent());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testIdentifierContextAGGREGATION_TYPE_COMPOSITE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_COMPOSITE());
  }

  @Test
  public void testIdentifierContextAGGREGATION_TYPE_NONE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_NONE());
  }

  @Test
  public void testIdentifierContextAGGREGATION_TYPE_SHARED() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).AGGREGATION_TYPE_SHARED());
  }

  @Test
  public void testIdentifierContextALL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL_VERSIONS());
  }

  @Test
  public void testIdentifierContextALL_VERSIONS_IN_RANGE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ALL_VERSIONS_IN_RANGE());
  }

  @Test
  public void testIdentifierContextAS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).AS());
  }

  @Test
  public void testIdentifierContextASSOCIATION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ASSOCIATION());
  }

  @Test
  public void testIdentifierContextAccept() {
    // Arrange
    DomainParserGrammar.IdentifierContext identifierContext = new DomainParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextAccept2() {
    // Arrange
    DomainParserGrammar.IdentifierContext identifierContext = new DomainParserGrammar.IdentifierContext(
        new ParserRuleContext(), 1);
    identifierContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(identifierContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testIdentifierContextCLASS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).CLASS());
  }

  @Test
  public void testIdentifierContextCONSTRAINT_ENFORCEMENT_LEVEL_ERROR() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).CONSTRAINT_ENFORCEMENT_LEVEL_ERROR());
  }

  @Test
  public void testIdentifierContextCONSTRAINT_ENFORCEMENT_LEVEL_WARN() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).CONSTRAINT_ENFORCEMENT_LEVEL_WARN());
  }

  @Test
  public void testIdentifierContextENUM() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).ENUM());
  }

  @Test
  public void testIdentifierContextEXTENDS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).EXTENDS());
  }

  @Test
  public void testIdentifierContextFUNCTION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).FUNCTION());
  }

  @Test
  public void testIdentifierContextIMPORT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).IMPORT());
  }

  @Test
  public void testIdentifierContextLET() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testIdentifierContextMEASURE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).MEASURE());
  }

  @Test
  public void testIdentifierContextNATIVE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).NATIVE());
  }

  @Test
  public void testIdentifierContextPROFILE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).PROFILE());
  }

  @Test
  public void testIdentifierContextPROJECTS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).PROJECTS());
  }

  @Test
  public void testIdentifierContextSTEREOTYPES() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).STEREOTYPES());
  }

  @Test
  public void testIdentifierContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testIdentifierContextTAGS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).TAGS());
  }

  @Test
  public void testIdentifierContextVALID_STRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.IdentifierContext(new ParserRuleContext(), 1)).VALID_STRING());
  }

  @Test
  public void testImportStatement() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualImportStatementResult.invokingState);
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.start;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportStatementResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(285, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testImportStatement2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualImportStatementResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualImportStatementResult.getParent());
    Token token = actualImportStatementResult.stop;
    assertSame(token, actualImportStatementResult.getStart());
    Token stop = actualImportStatementResult.getStop();
    assertSame(token, stop);
    assertEquals("null", actualImportStatementResult.getText());
    assertEquals(2, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertEquals(287, recognitionException.getOffendingState());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, stop.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualImportStatementResult, getResult.getParent());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(286, ((DomainParserGrammar.PackagePathContext) parseTreeList.get(1)).invokingState);
    assertNull(getResult.getText());
  }

  @Test
  public void testImportStatement3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualImportStatementResult.children.size());
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.start;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualImportStatementResult.stop;
    Token stop = actualImportStatementResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualImportStatementResult.getText());
    assertEquals(2, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1438, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(1, stop.getTokenIndex());
    RuleContext ctx = recognitionException.getCtx();
    assertTrue(ctx instanceof DomainParserGrammar.PackagePathContext);
    assertEquals(286, ((DomainParserGrammar.PackagePathContext) ctx).invokingState);
  }

  @Test
  public void testImportStatement4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(285));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualImportStatementResult.children.size());
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.stop;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualImportStatementResult.getStop());
    assertEquals("null", actualImportStatementResult.getText());
    assertEquals(1, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(285, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testImportStatement5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(3);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualImportStatementResult.children.size());
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.stop;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualImportStatementResult.getStop());
    assertEquals("null", actualImportStatementResult.getText());
    assertEquals(1, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(285, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testImportStatement6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(6));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualImportStatementResult.children.size());
    assertNull(actualImportStatementResult.getParent());
    Token expectedStart = actualImportStatementResult.start;
    Token start = actualImportStatementResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualImportStatementResult.stop;
    Token stop = actualImportStatementResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualImportStatementResult.getText());
    assertEquals(2, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1438, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(1, stop.getTokenIndex());
    RuleContext ctx = recognitionException.getCtx();
    assertTrue(ctx instanceof DomainParserGrammar.PackagePathContext);
    assertEquals(286, ((DomainParserGrammar.PackagePathContext) ctx).invokingState);
  }

  @Test
  public void testImportStatement7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(new CommonToken(1)));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ImportStatementContext actualImportStatementResult = domainParserGrammar.importStatement();

    // Assert
    RecognitionException recognitionException = actualImportStatementResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualImportStatementResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualImportStatementResult.getParent());
    Token token = actualImportStatementResult.stop;
    assertSame(token, actualImportStatementResult.getStart());
    Token stop = actualImportStatementResult.getStop();
    assertSame(token, stop);
    assertEquals("null", actualImportStatementResult.getText());
    assertEquals(2, actualImportStatementResult.getChildCount());
    assertTrue(actualImportStatementResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertEquals(287, recognitionException.getOffendingState());
    assertSame(actualImportStatementResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, stop.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualImportStatementResult, getResult.getParent());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(286, ((DomainParserGrammar.PackagePathContext) parseTreeList.get(1)).invokingState);
    assertNull(getResult.getText());
  }

  @Test
  public void testImportStatementContextAccept() {
    // Arrange
    DomainParserGrammar.ImportStatementContext importStatementContext = new DomainParserGrammar.ImportStatementContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(importStatementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportStatementContextAccept2() {
    // Arrange
    DomainParserGrammar.ImportStatementContext importStatementContext = new DomainParserGrammar.ImportStatementContext(
        new ParserRuleContext(), 1);
    importStatementContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(importStatementContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportStatementContextIMPORT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).IMPORT());
  }

  @Test
  public void testImportStatementContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testImportStatementContextPackagePath() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).packagePath());
  }

  @Test
  public void testImportStatementContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testImportStatementContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ImportStatementContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testImports() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.ImportsContext actualImportsResult = domainParserGrammar.imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualImportsResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testImports2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ImportsContext actualImportsResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    List<ParseTree> parseTreeList = actualImportsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.stop;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualImportsResult.getStop());
    assertEquals(1, actualImportsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.ImportStatementContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ImportStatementContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ImportStatementContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.ImportStatementContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    RecognitionException recognitionException = ((DomainParserGrammar.ImportStatementContext) getResult).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.ImportStatementContext) getResult).children;
    assertEquals(2, parseTreeList1.size());
    assertEquals(287, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(getResult, recognitionException.getCtx());
    assertEquals(286, ((DomainParserGrammar.PackagePathContext) parseTreeList1.get(1)).invokingState);
  }

  @Test
  public void testImports3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ImportsContext actualImportsResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    List<ParseTree> parseTreeList = actualImportsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualImportsResult.stop;
    Token stop = actualImportsResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals(1, actualImportsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ImportStatementContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ImportStatementContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ImportStatementContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.ImportStatementContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    assertTrue(
        ((DomainParserGrammar.ImportStatementContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("nullnull", getResult.getText());
  }

  @Test
  public void testImports4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(0));

    // Act
    DomainParserGrammar.ImportsContext actualImportsResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).imports();

    // Assert
    assertEquals(-1, actualImportsResult.invokingState);
    List<ParseTree> parseTreeList = actualImportsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualImportsResult.getParent());
    Token expectedStart = actualImportsResult.start;
    Token start = actualImportsResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualImportsResult.stop;
    Token stop = actualImportsResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals(1, actualImportsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.ImportStatementContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.ImportStatementContext) getResult).depth());
    assertFalse(((DomainParserGrammar.ImportStatementContext) getResult).isEmpty());
    assertSame(stop, ((DomainParserGrammar.ImportStatementContext) getResult).getStop());
    assertEquals(2, getResult.getChildCount());
    assertTrue(
        ((DomainParserGrammar.ImportStatementContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("nullnull", getResult.getText());
  }

  @Test
  public void testImportsContextAccept() {
    // Arrange
    DomainParserGrammar.ImportsContext importsContext = new DomainParserGrammar.ImportsContext(new ParserRuleContext(),
        1);

    // Act and Assert
    assertNull(importsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportsContextAccept2() {
    // Arrange
    DomainParserGrammar.ImportsContext importsContext = new DomainParserGrammar.ImportsContext(new ParserRuleContext(),
        1);
    importsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(importsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testImportsContextImportStatement() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.ImportsContext(new ParserRuleContext(), 1)).importStatement().isEmpty());
    assertNull((new DomainParserGrammar.ImportsContext(new ParserRuleContext(), 1)).importStatement(1));
  }

  @Test
  public void testInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceContext actualInstanceResult = domainParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceResult.invokingState);
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(821, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceContext actualInstanceResult = domainParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.stop;
    Token start = actualInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceResult.getStop());
    assertEquals("<missing '^'><EOF>", actualInstanceResult.getText());
    assertEquals(2, actualInstanceResult.getChildCount());
    assertTrue(actualInstanceResult.isEmpty());
    assertEquals("([] <missing '^'> ([822] ([1431 822] <EOF>)))", actualInstanceResult.toStringTree());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(832, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualInstanceResult, getResult.getParent());
    assertEquals(822, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
    assertEquals("<missing '^'>", getResult.toString());
    assertEquals("<missing '^'>", getResult.getText());
  }

  @Test
  public void testInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceContext actualInstanceResult = domainParserGrammar.instance();

    // Assert
    RecognitionException recognitionException = actualInstanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstanceResult.getParent());
    Token expectedStart = actualInstanceResult.start;
    assertSame(expectedStart, actualInstanceResult.getStart());
    Token expectedStop = actualInstanceResult.stop;
    Token stop = actualInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '^'><EOF>null", actualInstanceResult.getText());
    assertEquals(3, actualInstanceResult.getChildCount());
    assertTrue(actualInstanceResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualInstanceResult.identifier();
    assertEquals(834, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(851, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualInstanceResult, recognitionException.getCtx());
    assertEquals(822, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertEquals(1, actualInstanceAtomicRightSideResult.depth());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(908, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertEquals(1, actualInstanceAtomicRightSideResult.depth());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(908, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(66));

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertEquals(1, actualInstanceAtomicRightSideResult.children.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertEquals(1, actualInstanceAtomicRightSideResult.depth());
    Token expectedStart = actualInstanceAtomicRightSideResult.stop;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideResult.getStop());
    DomainParserGrammar.InstanceContext instanceResult = actualInstanceAtomicRightSideResult.instance();
    assertEquals("null", instanceResult.getText());
    assertSame(start, instanceResult.getStart());
    assertEquals(2, instanceResult.depth());
    assertFalse(instanceResult.isEmpty());
    assertSame(start, instanceResult.getStop());
    assertEquals(2, instanceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    RecognitionException recognitionException = instanceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(instanceResult, recognitionException.getCtx());
    assertEquals(857, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
  }

  @Test
  public void testInstanceAtomicRightSide4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideResult.identifier());
    assertNull(actualInstanceAtomicRightSideResult.getParent());
    Token token = actualInstanceAtomicRightSideResult.stop;
    assertSame(token, actualInstanceAtomicRightSideResult.getStart());
    Token stop = actualInstanceAtomicRightSideResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    Interval expectedSourceInterval = actualInstanceAtomicRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 903]", identifierResult.toString());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testInstanceAtomicRightSide9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideContext actualInstanceAtomicRightSideResult = domainParserGrammar
        .instanceAtomicRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideResult.invokingState);
    assertEquals(1, actualInstanceAtomicRightSideResult.depth());
    Token expectedStart = actualInstanceAtomicRightSideResult.start;
    Token start = actualInstanceAtomicRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(908, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new DomainParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideContext instanceAtomicRightSideContext = new DomainParserGrammar.InstanceAtomicRightSideContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideContextEnumReference() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).enumReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(66,
        (new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstance() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).instance());
  }

  @Test
  public void testInstanceAtomicRightSideContextInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).instanceLiteral());
  }

  @Test
  public void testInstanceAtomicRightSideContextLATEST_DATE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).LATEST_DATE());
  }

  @Test
  public void testInstanceAtomicRightSideContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testInstanceAtomicRightSideContextStereotypeReference() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).stereotypeReference());
  }

  @Test
  public void testInstanceAtomicRightSideContextTagReference() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideContext(new ParserRuleContext(), 1)).tagReference());
  }

  @Test
  public void testInstanceAtomicRightSideScalar() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = domainParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(66));

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    DomainParserGrammar.InstanceContext instanceResult = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult)
        .instance();
    assertFalse(instanceResult.isEmpty());
    assertSame(start, instanceResult.getStop());
    assertEquals(2, instanceResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, instanceResult.getSourceInterval());
    assertEquals(3, instanceResult.depth());
    assertTrue(instanceResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalar4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = domainParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = domainParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = domainParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.stop;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[903 885]", getResult1.toString());
    assertEquals(903, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceAtomicRightSideScalarResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceAtomicRightSideScalar9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideScalarContext actualInstanceAtomicRightSideScalarResult = domainParserGrammar
        .instanceAtomicRightSideScalar();

    // Assert
    assertEquals(-1, actualInstanceAtomicRightSideScalarResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideScalarResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideScalarResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideScalarResult.start;
    Token start = actualInstanceAtomicRightSideScalarResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideScalarResult.getStop());
    assertEquals(1, actualInstanceAtomicRightSideScalarResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new DomainParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideScalarContext instanceAtomicRightSideScalarContext = new DomainParserGrammar.InstanceAtomicRightSideScalarContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideScalarContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideScalarContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(64,
        (new DomainParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideScalarContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideScalarContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide());
  }

  @Test
  public void testInstanceAtomicRightSideVector() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = domainParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceAtomicRightSideVectorResult.invokingState);
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.start;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(887, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceAtomicRightSideVector2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceAtomicRightSideVectorContext actualInstanceAtomicRightSideVectorResult = domainParserGrammar
        .instanceAtomicRightSideVector();

    // Assert
    RecognitionException recognitionException = actualInstanceAtomicRightSideVectorResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualInstanceAtomicRightSideVectorResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualInstanceAtomicRightSideVectorResult.getParent());
    Token expectedStart = actualInstanceAtomicRightSideVectorResult.stop;
    Token start = actualInstanceAtomicRightSideVectorResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceAtomicRightSideVectorResult.getStop());
    assertEquals("<missing '['><EOF>", actualInstanceAtomicRightSideVectorResult.getText());
    assertEquals(2, actualInstanceAtomicRightSideVectorResult.getChildCount());
    assertTrue(actualInstanceAtomicRightSideVectorResult.isEmpty());
    assertEquals("([] <missing '['> ([888] ([903 888] ([1431 903 888] <EOF>))))",
        actualInstanceAtomicRightSideVectorResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(893, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualInstanceAtomicRightSideVectorResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(888, ((DomainParserGrammar.InstanceAtomicRightSideContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new DomainParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceAtomicRightSideVectorContext instanceAtomicRightSideVectorContext = new DomainParserGrammar.InstanceAtomicRightSideVectorContext(
        new ParserRuleContext(), 1);
    instanceAtomicRightSideVectorContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceAtomicRightSideVectorContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(65,
        (new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceAtomicRightSideVectorContextInstanceAtomicRightSide() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide()
        .isEmpty());
    assertNull((new DomainParserGrammar.InstanceAtomicRightSideVectorContext(new ParserRuleContext(), 1))
        .instanceAtomicRightSide(1));
  }

  @Test
  public void testInstanceContextAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testInstanceContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceContext instanceContext = new DomainParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceContext instanceContext = new DomainParserGrammar.InstanceContext(
        new ParserRuleContext(), 1);
    instanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testInstanceContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testInstanceContextFILE_NAME() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME());
  }

  @Test
  public void testInstanceContextFILE_NAME_END() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).FILE_NAME_END());
  }

  @Test
  public void testInstanceContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(59, (new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceContextINTEGER() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER().isEmpty());
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).INTEGER(1));
  }

  @Test
  public void testInstanceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstanceContextInstancePropertyAssignment() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).instancePropertyAssignment().isEmpty());
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).instancePropertyAssignment(1));
  }

  @Test
  public void testInstanceContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testInstanceContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testInstanceContextNEW_SYMBOL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).NEW_SYMBOL());
  }

  @Test
  public void testInstanceContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testInstanceContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testInstanceContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testInstanceContextQualifiedName() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName().isEmpty());
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).qualifiedName(1));
  }

  @Test
  public void testInstanceContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceLiteralContext actualInstanceLiteralResult = domainParserGrammar.instanceLiteral();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceLiteralResult.invokingState);
    assertNull(actualInstanceLiteralResult.getParent());
    Token expectedStart = actualInstanceLiteralResult.start;
    Token start = actualInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1210, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceLiteralContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceLiteralContext instanceLiteralContext = new DomainParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceLiteralContext instanceLiteralContext = new DomainParserGrammar.InstanceLiteralContext(
        new ParserRuleContext(), 1);
    instanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(106, (new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralContextInstanceLiteralToken() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).instanceLiteralToken());
  }

  @Test
  public void testInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testInstanceLiteralToken() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = domainParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralToken2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = domainParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("null", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1212, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testInstanceLiteralToken3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = domainParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1212, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testInstanceLiteralToken5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = domainParserGrammar
        .instanceLiteralToken();

    // Assert
    RecognitionException recognitionException = actualInstanceLiteralTokenResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstanceLiteralTokenResult.children.size());
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.stop;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceLiteralTokenResult.getStop());
    assertEquals("Input", actualInstanceLiteralTokenResult.getText());
    assertEquals(1, actualInstanceLiteralTokenResult.getChildCount());
    assertTrue(actualInstanceLiteralTokenResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1212, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualInstanceLiteralTokenResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testInstanceLiteralToken6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceLiteralTokenContext actualInstanceLiteralTokenResult = domainParserGrammar
        .instanceLiteralToken();

    // Assert
    assertEquals(-1, actualInstanceLiteralTokenResult.invokingState);
    assertNull(actualInstanceLiteralTokenResult.getParent());
    Token expectedStart = actualInstanceLiteralTokenResult.start;
    Token start = actualInstanceLiteralTokenResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceLiteralTokenResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testInstanceLiteralTokenContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new DomainParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceLiteralTokenContext instanceLiteralTokenContext = new DomainParserGrammar.InstanceLiteralTokenContext(
        new ParserRuleContext(), 1);
    instanceLiteralTokenContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceLiteralTokenContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceLiteralTokenContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testInstanceLiteralTokenContextDATE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DATE());
  }

  @Test
  public void testInstanceLiteralTokenContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testInstanceLiteralTokenContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testInstanceLiteralTokenContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(107, (new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceLiteralTokenContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testInstanceLiteralTokenContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceLiteralTokenContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testInstancePropertyAssignment() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = domainParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstancePropertyAssignmentResult.getStop());
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertEquals(877, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(878, recognitionException.getOffendingState());
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
  }

  @Test
  public void testInstancePropertyAssignment2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = domainParserGrammar
        .instancePropertyAssignment();

    // Assert
    RecognitionException recognitionException = actualInstancePropertyAssignmentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualInstancePropertyAssignmentResult.children.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.stop;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstancePropertyAssignmentResult.getStop());
    assertEquals("null", actualInstancePropertyAssignmentResult.getText());
    assertEquals(1, actualInstancePropertyAssignmentResult.getChildCount());
    assertTrue(actualInstancePropertyAssignmentResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertEquals(877, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(878, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualInstancePropertyAssignmentResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testInstancePropertyAssignment3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.InstancePropertyAssignmentContext actualInstancePropertyAssignmentResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instancePropertyAssignment();

    // Assert
    assertEquals(-1, actualInstancePropertyAssignmentResult.invokingState);
    List<ParseTree> parseTreeList = actualInstancePropertyAssignmentResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualInstancePropertyAssignmentResult.getParent());
    Token expectedStart = actualInstancePropertyAssignmentResult.start;
    Token start = actualInstancePropertyAssignmentResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualInstancePropertyAssignmentResult.stop;
    Token stop = actualInstancePropertyAssignmentResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '='><EOF>", actualInstancePropertyAssignmentResult.getText());
    assertEquals(3, actualInstancePropertyAssignmentResult.getChildCount());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    DomainParserGrammar.IdentifierContext identifierResult = actualInstancePropertyAssignmentResult.identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(877, identifierResult.invokingState);
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(879, ((DomainParserGrammar.InstanceRightSideContext) parseTreeList.get(2)).invokingState);
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept() {
    // Arrange
    DomainParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new DomainParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextAccept2() {
    // Arrange
    DomainParserGrammar.InstancePropertyAssignmentContext instancePropertyAssignmentContext = new DomainParserGrammar.InstancePropertyAssignmentContext(
        new ParserRuleContext(), 1);
    instancePropertyAssignmentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instancePropertyAssignmentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstancePropertyAssignmentContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testInstancePropertyAssignmentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(62,
        (new DomainParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstancePropertyAssignmentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testInstancePropertyAssignmentContextInstanceRightSide() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstancePropertyAssignmentContext(new ParserRuleContext(), 1)).instanceRightSide());
  }

  @Test
  public void testInstanceReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1048, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.stop;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceReferenceResult.getStop());
    assertEquals(1, actualInstanceReferenceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualInstanceReferenceResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testInstanceReference8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1048, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReference9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceReferenceContext actualInstanceReferenceResult = domainParserGrammar
        .instanceReference();

    // Assert
    RecognitionException recognitionException = actualInstanceReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceReferenceResult.invokingState);
    assertNull(actualInstanceReferenceResult.getParent());
    Token expectedStart = actualInstanceReferenceResult.start;
    Token start = actualInstanceReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceReferenceResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1048, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceReferenceResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceReferenceContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceReferenceContext instanceReferenceContext = new DomainParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceReferenceContext instanceReferenceContext = new DomainParserGrammar.InstanceReferenceContext(
        new ParserRuleContext(), 1);
    instanceReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceReferenceContextAllOrFunction() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).allOrFunction());
  }

  @Test
  public void testInstanceReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(87, (new DomainParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceReferenceContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testInstanceReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testInstanceReferenceContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.InstanceReferenceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testInstanceRightSide() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(883, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    List<ParseTree> parseTreeList = actualInstanceRightSideResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.stop;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualInstanceRightSideResult.getStop());
    assertEquals(1, actualInstanceRightSideResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).depth());
    assertFalse(((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.InstanceAtomicRightSideScalarContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(885, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).depth());
    assertSame(start, ((DomainParserGrammar.InstanceAtomicRightSideContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualInstanceRightSideResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testInstanceRightSide8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(883, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSide9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.InstanceRightSideContext actualInstanceRightSideResult = domainParserGrammar
        .instanceRightSide();

    // Assert
    RecognitionException recognitionException = actualInstanceRightSideResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualInstanceRightSideResult.invokingState);
    assertNull(actualInstanceRightSideResult.getParent());
    Token expectedStart = actualInstanceRightSideResult.start;
    Token start = actualInstanceRightSideResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualInstanceRightSideResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(883, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualInstanceRightSideResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testInstanceRightSideContextAccept() {
    // Arrange
    DomainParserGrammar.InstanceRightSideContext instanceRightSideContext = new DomainParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextAccept2() {
    // Arrange
    DomainParserGrammar.InstanceRightSideContext instanceRightSideContext = new DomainParserGrammar.InstanceRightSideContext(
        new ParserRuleContext(), 1);
    instanceRightSideContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(instanceRightSideContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testInstanceRightSideContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(63, (new DomainParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideScalar() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1)).instanceAtomicRightSideScalar());
  }

  @Test
  public void testInstanceRightSideContextInstanceAtomicRightSideVector() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.InstanceRightSideContext(new ParserRuleContext(), 1)).instanceAtomicRightSideVector());
  }

  @Test
  public void testLambdaFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = domainParserGrammar.lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaFunctionResult.invokingState);
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.start;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1053, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LambdaFunctionContext actualLambdaFunctionResult = domainParserGrammar.lambdaFunction();

    // Assert
    RecognitionException recognitionException = actualLambdaFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualLambdaFunctionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaFunctionResult.getParent());
    Token expectedStart = actualLambdaFunctionResult.stop;
    Token start = actualLambdaFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLambdaFunctionResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF>", actualLambdaFunctionResult.getText());
    assertEquals(2, actualLambdaFunctionResult.getChildCount());
    assertTrue(actualLambdaFunctionResult.isEmpty());
    assertEquals("([] <missing BRACE_OPEN> ([1054] ([1189 1054] <EOF>)))", actualLambdaFunctionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(1059, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualLambdaFunctionResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(1054, ((DomainParserGrammar.LambdaParamContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testLambdaFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.LambdaFunctionContext lambdaFunctionContext = new DomainParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.LambdaFunctionContext lambdaFunctionContext = new DomainParserGrammar.LambdaFunctionContext(
        new ParserRuleContext(), 1);
    lambdaFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaFunctionContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testLambdaFunctionContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testLambdaFunctionContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testLambdaFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(88, (new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaFunctionContextLambdaParam() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam().isEmpty());
    assertNull((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaParam(1));
  }

  @Test
  public void testLambdaFunctionContextLambdaPipe() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaFunctionContext(new ParserRuleContext(), 1)).lambdaPipe());
  }

  @Test
  public void testLambdaParam() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.LambdaParamContext actualLambdaParamResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertFalse(identifierResult.isEmpty());
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaParam2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.LambdaParamContext actualLambdaParamResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token token = actualLambdaParamResult.stop;
    assertSame(token, actualLambdaParamResult.getStart());
    Token stop = actualLambdaParamResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testLambdaParam3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.LambdaParamContext actualLambdaParamResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token token = actualLambdaParamResult.stop;
    assertSame(token, actualLambdaParamResult.getStart());
    Token stop = actualLambdaParamResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParam4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.LambdaParamContext actualLambdaParamResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token expectedStart = actualLambdaParamResult.start;
    Token start = actualLambdaParamResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamResult.getStop());
    assertEquals(1, actualLambdaParamResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1189, identifierResult.invokingState);
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testLambdaParam5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.LambdaParamContext actualLambdaParamResult = domainParserGrammar.lambdaParam();

    // Assert
    assertEquals(-1, actualLambdaParamResult.invokingState);
    assertEquals(1, actualLambdaParamResult.children.size());
    assertNull(actualLambdaParamResult.getParent());
    Token token = actualLambdaParamResult.stop;
    assertSame(token, actualLambdaParamResult.getStart());
    Token stop = actualLambdaParamResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualLambdaParamResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualLambdaParamResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testLambdaParamContextAccept() {
    // Arrange
    DomainParserGrammar.LambdaParamContext lambdaParamContext = new DomainParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextAccept2() {
    // Arrange
    DomainParserGrammar.LambdaParamContext lambdaParamContext = new DomainParserGrammar.LambdaParamContext(
        new ParserRuleContext(), 1);
    lambdaParamContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(104, (new DomainParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLambdaParamContextLambdaParamType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaParamContext(new ParserRuleContext(), 1)).lambdaParamType());
  }

  @Test
  public void testLambdaParamType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = domainParserGrammar.lambdaParamType();

    // Assert
    RecognitionException recognitionException = actualLambdaParamTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertNull(actualLambdaParamTypeResult.getParent());
    Token expectedStart = actualLambdaParamTypeResult.start;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaParamTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(domainParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualLambdaParamTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1193, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testLambdaParamType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.LambdaParamTypeContext actualLambdaParamTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaParamType();

    // Assert
    assertEquals(-1, actualLambdaParamTypeResult.invokingState);
    assertEquals(3, actualLambdaParamTypeResult.children.size());
    assertEquals("([] <missing ':'> ([1194] ([1307 1194] ([1431 1307 1194] <EOF>))) [1195])",
        actualLambdaParamTypeResult.toStringTree());
    assertNull(actualLambdaParamTypeResult.getParent());
    Token token = actualLambdaParamTypeResult.stop;
    Token start = actualLambdaParamTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualLambdaParamTypeResult.getStop());
    assertEquals("<missing ':'><EOF>", actualLambdaParamTypeResult.getText());
    assertEquals(3, actualLambdaParamTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualLambdaParamTypeResult.multiplicity();
    assertEquals(1195, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualLambdaParamTypeResult.type();
    assertEquals(1194, typeResult.invokingState);
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(1, typeResult.getChildCount());
    Interval expectedSourceInterval = actualLambdaParamTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, typeResult.getSourceInterval());
    assertTrue(multiplicityResult.getStart() instanceof CommonToken);
    assertEquals(2, multiplicityResult.depth());
    assertSame(start, multiplicityResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testLambdaParamTypeContextAccept() {
    // Arrange
    DomainParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new DomainParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.LambdaParamTypeContext lambdaParamTypeContext = new DomainParserGrammar.LambdaParamTypeContext(
        new ParserRuleContext(), 1);
    lambdaParamTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaParamTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaParamTypeContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testLambdaParamTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(105, (new DomainParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaParamTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testLambdaParamTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaParamTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testLambdaPipe() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LambdaPipeContext actualLambdaPipeResult = domainParserGrammar.lambdaPipe();

    // Assert
    RecognitionException recognitionException = actualLambdaPipeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    assertNull(actualLambdaPipeResult.getParent());
    Token expectedStart = actualLambdaPipeResult.start;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLambdaPipeResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1186, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualLambdaPipeResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testLambdaPipe2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.LambdaPipeContext actualLambdaPipeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).lambdaPipe();

    // Assert
    assertEquals(-1, actualLambdaPipeResult.invokingState);
    List<ParseTree> parseTreeList = actualLambdaPipeResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualLambdaPipeResult.getParent());
    Token token = actualLambdaPipeResult.stop;
    Token start = actualLambdaPipeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualLambdaPipeResult.getStop());
    assertEquals(2, actualLambdaPipeResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<EOF>", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CodeBlockContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CodeBlockContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CodeBlockContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CodeBlockContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals("<missing '|'>", getResult1.toString());
    assertEquals("([1187] ([925 1187] ([937 925 1187] ([960 937 925 1187] ([967 960 937 925 1187] ([800 967 960 937 925"
        + " 1187] ([1039 800 967 960 937 925 1187] ([1046 1039 800 967 960 937 925 1187] ([1431 1046 1039 800 967"
        + " 960 937 925 1187] <EOF>)))))))))", getResult.toStringTree());
    assertSame(actualLambdaPipeResult, getResult1.getParent());
  }

  @Test
  public void testLambdaPipeContextAccept() {
    // Arrange
    DomainParserGrammar.LambdaPipeContext lambdaPipeContext = new DomainParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextAccept2() {
    // Arrange
    DomainParserGrammar.LambdaPipeContext lambdaPipeContext = new DomainParserGrammar.LambdaPipeContext(
        new ParserRuleContext(), 1);
    lambdaPipeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(lambdaPipeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLambdaPipeContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testLambdaPipeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(103, (new DomainParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLambdaPipeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LambdaPipeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testLetExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LetExpressionContext actualLetExpressionResult = domainParserGrammar.letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualLetExpressionResult.invokingState);
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.start;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualLetExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(955, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testLetExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.LetExpressionContext actualLetExpressionResult = domainParserGrammar.letExpression();

    // Assert
    RecognitionException recognitionException = actualLetExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, actualLetExpressionResult.children.size());
    assertNull(actualLetExpressionResult.getParent());
    Token expectedStart = actualLetExpressionResult.stop;
    Token start = actualLetExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualLetExpressionResult.getStop());
    assertEquals("<missing 'let'><EOF>", actualLetExpressionResult.getText());
    assertEquals(2, actualLetExpressionResult.getChildCount());
    assertTrue(actualLetExpressionResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualLetExpressionResult.identifier();
    assertEquals(956, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(957, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualLetExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testLetExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.LetExpressionContext letExpressionContext = new DomainParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.LetExpressionContext letExpressionContext = new DomainParserGrammar.LetExpressionContext(
        new ParserRuleContext(), 1);
    letExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(letExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testLetExpressionContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testLetExpressionContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testLetExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(76, (new DomainParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testLetExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testLetExpressionContextLET() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.LetExpressionContext(new ParserRuleContext(), 1)).LET());
  }

  @Test
  public void testMeasureBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MeasureBodyContext actualMeasureBodyResult = domainParserGrammar.measureBody();

    // Assert
    RecognitionException recognitionException = actualMeasureBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMeasureBodyResult.invokingState);
    assertNull(actualMeasureBodyResult.getParent());
    Token expectedStart = actualMeasureBodyResult.start;
    Token start = actualMeasureBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMeasureBodyResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(551, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMeasureBodyResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMeasureBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MeasureBodyContext actualMeasureBodyResult = domainParserGrammar.measureBody();

    // Assert
    RecognitionException recognitionException = actualMeasureBodyResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualMeasureBodyResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMeasureBodyResult.getParent());
    Token token = actualMeasureBodyResult.stop;
    assertSame(token, actualMeasureBodyResult.getStart());
    Token stop = actualMeasureBodyResult.getStop();
    assertSame(token, stop);
    assertEquals("<missing BRACE_OPEN><EOF>", actualMeasureBodyResult.getText());
    assertEquals(2, actualMeasureBodyResult.getChildCount());
    assertTrue(actualMeasureBodyResult.isEmpty());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(570, recognitionException.getOffendingState());
    assertSame(stop, ((NoViableAltException) recognitionException).getStartToken());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualMeasureBodyResult, recognitionException.getCtx());
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(actualMeasureBodyResult, getResult.getParent());
    assertEquals("<missing BRACE_OPEN>", getResult.toString());
  }

  @Test
  public void testMeasureBodyContextAccept() {
    // Arrange
    DomainParserGrammar.MeasureBodyContext measureBodyContext = new DomainParserGrammar.MeasureBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(measureBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureBodyContextAccept2() {
    // Arrange
    DomainParserGrammar.MeasureBodyContext measureBodyContext = new DomainParserGrammar.MeasureBodyContext(
        new ParserRuleContext(), 1);
    measureBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(measureBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureBodyContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testMeasureBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testMeasureBodyContextCanonicalExpr() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).canonicalExpr());
  }

  @Test
  public void testMeasureBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(29, (new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMeasureBodyContextMeasureExpr() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).measureExpr().isEmpty());
    assertNull((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).measureExpr(1));
  }

  @Test
  public void testMeasureBodyContextNonConvertibleMeasureExpr() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).nonConvertibleMeasureExpr().isEmpty());
    assertNull((new DomainParserGrammar.MeasureBodyContext(new ParserRuleContext(), 1)).nonConvertibleMeasureExpr(1));
  }

  @Test
  public void testMeasureDefinition() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MeasureDefinitionContext actualMeasureDefinitionResult = domainParserGrammar
        .measureDefinition();

    // Assert
    RecognitionException recognitionException = actualMeasureDefinitionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMeasureDefinitionResult.invokingState);
    assertNull(actualMeasureDefinitionResult.getParent());
    Token expectedStart = actualMeasureDefinitionResult.start;
    Token start = actualMeasureDefinitionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMeasureDefinitionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(547, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMeasureDefinitionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMeasureDefinition2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.MeasureDefinitionContext actualMeasureDefinitionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).measureDefinition();

    // Assert
    assertEquals(-1, actualMeasureDefinitionResult.invokingState);
    List<ParseTree> parseTreeList = actualMeasureDefinitionResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing 'Measure'> ([548] ([1431 548] <EOF>)) [549])",
        actualMeasureDefinitionResult.toStringTree());
    assertNull(actualMeasureDefinitionResult.getParent());
    Token token = actualMeasureDefinitionResult.stop;
    Token start = actualMeasureDefinitionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMeasureDefinitionResult.getStop());
    assertEquals("<missing 'Measure'><EOF>", actualMeasureDefinitionResult.getText());
    assertEquals(3, actualMeasureDefinitionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(549, ((DomainParserGrammar.MeasureBodyContext) parseTreeList.get(2)).invokingState);
    assertTrue(((DomainParserGrammar.MeasureBodyContext) parseTreeList.get(2)).getStart() instanceof CommonToken);
    assertEquals(2, ((DomainParserGrammar.MeasureBodyContext) parseTreeList.get(2)).depth());
    assertSame(start, ((DomainParserGrammar.MeasureBodyContext) parseTreeList.get(2)).getStop());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    assertEquals(548, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    Interval expectedSourceInterval = actualMeasureDefinitionResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult.getSourceInterval());
    assertTrue(((DomainParserGrammar.MeasureBodyContext) parseTreeList
        .get(2)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[548]", getResult.toString());
  }

  @Test
  public void testMeasureDefinitionContextAccept() {
    // Arrange
    DomainParserGrammar.MeasureDefinitionContext measureDefinitionContext = new DomainParserGrammar.MeasureDefinitionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(measureDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureDefinitionContextAccept2() {
    // Arrange
    DomainParserGrammar.MeasureDefinitionContext measureDefinitionContext = new DomainParserGrammar.MeasureDefinitionContext(
        new ParserRuleContext(), 1);
    measureDefinitionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(measureDefinitionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureDefinitionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(28, (new DomainParserGrammar.MeasureDefinitionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMeasureDefinitionContextMEASURE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureDefinitionContext(new ParserRuleContext(), 1)).MEASURE());
  }

  @Test
  public void testMeasureDefinitionContextMeasureBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureDefinitionContext(new ParserRuleContext(), 1)).measureBody());
  }

  @Test
  public void testMeasureDefinitionContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureDefinitionContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testMeasureExpr() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MeasureExprContext actualMeasureExprResult = domainParserGrammar.measureExpr();

    // Assert
    RecognitionException recognitionException = actualMeasureExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMeasureExprResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMeasureExprResult.getParent());
    Token expectedStart = actualMeasureExprResult.start;
    Token start = actualMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMeasureExprResult.getStop());
    assertEquals(1, actualMeasureExprResult.getChildCount());
    assertTrue(actualMeasureExprResult.isEmpty());
    assertEquals("([] [577])", actualMeasureExprResult.toStringTree());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(578, recognitionException.getOffendingState());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertSame(actualMeasureExprResult, recognitionException.getCtx());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, inputStream.index());
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
    assertEquals(577, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testMeasureExpr2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MeasureExprContext actualMeasureExprResult = domainParserGrammar.measureExpr();

    // Assert
    RecognitionException recognitionException = actualMeasureExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMeasureExprResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMeasureExprResult.getParent());
    Token expectedStart = actualMeasureExprResult.stop;
    Token start = actualMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMeasureExprResult.getStop());
    assertEquals("null", actualMeasureExprResult.getText());
    assertEquals(1, actualMeasureExprResult.getChildCount());
    assertTrue(actualMeasureExprResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(578, recognitionException.getOffendingState());
    assertSame(actualMeasureExprResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(2, inputStream.size());
    assertEquals(577, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testMeasureExpr3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.MeasureExprContext actualMeasureExprResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).measureExpr();

    // Assert
    assertEquals(-1, actualMeasureExprResult.invokingState);
    List<ParseTree> parseTreeList = actualMeasureExprResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualMeasureExprResult.getParent());
    Token expectedStart = actualMeasureExprResult.start;
    Token start = actualMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMeasureExprResult.stop;
    Token stop = actualMeasureExprResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing ':'><EOF>", actualMeasureExprResult.getText());
    assertEquals(3, actualMeasureExprResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(577, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(2);
    assertTrue(
        ((DomainParserGrammar.UnitExprContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(stop, ((DomainParserGrammar.UnitExprContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("[579]", getResult.toString());
    assertEquals(579, ((DomainParserGrammar.UnitExprContext) getResult).invokingState);
  }

  @Test
  public void testMeasureExprContextAccept() {
    // Arrange
    DomainParserGrammar.MeasureExprContext measureExprContext = new DomainParserGrammar.MeasureExprContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(measureExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureExprContextAccept2() {
    // Arrange
    DomainParserGrammar.MeasureExprContext measureExprContext = new DomainParserGrammar.MeasureExprContext(
        new ParserRuleContext(), 1);
    measureExprContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(measureExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMeasureExprContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureExprContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testMeasureExprContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(31, (new DomainParserGrammar.MeasureExprContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMeasureExprContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureExprContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testMeasureExprContextUnitExpr() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MeasureExprContext(new ParserRuleContext(), 1)).unitExpr());
  }

  @Test
  public void testMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MultiplicityContext actualMultiplicityResult = domainParserGrammar.multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityResult.invokingState);
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1338, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.MultiplicityContext actualMultiplicityResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicity();

    // Assert
    assertEquals(-1, actualMultiplicityResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing '['> ([1339] ([1400 1339] <EOF>)) <missing ']'>)",
        actualMultiplicityResult.toStringTree());
    assertNull(actualMultiplicityResult.getParent());
    Token token = actualMultiplicityResult.stop;
    Token start = actualMultiplicityResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplicityResult.getStop());
    assertEquals("<missing '['><EOF><missing ']'>", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing ']'>", getResult1.getText());
    assertEquals("<missing ']'>", getResult1.toString());
    assertSame(actualMultiplicityResult, getResult1.getParent());
    assertEquals(1339, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
  }

  @Test
  public void testMultiplicity3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MultiplicityContext actualMultiplicityResult = domainParserGrammar.multiplicity();

    // Assert
    RecognitionException recognitionException = actualMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualMultiplicityResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualMultiplicityResult.getParent());
    Token expectedStart = actualMultiplicityResult.start;
    Token start = actualMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualMultiplicityResult.stop;
    Token stop = actualMultiplicityResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("<missing '['><EOF>null", actualMultiplicityResult.getText());
    assertEquals(3, actualMultiplicityResult.getChildCount());
    assertTrue(actualMultiplicityResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1340, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(stop, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualMultiplicityResult, recognitionException.getCtx());
    assertEquals(1339, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testMultiplicityArgument() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = domainParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertNull(actualMultiplicityArgumentResult.getParent());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1407, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgument2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertNull(actualMultiplicityArgumentResult.getParent());
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    Token token = actualMultiplicityArgumentResult.stop;
    assertSame(token, actualMultiplicityArgumentResult.getStart());
    Token stop = actualMultiplicityArgumentResult.getStop();
    assertSame(token, stop);
    DomainParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertEquals(1400, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertNull(actualMultiplicityArgumentResult.getParent());
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    Token token = actualMultiplicityArgumentResult.stop;
    assertSame(token, actualMultiplicityArgumentResult.getStart());
    Token stop = actualMultiplicityArgumentResult.getStop();
    assertSame(token, stop);
    DomainParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertEquals(1400, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertNull(actualMultiplicityArgumentResult.getParent());
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    Token token = actualMultiplicityArgumentResult.stop;
    assertSame(token, actualMultiplicityArgumentResult.getStart());
    Token stop = actualMultiplicityArgumentResult.getStop();
    assertSame(token, stop);
    DomainParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertEquals(1400, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = domainParserGrammar
        .multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertNull(actualMultiplicityArgumentResult.getParent());
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    Token token = actualMultiplicityArgumentResult.stop;
    assertSame(token, actualMultiplicityArgumentResult.getStart());
    Token stop = actualMultiplicityArgumentResult.getStop();
    assertSame(token, stop);
    DomainParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertEquals(1400, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = domainParserGrammar
        .multiplicityArgument();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertEquals(1, actualMultiplicityArgumentResult.children.size());
    assertNull(actualMultiplicityArgumentResult.getParent());
    assertNull(actualMultiplicityArgumentResult.toMultiplicity());
    Token token = actualMultiplicityArgumentResult.stop;
    assertSame(token, actualMultiplicityArgumentResult.getStart());
    Token stop = actualMultiplicityArgumentResult.getStop();
    assertSame(token, stop);
    DomainParserGrammar.IdentifierContext identifierResult = actualMultiplicityArgumentResult.identifier();
    assertEquals(1400, identifierResult.invokingState);
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.toString());
  }

  @Test
  public void testMultiplicityArgument7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = domainParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertNull(actualMultiplicityArgumentResult.getParent());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1407, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgument8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.MultiplicityArgumentContext actualMultiplicityArgumentResult = domainParserGrammar
        .multiplicityArgument();

    // Assert
    RecognitionException recognitionException = actualMultiplicityArgumentResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplicityArgumentResult.invokingState);
    assertNull(actualMultiplicityArgumentResult.getParent());
    Token expectedStart = actualMultiplicityArgumentResult.start;
    Token start = actualMultiplicityArgumentResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(actualMultiplicityArgumentResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1407, recognitionException.getOffendingState());
    assertEquals(-1, start.getStopIndex());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplicityArgumentContextAccept() {
    // Arrange
    DomainParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new DomainParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextAccept2() {
    // Arrange
    DomainParserGrammar.MultiplicityArgumentContext multiplicityArgumentContext = new DomainParserGrammar.MultiplicityArgumentContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentContextDOT_DOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).DOT_DOT());
  }

  @Test
  public void testMultiplicityArgumentContextFromMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).fromMultiplicity());
  }

  @Test
  public void testMultiplicityArgumentContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(128, (new DomainParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testMultiplicityArgumentContextToMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityArgumentContext(new ParserRuleContext(), 1)).toMultiplicity());
  }

  @Test
  public void testMultiplicityArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertEquals(1400, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1400 1392]", identifierResult.toString());
  }

  @Test
  public void testMultiplicityArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertEquals(1400, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1400 1392]", identifierResult.toString());
  }

  @Test
  public void testMultiplicityArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertEquals(1400, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1400 1392]", identifierResult.toString());
  }

  @Test
  public void testMultiplicityArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = domainParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertEquals(1400, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1400 1392]", identifierResult.toString());
  }

  @Test
  public void testMultiplicityArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = domainParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.stop;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStart());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) getResult).toMultiplicity());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).getStop());
    assertEquals(1, ((DomainParserGrammar.MultiplicityArgumentContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.MultiplicityArgumentContext) getResult)
        .identifier();
    assertEquals(1400, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualMultiplicityArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1400 1392]", identifierResult.toString());
  }

  @Test
  public void testMultiplicityArguments7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = domainParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArguments8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.MultiplicityArgumentsContext actualMultiplicityArgumentsResult = domainParserGrammar
        .multiplicityArguments();

    // Assert
    assertEquals(-1, actualMultiplicityArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplicityArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualMultiplicityArgumentsResult.getParent());
    Token expectedStart = actualMultiplicityArgumentsResult.start;
    Token start = actualMultiplicityArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplicityArgumentsResult.getStop());
    assertEquals(1, actualMultiplicityArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertSame(start, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    assertTrue(((DomainParserGrammar.MultiplicityArgumentContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testMultiplicityArgumentsContextAccept() {
    // Arrange
    DomainParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new DomainParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextAccept2() {
    // Arrange
    DomainParserGrammar.MultiplicityArgumentsContext multiplicityArgumentsContext = new DomainParserGrammar.MultiplicityArgumentsContext(
        new ParserRuleContext(), 1);
    multiplicityArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplicityArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(127,
        (new DomainParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityArgumentsContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).multiplicityArgument()
        .isEmpty());
    assertNull(
        (new DomainParserGrammar.MultiplicityArgumentsContext(new ParserRuleContext(), 1)).multiplicityArgument(1));
  }

  @Test
  public void testMultiplicityContextAccept() {
    // Arrange
    DomainParserGrammar.MultiplicityContext multiplicityContext = new DomainParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextAccept2() {
    // Arrange
    DomainParserGrammar.MultiplicityContext multiplicityContext = new DomainParserGrammar.MultiplicityContext(
        new ParserRuleContext(), 1);
    multiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplicityContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testMultiplicityContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(117, (new DomainParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplicityContextMultiplicityArgument() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplicityContext(new ParserRuleContext(), 1)).multiplicityArgument());
  }

  @Test
  public void testMultiplictyParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = domainParserGrammar
        .multiplictyParameters();

    // Assert
    RecognitionException recognitionException = actualMultiplictyParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    assertNull(actualMultiplictyParametersResult.getParent());
    Token expectedStart = actualMultiplictyParametersResult.start;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualMultiplictyParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1417, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualMultiplictyParametersResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testMultiplictyParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.MultiplictyParametersContext actualMultiplictyParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).multiplictyParameters();

    // Assert
    assertEquals(-1, actualMultiplictyParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualMultiplictyParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualMultiplictyParametersResult.getParent());
    Token token = actualMultiplictyParametersResult.stop;
    Token start = actualMultiplictyParametersResult.getStart();
    assertSame(token, start);
    assertSame(token, actualMultiplictyParametersResult.getStop());
    assertEquals("<missing '|'><EOF>", actualMultiplictyParametersResult.getText());
    assertEquals(2, actualMultiplictyParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((DomainParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertSame(actualMultiplictyParametersResult, parseTreeList.get(0).getParent());
    assertEquals("<EOF>", getResult.getText());
  }

  @Test
  public void testMultiplictyParametersContextAccept() {
    // Arrange
    DomainParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new DomainParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.MultiplictyParametersContext multiplictyParametersContext = new DomainParserGrammar.MultiplictyParametersContext(
        new ParserRuleContext(), 1);
    multiplictyParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(multiplictyParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testMultiplictyParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testMultiplictyParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(130,
        (new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testMultiplictyParametersContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testMultiplictyParametersContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.MultiplictyParametersContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testNativeFunction() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.NativeFunctionContext actualNativeFunctionResult = domainParserGrammar.nativeFunction();

    // Assert
    RecognitionException recognitionException = actualNativeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualNativeFunctionResult.invokingState);
    assertNull(actualNativeFunctionResult.getParent());
    Token expectedStart = actualNativeFunctionResult.start;
    Token start = actualNativeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNativeFunctionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(588, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualNativeFunctionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testNativeFunction2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.NativeFunctionContext actualNativeFunctionResult = domainParserGrammar.nativeFunction();

    // Assert
    RecognitionException recognitionException = actualNativeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualNativeFunctionResult.children.size());
    assertNull(actualNativeFunctionResult.getParent());
    Token expectedStart = actualNativeFunctionResult.stop;
    Token start = actualNativeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualNativeFunctionResult.getStop());
    assertEquals("null", actualNativeFunctionResult.getText());
    assertEquals(1, actualNativeFunctionResult.getChildCount());
    assertTrue(actualNativeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(588, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualNativeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testNativeFunction3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(18));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.NativeFunctionContext actualNativeFunctionResult = domainParserGrammar.nativeFunction();

    // Assert
    RecognitionException recognitionException = actualNativeFunctionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualNativeFunctionResult.children.size());
    assertNull(actualNativeFunctionResult.getParent());
    Token expectedStart = actualNativeFunctionResult.stop;
    Token start = actualNativeFunctionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualNativeFunctionResult.getStop());
    assertEquals("null", actualNativeFunctionResult.getText());
    assertEquals(1, actualNativeFunctionResult.getChildCount());
    assertTrue(actualNativeFunctionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(589, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualNativeFunctionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testNativeFunctionContextAccept() {
    // Arrange
    DomainParserGrammar.NativeFunctionContext nativeFunctionContext = new DomainParserGrammar.NativeFunctionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(nativeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNativeFunctionContextAccept2() {
    // Arrange
    DomainParserGrammar.NativeFunctionContext nativeFunctionContext = new DomainParserGrammar.NativeFunctionContext(
        new ParserRuleContext(), 1);
    nativeFunctionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(nativeFunctionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNativeFunctionContextFUNCTION() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).FUNCTION());
  }

  @Test
  public void testNativeFunctionContextFunctionTypeSignature() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).functionTypeSignature());
  }

  @Test
  public void testNativeFunctionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(34, (new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testNativeFunctionContextNATIVE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).NATIVE());
  }

  @Test
  public void testNativeFunctionContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testNativeFunctionContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testNativeFunctionContextTypeAndMultiplicityParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.NativeFunctionContext(new ParserRuleContext(), 1)).typeAndMultiplicityParameters());
  }

  @Test
  public void testNonConvertibleMeasureExpr() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).nonConvertibleMeasureExpr();

    // Assert
    assertEquals(-1, actualNonConvertibleMeasureExprResult.invokingState);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token expectedStart = actualNonConvertibleMeasureExprResult.start;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNonConvertibleMeasureExprResult.getStop());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertNull(((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<missing ';'>", getResult.getText());
    assertEquals("<missing ';'>", getResult.toString());
    assertSame(actualNonConvertibleMeasureExprResult, getResult.getParent());
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
  }

  @Test
  public void testNonConvertibleMeasureExpr2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = domainParserGrammar
        .nonConvertibleMeasureExpr();

    // Assert
    RecognitionException recognitionException = actualNonConvertibleMeasureExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token expectedStart = actualNonConvertibleMeasureExprResult.start;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualNonConvertibleMeasureExprResult.stop;
    Token stop = actualNonConvertibleMeasureExprResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualNonConvertibleMeasureExprResult.getText());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertTrue(actualNonConvertibleMeasureExprResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(582, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualNonConvertibleMeasureExprResult, recognitionException.getCtx());
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testNonConvertibleMeasureExpr3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).nonConvertibleMeasureExpr();

    // Assert
    assertEquals(-1, actualNonConvertibleMeasureExprResult.invokingState);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals("([] [581] <missing ';'>)", actualNonConvertibleMeasureExprResult.toStringTree());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token expectedStart = actualNonConvertibleMeasureExprResult.start;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNonConvertibleMeasureExprResult.getStop());
    assertEquals("<missing ';'>", actualNonConvertibleMeasureExprResult.getText());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testNonConvertibleMeasureExpr4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = domainParserGrammar
        .nonConvertibleMeasureExpr();

    // Assert
    RecognitionException recognitionException = actualNonConvertibleMeasureExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token expectedStart = actualNonConvertibleMeasureExprResult.start;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualNonConvertibleMeasureExprResult.stop;
    Token stop = actualNonConvertibleMeasureExprResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("nullnull", actualNonConvertibleMeasureExprResult.getText());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertTrue(actualNonConvertibleMeasureExprResult.isEmpty());
    assertEquals(0, start.getTokenIndex());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(582, recognitionException.getOffendingState());
    assertSame(stop, recognitionException.getOffendingToken());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualNonConvertibleMeasureExprResult, recognitionException.getCtx());
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testNonConvertibleMeasureExpr5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = domainParserGrammar
        .nonConvertibleMeasureExpr();

    // Assert
    assertEquals(-1, actualNonConvertibleMeasureExprResult.invokingState);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals("([] ([581] ([1431 581] <EOF>)) <missing ';'>)", actualNonConvertibleMeasureExprResult.toStringTree());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token token = actualNonConvertibleMeasureExprResult.stop;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(token, start);
    assertSame(token, actualNonConvertibleMeasureExprResult.getStop());
    assertEquals("<EOF><missing ';'>", actualNonConvertibleMeasureExprResult.getText());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(1);
    assertEquals("<missing ';'>", getResult1.toString());
    assertSame(actualNonConvertibleMeasureExprResult, getResult1.getParent());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertEquals("<missing ';'>", getResult1.getText());
  }

  @Test
  public void testNonConvertibleMeasureExpr6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>(), "Source Name");

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.NonConvertibleMeasureExprContext actualNonConvertibleMeasureExprResult = domainParserGrammar
        .nonConvertibleMeasureExpr();

    // Assert
    assertEquals(-1, actualNonConvertibleMeasureExprResult.invokingState);
    List<ParseTree> parseTreeList = actualNonConvertibleMeasureExprResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNonConvertibleMeasureExprResult.getParent());
    Token expectedStart = actualNonConvertibleMeasureExprResult.start;
    Token start = actualNonConvertibleMeasureExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNonConvertibleMeasureExprResult.getStop());
    assertEquals(2, actualNonConvertibleMeasureExprResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    assertNull(((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals("<missing ';'>", getResult.getText());
    assertEquals("<missing ';'>", getResult.toString());
    assertSame(actualNonConvertibleMeasureExprResult, getResult.getParent());
    assertEquals(581, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).depth());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).getStart());
  }

  @Test
  public void testNonConvertibleMeasureExprContextAccept() {
    // Arrange
    DomainParserGrammar.NonConvertibleMeasureExprContext nonConvertibleMeasureExprContext = new DomainParserGrammar.NonConvertibleMeasureExprContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(nonConvertibleMeasureExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNonConvertibleMeasureExprContextAccept2() {
    // Arrange
    DomainParserGrammar.NonConvertibleMeasureExprContext nonConvertibleMeasureExprContext = new DomainParserGrammar.NonConvertibleMeasureExprContext(
        new ParserRuleContext(), 1);
    nonConvertibleMeasureExprContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(nonConvertibleMeasureExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNonConvertibleMeasureExprContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(32,
        (new DomainParserGrammar.NonConvertibleMeasureExprContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testNonConvertibleMeasureExprContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NonConvertibleMeasureExprContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testNonConvertibleMeasureExprContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NonConvertibleMeasureExprContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testNotExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.NotExpressionContext actualNotExpressionResult = domainParserGrammar.notExpression();

    // Assert
    RecognitionException recognitionException = actualNotExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualNotExpressionResult.invokingState);
    assertNull(actualNotExpressionResult.getParent());
    Token expectedStart = actualNotExpressionResult.start;
    Token start = actualNotExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualNotExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1180, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualNotExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testNotExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.NotExpressionContext actualNotExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).notExpression();

    // Assert
    assertEquals(-1, actualNotExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualNotExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualNotExpressionResult.getParent());
    Token token = actualNotExpressionResult.stop;
    Token start = actualNotExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualNotExpressionResult.getStop());
    assertEquals(2, actualNotExpressionResult.getChildCount());
    assertEquals("<missing '!'><EOF>", actualNotExpressionResult.getText());
    DomainParserGrammar.ExpressionContext expressionResult = actualNotExpressionResult.expression();
    assertEquals(1181, expressionResult.invokingState);
    List<ParseTree> parseTreeList1 = expressionResult.children;
    assertEquals(1, parseTreeList1.size());
    assertEquals("([1181] ([800 1181] ([1039 800 1181] ([1046 1039 800 1181] ([1431 1046 1039 800 1181] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualNotExpressionResult, parseTreeList.get(0).getParent());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) parseTreeList1.get(0)).invokingState);
  }

  @Test
  public void testNotExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.NotExpressionContext notExpressionContext = new DomainParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.NotExpressionContext notExpressionContext = new DomainParserGrammar.NotExpressionContext(
        new ParserRuleContext(), 1);
    notExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(notExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testNotExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testNotExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(101, (new DomainParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testNotExpressionContextNOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.NotExpressionContext(new ParserRuleContext(), 1)).NOT());
  }

  @Test
  public void testPackagePath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.PackagePathContext actualPackagePathResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).getStop());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPackagePath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.PackagePathContext actualPackagePathResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((DomainParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertNull(getResult1.toString());
  }

  @Test
  public void testPackagePath3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.PackagePathContext actualPackagePathResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((DomainParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePath4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.PackagePathContext actualPackagePathResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] [1433])", actualPackagePathResult.toStringTree());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.start;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(1433, ((DomainParserGrammar.IdentifierContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
  }

  @Test
  public void testPackagePath5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.PackagePathContext actualPackagePathResult = domainParserGrammar.packagePath();

    // Assert
    assertEquals(-1, actualPackagePathResult.invokingState);
    List<ParseTree> parseTreeList = actualPackagePathResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualPackagePathResult.getParent());
    Token expectedStart = actualPackagePathResult.stop;
    Token start = actualPackagePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPackagePathResult.getStop());
    assertEquals(1, actualPackagePathResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.IdentifierContext) getResult).depth());
    assertFalse(((DomainParserGrammar.IdentifierContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.IdentifierContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.IdentifierContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertSame(getResult, getResult1.getParent());
    assertEquals("Input", getResult1.toString());
  }

  @Test
  public void testPackagePathContextAccept() {
    // Arrange
    DomainParserGrammar.PackagePathContext packagePathContext = new DomainParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextAccept2() {
    // Arrange
    DomainParserGrammar.PackagePathContext packagePathContext = new DomainParserGrammar.PackagePathContext(
        new ParserRuleContext(), 1);
    packagePathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(packagePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPackagePathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(132, (new DomainParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPackagePathContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new DomainParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testPackagePathContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR().isEmpty());
    assertNull((new DomainParserGrammar.PackagePathContext(new ParserRuleContext(), 1)).PATH_SEPARATOR(1));
  }

  @Test
  public void testProfile() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ProfileContext actualProfileResult = domainParserGrammar.profile();

    // Assert
    RecognitionException recognitionException = actualProfileResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProfileResult.invokingState);
    assertNull(actualProfileResult.getParent());
    Token expectedStart = actualProfileResult.start;
    Token start = actualProfileResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProfileResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(441, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProfileResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProfile2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ProfileContext actualProfileResult = domainParserGrammar.profile();

    // Assert
    RecognitionException recognitionException = actualProfileResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualProfileResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualProfileResult.getParent());
    Token expectedStart = actualProfileResult.stop;
    Token start = actualProfileResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProfileResult.getStop());
    assertEquals("<missing 'Profile'><EOF>", actualProfileResult.getText());
    assertEquals(2, actualProfileResult.getChildCount());
    assertTrue(actualProfileResult.isEmpty());
    assertEquals("([] <missing 'Profile'> ([442] ([1431 442] <EOF>)))", actualProfileResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(443, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualProfileResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(442, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testProfileContextAccept() {
    // Arrange
    DomainParserGrammar.ProfileContext profileContext = new DomainParserGrammar.ProfileContext(new ParserRuleContext(),
        1);

    // Act and Assert
    assertNull(profileContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProfileContextAccept2() {
    // Arrange
    DomainParserGrammar.ProfileContext profileContext = new DomainParserGrammar.ProfileContext(new ParserRuleContext(),
        1);
    profileContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(profileContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProfileContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testProfileContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testProfileContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(19, (new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testProfileContextPROFILE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).PROFILE());
  }

  @Test
  public void testProfileContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testProfileContextStereotypeDefinitions() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).stereotypeDefinitions());
  }

  @Test
  public void testProfileContextTagDefinitions() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProfileContext(new ParserRuleContext(), 1)).tagDefinitions());
  }

  @Test
  public void testProgramLine() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(939, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine10() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(939, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLine2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(72));

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertNull(((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals("([937] ([960 937] [967 960 937]))", getResult.toStringTree());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertNull(((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals("[960 937]", getResult1.toString());
  }

  @Test
  public void testProgramLine4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine5() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    assertEquals(-1, actualProgramLineResult.invokingState);
    List<ParseTree> parseTreeList = actualProgramLineResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.stop;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualProgramLineResult.getStop());
    assertEquals(1, actualProgramLineResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualProgramLineResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testProgramLine9() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ProgramLineContext actualProgramLineResult = domainParserGrammar.programLine();

    // Assert
    RecognitionException recognitionException = actualProgramLineResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProgramLineResult.invokingState);
    assertNull(actualProgramLineResult.getParent());
    Token expectedStart = actualProgramLineResult.start;
    Token start = actualProgramLineResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProgramLineResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(939, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualProgramLineResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProgramLineContextAccept() {
    // Arrange
    DomainParserGrammar.ProgramLineContext programLineContext = new DomainParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextAccept2() {
    // Arrange
    DomainParserGrammar.ProgramLineContext programLineContext = new DomainParserGrammar.ProgramLineContext(
        new ParserRuleContext(), 1);
    programLineContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(programLineContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProgramLineContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testProgramLineContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(72, (new DomainParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testProgramLineContextLetExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProgramLineContext(new ParserRuleContext(), 1)).letExpression());
  }

  @Test
  public void testProjection() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ProjectionContext actualProjectionResult = domainParserGrammar.projection();

    // Assert
    RecognitionException recognitionException = actualProjectionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualProjectionResult.invokingState);
    assertNull(actualProjectionResult.getParent());
    Token expectedStart = actualProjectionResult.start;
    Token start = actualProjectionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualProjectionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(696, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualProjectionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testProjection2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.ProjectionContext actualProjectionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).projection();

    // Assert
    assertEquals(-1, actualProjectionResult.invokingState);
    List<ParseTree> parseTreeList = actualProjectionResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualProjectionResult.getParent());
    assertNull(actualProjectionResult.dsl());
    Token token = actualProjectionResult.stop;
    Token start = actualProjectionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualProjectionResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TreePathContext) getResult).alias());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TreePathContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TreePathContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TreePathContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TreePathContext) getResult).getStop());
    RecognitionException recognitionException = ((DomainParserGrammar.TreePathContext) getResult).exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, ((DomainParserGrammar.TreePathContext) getResult).children.size());
    assertEquals(700, recognitionException.getOffendingState());
    assertEquals(698, ((DomainParserGrammar.TreePathContext) getResult).type().invokingState);
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(getResult, recognitionException.getCtx());
  }

  @Test
  public void testProjectionContextAccept() {
    // Arrange
    DomainParserGrammar.ProjectionContext projectionContext = new DomainParserGrammar.ProjectionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(projectionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProjectionContextAccept2() {
    // Arrange
    DomainParserGrammar.ProjectionContext projectionContext = new DomainParserGrammar.ProjectionContext(
        new ParserRuleContext(), 1);
    projectionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(projectionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testProjectionContextDsl() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProjectionContext(new ParserRuleContext(), 1)).dsl());
  }

  @Test
  public void testProjectionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(48, (new DomainParserGrammar.ProjectionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testProjectionContextTreePath() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ProjectionContext(new ParserRuleContext(), 1)).treePath());
  }

  @Test
  public void testProperties() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.PropertiesContext actualPropertiesResult = domainParserGrammar.properties();

    // Assert
    assertEquals(-1, actualPropertiesResult.invokingState);
    assertNull(actualPropertiesResult.getParent());
    Token expectedStart = actualPropertiesResult.start;
    Token start = actualPropertiesResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertiesResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testProperties2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertiesContext actualPropertiesResult = domainParserGrammar.properties();

    // Assert
    RecognitionException recognitionException = actualPropertiesResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    assertEquals(1, actualPropertiesResult.children.size());
    assertNull(actualPropertiesResult.getParent());
    Token token = actualPropertiesResult.stop;
    assertSame(token, actualPropertiesResult.getStart());
    Token stop = actualPropertiesResult.getStop();
    assertSame(token, stop);
    assertEquals("null", actualPropertiesResult.getText());
    assertEquals(1, actualPropertiesResult.getChildCount());
    assertTrue(actualPropertiesResult.isEmpty());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(337, recognitionException.getOffendingState());
    assertSame(stop, ((NoViableAltException) recognitionException).getStartToken());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(0, stop.getTokenIndex());
    assertSame(actualPropertiesResult, recognitionException.getCtx());
  }

  @Test
  public void testProperties3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(0));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)));

    // Act
    DomainParserGrammar.PropertiesContext actualPropertiesResult = domainParserGrammar.properties();

    // Assert
    assertEquals(-1, actualPropertiesResult.invokingState);
    assertNull(actualPropertiesResult.getParent());
    Token expectedStart = actualPropertiesResult.start;
    Token start = actualPropertiesResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertiesResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testPropertiesContextAccept() {
    // Arrange
    DomainParserGrammar.PropertiesContext propertiesContext = new DomainParserGrammar.PropertiesContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertiesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertiesContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertiesContext propertiesContext = new DomainParserGrammar.PropertiesContext(
        new ParserRuleContext(), 1);
    propertiesContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertiesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertiesContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(7, (new DomainParserGrammar.PropertiesContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertiesContextProperty() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertiesContext(new ParserRuleContext(), 1)).property().isEmpty());
    assertNull((new DomainParserGrammar.PropertiesContext(new ParserRuleContext(), 1)).property(1));
  }

  @Test
  public void testPropertiesContextQualifiedProperty() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertiesContext(new ParserRuleContext(), 1)).qualifiedProperty().isEmpty());
    assertNull((new DomainParserGrammar.PropertiesContext(new ParserRuleContext(), 1)).qualifiedProperty(1));
  }

  @Test
  public void testProperty() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyContext actualPropertyResult = domainParserGrammar.property();

    // Assert
    RecognitionException recognitionException = actualPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyResult.invokingState);
    assertEquals(1, actualPropertyResult.depth());
    Token expectedStart = actualPropertyResult.start;
    Token start = actualPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualPropertyResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1, start.getLine());
    assertEquals(343, recognitionException.getOffendingState());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testProperty2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyContext actualPropertyResult = domainParserGrammar.property();

    // Assert
    assertNull(actualPropertyResult.stereotypes());
    RecognitionException recognitionException = actualPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyResult.children.size());
    assertEquals(1, actualPropertyResult.depth());
    assertEquals(-1, actualPropertyResult.invokingState);
    Token expectedStart = actualPropertyResult.stop;
    Token start = actualPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyResult.getStop());
    assertEquals("null", actualPropertyResult.getText());
    assertEquals(0, start.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyResult.identifier();
    assertEquals(351, identifierResult.invokingState);
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualPropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(352, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualPropertyResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
  }

  @Test
  public void testProperty3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.PropertyContext actualPropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).property();

    // Assert
    assertNull(actualPropertyResult.stereotypes());
    assertEquals(-1, actualPropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualPropertyResult.children;
    assertEquals(4, parseTreeList.size());
    assertEquals(1, actualPropertyResult.depth());
    Token expectedStart = actualPropertyResult.start;
    Token start = actualPropertyResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPropertyResult.stop;
    Token stop = actualPropertyResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing ':'><EOF><missing ';'>", actualPropertyResult.getText());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyResult.identifier();
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("null", identifierResult.getText());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(353, ((DomainParserGrammar.PropertyReturnTypeContext) parseTreeList.get(2)).invokingState);
  }

  @Test
  public void testPropertyBracketExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = domainParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyBracketExpressionResult.invokingState);
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.start;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyBracketExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(993, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyBracketExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = domainParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(993, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpression3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(57));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyBracketExpressionContext actualPropertyBracketExpressionResult = domainParserGrammar
        .propertyBracketExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyBracketExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualPropertyBracketExpressionResult.children.size());
    assertNull(actualPropertyBracketExpressionResult.getParent());
    Token expectedStart = actualPropertyBracketExpressionResult.stop;
    Token start = actualPropertyBracketExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualPropertyBracketExpressionResult.getStop());
    assertEquals("null", actualPropertyBracketExpressionResult.getText());
    assertEquals(1, actualPropertyBracketExpressionResult.getChildCount());
    assertTrue(actualPropertyBracketExpressionResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(994, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualPropertyBracketExpressionResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testPropertyBracketExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new DomainParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyBracketExpressionContext propertyBracketExpressionContext = new DomainParserGrammar.PropertyBracketExpressionContext(
        new ParserRuleContext(), 1);
    propertyBracketExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyBracketExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testPropertyBracketExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testPropertyBracketExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(82,
        (new DomainParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyBracketExpressionContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testPropertyBracketExpressionContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyBracketExpressionContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testPropertyContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyContext propertyContext = new DomainParserGrammar.PropertyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyContext propertyContext = new DomainParserGrammar.PropertyContext(
        new ParserRuleContext(), 1);
    propertyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyContextAggregation() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).aggregation());
  }

  @Test
  public void testPropertyContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testPropertyContextDefaultValue() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).defaultValue());
  }

  @Test
  public void testPropertyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(8, (new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyContextPropertyReturnType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).propertyReturnType());
  }

  @Test
  public void testPropertyContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testPropertyContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testPropertyContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testPropertyExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = domainParserGrammar
        .propertyExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    assertNull(actualPropertyExpressionResult.getParent());
    Token expectedStart = actualPropertyExpressionResult.start;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyExpressionResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(987, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualPropertyExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testPropertyExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.PropertyExpressionContext actualPropertyExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyExpression();

    // Assert
    assertEquals(-1, actualPropertyExpressionResult.invokingState);
    List<ParseTree> parseTreeList = actualPropertyExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualPropertyExpressionResult.getParent());
    Token token = actualPropertyExpressionResult.stop;
    Token start = actualPropertyExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualPropertyExpressionResult.getStop());
    assertEquals("<missing '.'><EOF>", actualPropertyExpressionResult.getText());
    assertEquals(2, actualPropertyExpressionResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyExpressionResult.identifier();
    assertEquals(988, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualPropertyExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testPropertyExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyExpressionContext propertyExpressionContext = new DomainParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyExpressionContext propertyExpressionContext = new DomainParserGrammar.PropertyExpressionContext(
        new ParserRuleContext(), 1);
    propertyExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyExpressionContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionLatestMilestoningDateParameter() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1))
        .functionExpressionLatestMilestoningDateParameter());
  }

  @Test
  public void testPropertyExpressionContextFunctionExpressionParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).functionExpressionParameters());
  }

  @Test
  public void testPropertyExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(81, (new DomainParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyExpressionContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyExpressionContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyOrFunctionExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.PropertyOrFunctionExpressionContext actualPropertyOrFunctionExpressionResult = domainParserGrammar
        .propertyOrFunctionExpression();

    // Assert
    RecognitionException recognitionException = actualPropertyOrFunctionExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualPropertyOrFunctionExpressionResult.invokingState);
    assertNull(actualPropertyOrFunctionExpressionResult.getParent());
    Token expectedStart = actualPropertyOrFunctionExpressionResult.start;
    Token start = actualPropertyOrFunctionExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyOrFunctionExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(985, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualPropertyOrFunctionExpressionResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new DomainParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyOrFunctionExpressionContext propertyOrFunctionExpressionContext = new DomainParserGrammar.PropertyOrFunctionExpressionContext(
        new ParserRuleContext(), 1);
    propertyOrFunctionExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyOrFunctionExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyOrFunctionExpressionContextFunctionExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1)).functionExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(80,
        (new DomainParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyBracketExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1))
        .propertyBracketExpression());
  }

  @Test
  public void testPropertyOrFunctionExpressionContextPropertyExpression() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.PropertyOrFunctionExpressionContext(new ParserRuleContext(), 1)).propertyExpression());
  }

  @Test
  public void testPropertyRef() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.PropertyRefContext actualPropertyRefResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).propertyRef();

    // Assert
    assertEquals(-1, actualPropertyRefResult.invokingState);
    assertEquals(1, actualPropertyRefResult.children.size());
    assertNull(actualPropertyRefResult.getParent());
    Token expectedStart = actualPropertyRefResult.start;
    Token start = actualPropertyRefResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyRefResult.getStop());
    assertEquals(1, actualPropertyRefResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyRefResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertFalse(identifierResult.isEmpty());
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testPropertyRef2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.PropertyRefContext actualPropertyRefResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyRef();

    // Assert
    assertEquals(-1, actualPropertyRefResult.invokingState);
    assertEquals(1, actualPropertyRefResult.children.size());
    assertNull(actualPropertyRefResult.getParent());
    Token token = actualPropertyRefResult.stop;
    assertSame(token, actualPropertyRefResult.getStart());
    Token stop = actualPropertyRefResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualPropertyRefResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyRefResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testPropertyRef3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.PropertyRefContext actualPropertyRefResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).propertyRef();

    // Assert
    assertEquals(-1, actualPropertyRefResult.invokingState);
    assertEquals(1, actualPropertyRefResult.children.size());
    assertNull(actualPropertyRefResult.getParent());
    Token token = actualPropertyRefResult.stop;
    assertSame(token, actualPropertyRefResult.getStart());
    Token stop = actualPropertyRefResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualPropertyRefResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyRefResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testPropertyRef4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.PropertyRefContext actualPropertyRefResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).propertyRef();

    // Assert
    assertEquals(-1, actualPropertyRefResult.invokingState);
    assertEquals(1, actualPropertyRefResult.children.size());
    assertNull(actualPropertyRefResult.getParent());
    Token expectedStart = actualPropertyRefResult.start;
    Token start = actualPropertyRefResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyRefResult.getStop());
    assertEquals(1, actualPropertyRefResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyRefResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(778, identifierResult.invokingState);
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testPropertyRef5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.PropertyRefContext actualPropertyRefResult = domainParserGrammar.propertyRef();

    // Assert
    assertEquals(-1, actualPropertyRefResult.invokingState);
    assertEquals(1, actualPropertyRefResult.children.size());
    assertNull(actualPropertyRefResult.getParent());
    Token token = actualPropertyRefResult.stop;
    assertSame(token, actualPropertyRefResult.getStart());
    Token stop = actualPropertyRefResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualPropertyRefResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualPropertyRefResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testPropertyRefContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyRefContext propertyRefContext = new DomainParserGrammar.PropertyRefContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyRefContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyRefContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyRefContext propertyRefContext = new DomainParserGrammar.PropertyRefContext(
        new ParserRuleContext(), 1);
    propertyRefContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyRefContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyRefContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testPropertyRefContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(56, (new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyRefContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testPropertyRefContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).PAREN_CLOSE().isEmpty());
    assertNull((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).PAREN_CLOSE(1));
  }

  @Test
  public void testPropertyRefContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).PAREN_OPEN().isEmpty());
    assertNull((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).PAREN_OPEN(1));
  }

  @Test
  public void testPropertyRefContextTreePathPropertyParameterType() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).treePathPropertyParameterType()
        .isEmpty());
    assertNull(
        (new DomainParserGrammar.PropertyRefContext(new ParserRuleContext(), 1)).treePathPropertyParameterType(1));
  }

  @Test
  public void testPropertyReturnType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualPropertyReturnTypeResult.getStop());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertEquals(923, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(922, typeResult.invokingState);
    assertEquals(2, typeResult.depth());
    assertNull(typeResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getType());
    assertSame(start, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertNull(multiplicityResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
  }

  @Test
  public void testPropertyReturnType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token token = actualPropertyReturnTypeResult.stop;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualPropertyReturnTypeResult.getStop());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertEquals(923, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[923]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    DomainParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(1, typeResult.getChildCount());
    assertEquals(922, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testPropertyReturnType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    assertSame(expectedStop, actualPropertyReturnTypeResult.getStop());
    assertEquals("null<missing '['><EOF><missing ']'>", actualPropertyReturnTypeResult.getText());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    assertEquals(923, actualPropertyReturnTypeResult.multiplicity().invokingState);
    DomainParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(922, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testPropertyReturnType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.PropertyReturnTypeContext actualPropertyReturnTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).propertyReturnType();

    // Assert
    assertEquals(-1, actualPropertyReturnTypeResult.invokingState);
    assertEquals(2, actualPropertyReturnTypeResult.children.size());
    assertNull(actualPropertyReturnTypeResult.getParent());
    Token expectedStart = actualPropertyReturnTypeResult.start;
    Token start = actualPropertyReturnTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualPropertyReturnTypeResult.stop;
    assertSame(expectedStop, actualPropertyReturnTypeResult.getStop());
    assertEquals("null<missing '['><EOF>null", actualPropertyReturnTypeResult.getText());
    assertEquals(2, actualPropertyReturnTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualPropertyReturnTypeResult.multiplicity();
    assertEquals(923, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualPropertyReturnTypeResult.type();
    assertEquals(922, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testPropertyReturnTypeContextAccept() {
    // Arrange
    DomainParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new DomainParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.PropertyReturnTypeContext propertyReturnTypeContext = new DomainParserGrammar.PropertyReturnTypeContext(
        new ParserRuleContext(), 1);
    propertyReturnTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(propertyReturnTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testPropertyReturnTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(70, (new DomainParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testPropertyReturnTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testPropertyReturnTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.PropertyReturnTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testQualifiedName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = domainParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1429, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = domainParserGrammar.qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = domainParserGrammar.qualifiedName();

    // Assert
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertEquals(1, actualQualifiedNameResult.children.size());
    assertNull(actualQualifiedNameResult.getParent());
    Token token = actualQualifiedNameResult.stop;
    assertSame(token, actualQualifiedNameResult.getStart());
    Token stop = actualQualifiedNameResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualQualifiedNameResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedNameResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testQualifiedName7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = domainParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1429, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedName8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedNameContext actualQualifiedNameResult = domainParserGrammar.qualifiedName();

    // Assert
    RecognitionException recognitionException = actualQualifiedNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedNameResult.invokingState);
    assertNull(actualQualifiedNameResult.getParent());
    Token expectedStart = actualQualifiedNameResult.start;
    Token start = actualQualifiedNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedNameResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1429, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualQualifiedNameResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedNameContextAccept() {
    // Arrange
    DomainParserGrammar.QualifiedNameContext qualifiedNameContext = new DomainParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextAccept2() {
    // Arrange
    DomainParserGrammar.QualifiedNameContext qualifiedNameContext = new DomainParserGrammar.QualifiedNameContext(
        new ParserRuleContext(), 1);
    qualifiedNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(qualifiedNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(131, (new DomainParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testQualifiedNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testQualifiedNameContextPATH_SEPARATOR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).PATH_SEPARATOR());
  }

  @Test
  public void testQualifiedNameContextPackagePath() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedNameContext(new ParserRuleContext(), 1)).packagePath());
  }

  @Test
  public void testQualifiedProperty() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedPropertyContext actualQualifiedPropertyResult = domainParserGrammar
        .qualifiedProperty();

    // Assert
    RecognitionException recognitionException = actualQualifiedPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedPropertyResult.invokingState);
    assertEquals(1, actualQualifiedPropertyResult.depth());
    Token expectedStart = actualQualifiedPropertyResult.start;
    Token start = actualQualifiedPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedPropertyResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualQualifiedPropertyResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(360, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testQualifiedProperty2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedPropertyContext actualQualifiedPropertyResult = domainParserGrammar
        .qualifiedProperty();

    // Assert
    assertNull(actualQualifiedPropertyResult.stereotypes());
    RecognitionException recognitionException = actualQualifiedPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualQualifiedPropertyResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualQualifiedPropertyResult.depth());
    Token expectedStart = actualQualifiedPropertyResult.stop;
    Token start = actualQualifiedPropertyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualQualifiedPropertyResult.getStop());
    assertEquals("null", actualQualifiedPropertyResult.getText());
    assertTrue(actualQualifiedPropertyResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualQualifiedPropertyResult.identifier();
    assertEquals(365, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(367, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualQualifiedPropertyResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertTrue(((DomainParserGrammar.QualifiedPropertyBodyContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(366, ((DomainParserGrammar.QualifiedPropertyBodyContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testQualifiedProperty3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedPropertyContext actualQualifiedPropertyResult = domainParserGrammar
        .qualifiedProperty();

    // Assert
    assertNull(actualQualifiedPropertyResult.stereotypes());
    RecognitionException recognitionException = actualQualifiedPropertyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualQualifiedPropertyResult.children;
    assertEquals(2, parseTreeList.size());
    assertEquals(1, actualQualifiedPropertyResult.depth());
    Token expectedStart = actualQualifiedPropertyResult.start;
    Token start = actualQualifiedPropertyResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualQualifiedPropertyResult.stop;
    Token stop = actualQualifiedPropertyResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '('><EOF>", actualQualifiedPropertyResult.getText());
    assertTrue(actualQualifiedPropertyResult.isEmpty());
    assertEquals(365, actualQualifiedPropertyResult.identifier().invokingState);
    assertEquals(367, recognitionException.getOffendingState());
    assertSame(actualQualifiedPropertyResult, recognitionException.getCtx());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(0, start.getTokenIndex());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertTrue(((DomainParserGrammar.QualifiedPropertyBodyContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(366, ((DomainParserGrammar.QualifiedPropertyBodyContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testQualifiedPropertyBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedPropertyBodyContext actualQualifiedPropertyBodyResult = domainParserGrammar
        .qualifiedPropertyBody();

    // Assert
    RecognitionException recognitionException = actualQualifiedPropertyBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualQualifiedPropertyBodyResult.invokingState);
    assertNull(actualQualifiedPropertyBodyResult.getParent());
    Token expectedStart = actualQualifiedPropertyBodyResult.start;
    Token start = actualQualifiedPropertyBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualQualifiedPropertyBodyResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(371, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualQualifiedPropertyBodyResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testQualifiedPropertyBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.QualifiedPropertyBodyContext actualQualifiedPropertyBodyResult = domainParserGrammar
        .qualifiedPropertyBody();

    // Assert
    RecognitionException recognitionException = actualQualifiedPropertyBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualQualifiedPropertyBodyResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualQualifiedPropertyBodyResult.getParent());
    Token expectedStart = actualQualifiedPropertyBodyResult.stop;
    Token start = actualQualifiedPropertyBodyResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualQualifiedPropertyBodyResult.getStop());
    assertEquals("<missing '('><EOF>", actualQualifiedPropertyBodyResult.getText());
    assertEquals(2, actualQualifiedPropertyBodyResult.getChildCount());
    assertTrue(actualQualifiedPropertyBodyResult.isEmpty());
    assertEquals("([] <missing '('> ([372] ([1287 372] <EOF>)))", actualQualifiedPropertyBodyResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(382, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualQualifiedPropertyBodyResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertTrue(((DomainParserGrammar.FunctionVariableExpressionContext) parseTreeList
        .get(1)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(372, ((DomainParserGrammar.FunctionVariableExpressionContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testQualifiedPropertyBodyContextAccept() {
    // Arrange
    DomainParserGrammar.QualifiedPropertyBodyContext qualifiedPropertyBodyContext = new DomainParserGrammar.QualifiedPropertyBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(qualifiedPropertyBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedPropertyBodyContextAccept2() {
    // Arrange
    DomainParserGrammar.QualifiedPropertyBodyContext qualifiedPropertyBodyContext = new DomainParserGrammar.QualifiedPropertyBodyContext(
        new ParserRuleContext(), 1);
    qualifiedPropertyBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(qualifiedPropertyBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedPropertyBodyContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testQualifiedPropertyBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testQualifiedPropertyBodyContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testQualifiedPropertyBodyContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testQualifiedPropertyBodyContextFunctionVariableExpression() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).functionVariableExpression()
            .isEmpty());
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1))
        .functionVariableExpression(1));
  }

  @Test
  public void testQualifiedPropertyBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(10, (new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testQualifiedPropertyBodyContextPAREN_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).PAREN_CLOSE());
  }

  @Test
  public void testQualifiedPropertyBodyContextPAREN_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyBodyContext(new ParserRuleContext(), 1)).PAREN_OPEN());
  }

  @Test
  public void testQualifiedPropertyContextAccept() {
    // Arrange
    DomainParserGrammar.QualifiedPropertyContext qualifiedPropertyContext = new DomainParserGrammar.QualifiedPropertyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(qualifiedPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedPropertyContextAccept2() {
    // Arrange
    DomainParserGrammar.QualifiedPropertyContext qualifiedPropertyContext = new DomainParserGrammar.QualifiedPropertyContext(
        new ParserRuleContext(), 1);
    qualifiedPropertyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(qualifiedPropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testQualifiedPropertyContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testQualifiedPropertyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(9, (new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testQualifiedPropertyContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testQualifiedPropertyContextPropertyReturnType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).propertyReturnType());
  }

  @Test
  public void testQualifiedPropertyContextQualifiedPropertyBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).qualifiedPropertyBody());
  }

  @Test
  public void testQualifiedPropertyContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testQualifiedPropertyContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testQualifiedPropertyContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.QualifiedPropertyContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testSignedExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.SignedExpressionContext actualSignedExpressionResult = domainParserGrammar.signedExpression();

    // Assert
    RecognitionException recognitionException = actualSignedExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertNull(actualSignedExpressionResult.getParent());
    Token expectedStart = actualSignedExpressionResult.start;
    Token start = actualSignedExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSignedExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1183, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertSame(actualSignedExpressionResult, recognitionException.getCtx());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSignedExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.SignedExpressionContext actualSignedExpressionResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).signedExpression();

    // Assert
    assertEquals(-1, actualSignedExpressionResult.invokingState);
    assertEquals(1, actualSignedExpressionResult.children.size());
    assertNull(actualSignedExpressionResult.getParent());
    Token token = actualSignedExpressionResult.stop;
    Token start = actualSignedExpressionResult.getStart();
    assertSame(token, start);
    assertSame(token, actualSignedExpressionResult.getStop());
    assertEquals(1, actualSignedExpressionResult.getChildCount());
    DomainParserGrammar.ExpressionContext expressionResult = actualSignedExpressionResult.expression();
    assertEquals(1184, expressionResult.invokingState);
    List<ParseTree> parseTreeList = expressionResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([1184] ([800 1184] ([1039 800 1184] ([1046 1039 800 1184] ([1431 1046 1039 800 1184] <EOF>)))))",
        expressionResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", expressionResult.getText());
    assertSame(start, expressionResult.getStart());
    assertEquals(2, expressionResult.depth());
    assertSame(start, expressionResult.getStop());
    assertEquals(1, expressionResult.getChildCount());
    assertEquals(800, ((DomainParserGrammar.AtomicExpressionContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testSignedExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.SignedExpressionContext signedExpressionContext = new DomainParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.SignedExpressionContext signedExpressionContext = new DomainParserGrammar.SignedExpressionContext(
        new ParserRuleContext(), 1);
    signedExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(signedExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSignedExpressionContextExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).expression());
  }

  @Test
  public void testSignedExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(102, (new DomainParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSignedExpressionContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testSignedExpressionContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SignedExpressionContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testSimpleConstraint() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    RecognitionException recognitionException = actualSimpleConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.start;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimpleConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(648, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSimpleConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testSimpleConstraint10() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    RecognitionException recognitionException = actualSimpleConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.start;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimpleConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(648, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSimpleConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testSimpleConstraint11() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    RecognitionException recognitionException = actualSimpleConstraintResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.start;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimpleConstraintResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(648, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSimpleConstraintResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testSimpleConstraint2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(78));

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(39));

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint6() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint8() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraint9() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.SimpleConstraintContext actualSimpleConstraintResult = domainParserGrammar.simpleConstraint();

    // Assert
    assertEquals(-1, actualSimpleConstraintResult.invokingState);
    List<ParseTree> parseTreeList = actualSimpleConstraintResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimpleConstraintResult.getParent());
    Token expectedStart = actualSimpleConstraintResult.stop;
    Token start = actualSimpleConstraintResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualSimpleConstraintResult.getStop());
    assertEquals(1, actualSimpleConstraintResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.CombinedExpressionContext) getResult).depth());
    assertFalse(((DomainParserGrammar.CombinedExpressionContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.CombinedExpressionContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.CombinedExpressionContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals(960, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).invokingState);
    assertEquals(3, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).depth());
    Interval expectedSourceInterval = actualSimpleConstraintResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
    assertSame(start, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).getStop());
    assertEquals(1, getResult1.getChildCount());
    assertEquals(967, ((DomainParserGrammar.ExpressionOrExpressionGroupContext) getResult1).expression().invokingState);
  }

  @Test
  public void testSimpleConstraintContextAccept() {
    // Arrange
    DomainParserGrammar.SimpleConstraintContext simpleConstraintContext = new DomainParserGrammar.SimpleConstraintContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(simpleConstraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimpleConstraintContextAccept2() {
    // Arrange
    DomainParserGrammar.SimpleConstraintContext simpleConstraintContext = new DomainParserGrammar.SimpleConstraintContext(
        new ParserRuleContext(), 1);
    simpleConstraintContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(simpleConstraintContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimpleConstraintContextCombinedExpression() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimpleConstraintContext(new ParserRuleContext(), 1)).combinedExpression());
  }

  @Test
  public void testSimpleConstraintContextConstraintId() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimpleConstraintContext(new ParserRuleContext(), 1)).constraintId());
  }

  @Test
  public void testSimpleConstraintContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(39, (new DomainParserGrammar.SimpleConstraintContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSimpleProperty() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.SimplePropertyContext actualSimplePropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).simpleProperty();

    // Assert
    assertNull(actualSimplePropertyResult.stereotypes());
    assertEquals(-1, actualSimplePropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualSimplePropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimplePropertyResult.getParent());
    Token expectedStart = actualSimplePropertyResult.start;
    Token start = actualSimplePropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimplePropertyResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(741, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals(1, getResult.getChildCount());
    assertSame(start, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    assertNull(((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertEquals("[778 741]", identifierResult.toString());
    assertEquals(778, identifierResult.invokingState);
  }

  @Test
  public void testSimpleProperty2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.SimplePropertyContext actualSimplePropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).simpleProperty();

    // Assert
    assertNull(actualSimplePropertyResult.stereotypes());
    assertEquals(-1, actualSimplePropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualSimplePropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimplePropertyResult.getParent());
    Token token = actualSimplePropertyResult.stop;
    assertSame(token, actualSimplePropertyResult.getStart());
    Token stop = actualSimplePropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(741, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("null", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    assertEquals("[778 741]", identifierResult.toString());
    Interval expectedSourceInterval = actualSimplePropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
  }

  @Test
  public void testSimpleProperty3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.SimplePropertyContext actualSimplePropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).simpleProperty();

    // Assert
    assertNull(actualSimplePropertyResult.stereotypes());
    assertEquals(-1, actualSimplePropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualSimplePropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimplePropertyResult.getParent());
    Token token = actualSimplePropertyResult.stop;
    assertSame(token, actualSimplePropertyResult.getStart());
    Token stop = actualSimplePropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    assertEquals("Input", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(0, stop.getStartIndex());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    assertEquals(1, stop.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(741, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("Input", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualSimplePropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(stop, identifierResult.getStop());
    assertEquals("[778 741]", identifierResult.toString());
  }

  @Test
  public void testSimpleProperty4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.SimplePropertyContext actualSimplePropertyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).simpleProperty();

    // Assert
    assertNull(actualSimplePropertyResult.stereotypes());
    assertEquals(-1, actualSimplePropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualSimplePropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimplePropertyResult.getParent());
    Token expectedStart = actualSimplePropertyResult.start;
    Token start = actualSimplePropertyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimplePropertyResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(741, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals("([741] [778 741])", getResult.toStringTree());
    assertSame(start, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    assertNull(((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(778, ((DomainParserGrammar.PropertyRefContext) getResult).identifier().invokingState);
  }

  @Test
  public void testSimpleProperty5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.SimplePropertyContext actualSimplePropertyResult = domainParserGrammar.simpleProperty();

    // Assert
    assertNull(actualSimplePropertyResult.stereotypes());
    assertEquals(-1, actualSimplePropertyResult.invokingState);
    List<ParseTree> parseTreeList = actualSimplePropertyResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualSimplePropertyResult.getParent());
    Token token = actualSimplePropertyResult.stop;
    assertSame(token, actualSimplePropertyResult.getStart());
    Token stop = actualSimplePropertyResult.getStop();
    assertSame(token, stop);
    assertEquals(0, stop.getTokenIndex());
    assertEquals("Input", stop.getText());
    assertNull(stop.getInputStream());
    assertEquals(0, stop.getCharPositionInLine());
    assertEquals(0, stop.getStartIndex());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    assertEquals(1, stop.getLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(741, ((DomainParserGrammar.PropertyRefContext) getResult).invokingState);
    assertEquals(1, ((DomainParserGrammar.PropertyRefContext) getResult).children.size());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStart());
    assertSame(stop, ((DomainParserGrammar.PropertyRefContext) getResult).getStop());
    assertEquals("Input", getResult.getText());
    assertEquals(1, getResult.getChildCount());
    assertEquals(2, ((DomainParserGrammar.PropertyRefContext) getResult).depth());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.PropertyRefContext) getResult)
        .identifier();
    assertFalse(identifierResult.isEmpty());
    Interval expectedSourceInterval = actualSimplePropertyResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(stop, identifierResult.getStop());
    assertEquals("[778 741]", identifierResult.toString());
  }

  @Test
  public void testSimplePropertyContextAccept() {
    // Arrange
    DomainParserGrammar.SimplePropertyContext simplePropertyContext = new DomainParserGrammar.SimplePropertyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(simplePropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimplePropertyContextAccept2() {
    // Arrange
    DomainParserGrammar.SimplePropertyContext simplePropertyContext = new DomainParserGrammar.SimplePropertyContext(
        new ParserRuleContext(), 1);
    simplePropertyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(simplePropertyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimplePropertyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(53, (new DomainParserGrammar.SimplePropertyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSimplePropertyContextPropertyRef() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyContext(new ParserRuleContext(), 1)).propertyRef());
  }

  @Test
  public void testSimplePropertyContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testSimplePropertyContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testSimplePropertyFilter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.SimplePropertyFilterContext actualSimplePropertyFilterResult = domainParserGrammar
        .simplePropertyFilter();

    // Assert
    RecognitionException recognitionException = actualSimplePropertyFilterResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSimplePropertyFilterResult.invokingState);
    assertNull(actualSimplePropertyFilterResult.getParent());
    Token expectedStart = actualSimplePropertyFilterResult.start;
    Token start = actualSimplePropertyFilterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSimplePropertyFilterResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(739, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSimplePropertyFilterResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testSimplePropertyFilterContextAccept() {
    // Arrange
    DomainParserGrammar.SimplePropertyFilterContext simplePropertyFilterContext = new DomainParserGrammar.SimplePropertyFilterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(simplePropertyFilterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimplePropertyFilterContextAccept2() {
    // Arrange
    DomainParserGrammar.SimplePropertyFilterContext simplePropertyFilterContext = new DomainParserGrammar.SimplePropertyFilterContext(
        new ParserRuleContext(), 1);
    simplePropertyFilterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(simplePropertyFilterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSimplePropertyFilterContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testSimplePropertyFilterContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testSimplePropertyFilterContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testSimplePropertyFilterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(52, (new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testSimplePropertyFilterContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testSimplePropertyFilterContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testSimplePropertyFilterContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testSimplePropertyFilterContextSimpleProperty() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).simpleProperty().isEmpty());
    assertNull((new DomainParserGrammar.SimplePropertyFilterContext(new ParserRuleContext(), 1)).simpleProperty(1));
  }

  @Test
  public void testSliceExpression() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.SliceExpressionContext actualSliceExpressionResult = domainParserGrammar.sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualSliceExpressionResult.invokingState);
    assertNull(actualSliceExpressionResult.getParent());
    Token expectedStart = actualSliceExpressionResult.start;
    Token start = actualSliceExpressionResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualSliceExpressionResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1163, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testSliceExpression2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.SliceExpressionContext actualSliceExpressionResult = domainParserGrammar.sliceExpression();

    // Assert
    RecognitionException recognitionException = actualSliceExpressionResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    List<ParseTree> parseTreeList = actualSliceExpressionResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualSliceExpressionResult.getParent());
    Token token = actualSliceExpressionResult.stop;
    assertSame(token, actualSliceExpressionResult.getStart());
    Token stop = actualSliceExpressionResult.getStop();
    assertSame(token, stop);
    assertEquals("<missing '['><EOF>", actualSliceExpressionResult.getText());
    assertEquals(2, actualSliceExpressionResult.getChildCount());
    assertTrue(actualSliceExpressionResult.isEmpty());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1176, recognitionException.getOffendingState());
    assertSame(stop, ((NoViableAltException) recognitionException).getStartToken());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualSliceExpressionResult, recognitionException.getCtx());
    assertEquals(0, stop.getTokenIndex());
    assertSame(actualSliceExpressionResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testSliceExpressionContextAccept() {
    // Arrange
    DomainParserGrammar.SliceExpressionContext sliceExpressionContext = new DomainParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextAccept2() {
    // Arrange
    DomainParserGrammar.SliceExpressionContext sliceExpressionContext = new DomainParserGrammar.SliceExpressionContext(
        new ParserRuleContext(), 1);
    sliceExpressionContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(sliceExpressionContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testSliceExpressionContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testSliceExpressionContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testSliceExpressionContextCOLON() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON().isEmpty());
    assertNull((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).COLON(1));
  }

  @Test
  public void testSliceExpressionContextExpression() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression().isEmpty());
    assertNull((new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).expression(1));
  }

  @Test
  public void testSliceExpressionContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(100, (new DomainParserGrammar.SliceExpressionContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotype() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeContext actualStereotypeResult = domainParserGrammar.stereotype();

    // Assert
    RecognitionException recognitionException = actualStereotypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeResult.getParent());
    Token expectedStart = actualStereotypeResult.start;
    Token start = actualStereotypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeResult.getStop());
    assertEquals(1, actualStereotypeResult.getChildCount());
    assertTrue(actualStereotypeResult.isEmpty());
    assertEquals("([] [497])", actualStereotypeResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualStereotypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(498, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(497, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testStereotype2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeContext actualStereotypeResult = domainParserGrammar.stereotype();

    // Assert
    RecognitionException recognitionException = actualStereotypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeResult.getParent());
    Token expectedStart = actualStereotypeResult.stop;
    Token start = actualStereotypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypeResult.getStop());
    assertEquals("null", actualStereotypeResult.getText());
    assertEquals(1, actualStereotypeResult.getChildCount());
    assertTrue(actualStereotypeResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(498, recognitionException.getOffendingState());
    assertSame(actualStereotypeResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(497, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotype3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.StereotypeContext actualStereotypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).stereotype();

    // Assert
    assertEquals(-1, actualStereotypeResult.invokingState);
    List<ParseTree> parseTreeList = actualStereotypeResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualStereotypeResult.getParent());
    Token expectedStart = actualStereotypeResult.start;
    Token start = actualStereotypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualStereotypeResult.stop;
    Token stop = actualStereotypeResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualStereotypeResult.getText());
    assertEquals(3, actualStereotypeResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualStereotypeResult.identifier();
    assertEquals(499, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(497, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeContextAccept() {
    // Arrange
    DomainParserGrammar.StereotypeContext stereotypeContext = new DomainParserGrammar.StereotypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeContextAccept2() {
    // Arrange
    DomainParserGrammar.StereotypeContext stereotypeContext = new DomainParserGrammar.StereotypeContext(
        new ParserRuleContext(), 1);
    stereotypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testStereotypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(23, (new DomainParserGrammar.StereotypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotypeContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testStereotypeContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testStereotypeDefinitions() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeDefinitionsContext actualStereotypeDefinitionsResult = domainParserGrammar
        .stereotypeDefinitions();

    // Assert
    RecognitionException recognitionException = actualStereotypeDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualStereotypeDefinitionsResult.invokingState);
    assertNull(actualStereotypeDefinitionsResult.getParent());
    Token expectedStart = actualStereotypeDefinitionsResult.start;
    Token start = actualStereotypeDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeDefinitionsResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(452, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualStereotypeDefinitionsResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testStereotypeDefinitions2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeDefinitionsContext actualStereotypeDefinitionsResult = domainParserGrammar
        .stereotypeDefinitions();

    // Assert
    RecognitionException recognitionException = actualStereotypeDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualStereotypeDefinitionsResult.children.size());
    assertNull(actualStereotypeDefinitionsResult.getParent());
    Token expectedStart = actualStereotypeDefinitionsResult.stop;
    Token start = actualStereotypeDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypeDefinitionsResult.getStop());
    assertEquals("null", actualStereotypeDefinitionsResult.getText());
    assertEquals(1, actualStereotypeDefinitionsResult.getChildCount());
    assertTrue(actualStereotypeDefinitionsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(452, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualStereotypeDefinitionsResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testStereotypeDefinitions3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(9));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeDefinitionsContext actualStereotypeDefinitionsResult = domainParserGrammar
        .stereotypeDefinitions();

    // Assert
    RecognitionException recognitionException = actualStereotypeDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualStereotypeDefinitionsResult.children.size());
    assertNull(actualStereotypeDefinitionsResult.getParent());
    Token expectedStart = actualStereotypeDefinitionsResult.stop;
    Token start = actualStereotypeDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypeDefinitionsResult.getStop());
    assertEquals("null", actualStereotypeDefinitionsResult.getText());
    assertEquals(1, actualStereotypeDefinitionsResult.getChildCount());
    assertTrue(actualStereotypeDefinitionsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(453, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualStereotypeDefinitionsResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testStereotypeDefinitionsContextAccept() {
    // Arrange
    DomainParserGrammar.StereotypeDefinitionsContext stereotypeDefinitionsContext = new DomainParserGrammar.StereotypeDefinitionsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypeDefinitionsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeDefinitionsContextAccept2() {
    // Arrange
    DomainParserGrammar.StereotypeDefinitionsContext stereotypeDefinitionsContext = new DomainParserGrammar.StereotypeDefinitionsContext(
        new ParserRuleContext(), 1);
    stereotypeDefinitionsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypeDefinitionsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeDefinitionsContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testStereotypeDefinitionsContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testStereotypeDefinitionsContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testStereotypeDefinitionsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testStereotypeDefinitionsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(20, (new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotypeDefinitionsContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testStereotypeDefinitionsContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testStereotypeDefinitionsContextSTEREOTYPES() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeDefinitionsContext(new ParserRuleContext(), 1)).STEREOTYPES());
  }

  @Test
  public void testStereotypeReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = domainParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypeReferenceResult.getStop());
    assertEquals(1, actualStereotypeReferenceResult.getChildCount());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    assertEquals("([] [914])", actualStereotypeReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(915, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(914, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testStereotypeReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = domainParserGrammar
        .stereotypeReference();

    // Assert
    RecognitionException recognitionException = actualStereotypeReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.stop;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypeReferenceResult.getStop());
    assertEquals("null", actualStereotypeReferenceResult.getText());
    assertEquals(1, actualStereotypeReferenceResult.getChildCount());
    assertTrue(actualStereotypeReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(915, recognitionException.getOffendingState());
    assertSame(actualStereotypeReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(914, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.StereotypeReferenceContext actualStereotypeReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).stereotypeReference();

    // Assert
    assertEquals(-1, actualStereotypeReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualStereotypeReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualStereotypeReferenceResult.getParent());
    Token expectedStart = actualStereotypeReferenceResult.start;
    Token start = actualStereotypeReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualStereotypeReferenceResult.stop;
    Token stop = actualStereotypeReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '@'><EOF>", actualStereotypeReferenceResult.getText());
    assertEquals(3, actualStereotypeReferenceResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualStereotypeReferenceResult.identifier();
    assertEquals(916, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(914, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testStereotypeReferenceContextAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).AT());
  }

  @Test
  public void testStereotypeReferenceContextAccept() {
    // Arrange
    DomainParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new DomainParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextAccept2() {
    // Arrange
    DomainParserGrammar.StereotypeReferenceContext stereotypeReferenceContext = new DomainParserGrammar.StereotypeReferenceContext(
        new ParserRuleContext(), 1);
    stereotypeReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypeReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypeReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(68, (new DomainParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotypeReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testStereotypeReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.StereotypeReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testStereotypes() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypesContext actualStereotypesResult = domainParserGrammar.stereotypes();

    // Assert
    RecognitionException recognitionException = actualStereotypesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualStereotypesResult.invokingState);
    assertNull(actualStereotypesResult.getParent());
    Token expectedStart = actualStereotypesResult.start;
    Token start = actualStereotypesResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualStereotypesResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(484, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualStereotypesResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testStereotypes2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypesContext actualStereotypesResult = domainParserGrammar.stereotypes();

    // Assert
    RecognitionException recognitionException = actualStereotypesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualStereotypesResult.children.size());
    assertNull(actualStereotypesResult.getParent());
    Token expectedStart = actualStereotypesResult.stop;
    Token start = actualStereotypesResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypesResult.getStop());
    assertEquals("null", actualStereotypesResult.getText());
    assertEquals(1, actualStereotypesResult.getChildCount());
    assertTrue(actualStereotypesResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(484, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualStereotypesResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testStereotypes3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(74));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.StereotypesContext actualStereotypesResult = domainParserGrammar.stereotypes();

    // Assert
    RecognitionException recognitionException = actualStereotypesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualStereotypesResult.children.size());
    assertNull(actualStereotypesResult.getParent());
    Token expectedStart = actualStereotypesResult.stop;
    Token start = actualStereotypesResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualStereotypesResult.getStop());
    assertEquals("null", actualStereotypesResult.getText());
    assertEquals(1, actualStereotypesResult.getChildCount());
    assertTrue(actualStereotypesResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(485, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualStereotypesResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testStereotypesContextAccept() {
    // Arrange
    DomainParserGrammar.StereotypesContext stereotypesContext = new DomainParserGrammar.StereotypesContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(stereotypesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypesContextAccept2() {
    // Arrange
    DomainParserGrammar.StereotypesContext stereotypesContext = new DomainParserGrammar.StereotypesContext(
        new ParserRuleContext(), 1);
    stereotypesContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(stereotypesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testStereotypesContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testStereotypesContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).GREATER_THAN().isEmpty());
    assertNull((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).GREATER_THAN(1));
  }

  @Test
  public void testStereotypesContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(22, (new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testStereotypesContextLESS_THAN() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).LESS_THAN().isEmpty());
    assertNull((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).LESS_THAN(1));
  }

  @Test
  public void testStereotypesContextStereotype() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).stereotype().isEmpty());
    assertNull((new DomainParserGrammar.StereotypesContext(new ParserRuleContext(), 1)).stereotype(1));
  }

  @Test
  public void testTagDefinitions() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TagDefinitionsContext actualTagDefinitionsResult = domainParserGrammar.tagDefinitions();

    // Assert
    RecognitionException recognitionException = actualTagDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTagDefinitionsResult.invokingState);
    assertNull(actualTagDefinitionsResult.getParent());
    Token expectedStart = actualTagDefinitionsResult.start;
    Token start = actualTagDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTagDefinitionsResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(468, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTagDefinitionsResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testTagDefinitions2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TagDefinitionsContext actualTagDefinitionsResult = domainParserGrammar.tagDefinitions();

    // Assert
    RecognitionException recognitionException = actualTagDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTagDefinitionsResult.children.size());
    assertNull(actualTagDefinitionsResult.getParent());
    Token expectedStart = actualTagDefinitionsResult.stop;
    Token start = actualTagDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTagDefinitionsResult.getStop());
    assertEquals("null", actualTagDefinitionsResult.getText());
    assertEquals(1, actualTagDefinitionsResult.getChildCount());
    assertTrue(actualTagDefinitionsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(468, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTagDefinitionsResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testTagDefinitions3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(10));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TagDefinitionsContext actualTagDefinitionsResult = domainParserGrammar.tagDefinitions();

    // Assert
    RecognitionException recognitionException = actualTagDefinitionsResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTagDefinitionsResult.children.size());
    assertNull(actualTagDefinitionsResult.getParent());
    Token expectedStart = actualTagDefinitionsResult.stop;
    Token start = actualTagDefinitionsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTagDefinitionsResult.getStop());
    assertEquals("null", actualTagDefinitionsResult.getText());
    assertEquals(1, actualTagDefinitionsResult.getChildCount());
    assertTrue(actualTagDefinitionsResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(469, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTagDefinitionsResult, recognitionException.getCtx());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
  }

  @Test
  public void testTagDefinitionsContextAccept() {
    // Arrange
    DomainParserGrammar.TagDefinitionsContext tagDefinitionsContext = new DomainParserGrammar.TagDefinitionsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(tagDefinitionsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagDefinitionsContextAccept2() {
    // Arrange
    DomainParserGrammar.TagDefinitionsContext tagDefinitionsContext = new DomainParserGrammar.TagDefinitionsContext(
        new ParserRuleContext(), 1);
    tagDefinitionsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(tagDefinitionsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagDefinitionsContextBRACKET_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).BRACKET_CLOSE());
  }

  @Test
  public void testTagDefinitionsContextBRACKET_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).BRACKET_OPEN());
  }

  @Test
  public void testTagDefinitionsContextCOLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).COLON());
  }

  @Test
  public void testTagDefinitionsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTagDefinitionsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(21, (new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTagDefinitionsContextIdentifier() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).identifier().isEmpty());
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).identifier(1));
  }

  @Test
  public void testTagDefinitionsContextSEMI_COLON() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).SEMI_COLON());
  }

  @Test
  public void testTagDefinitionsContextTAGS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagDefinitionsContext(new ParserRuleContext(), 1)).TAGS());
  }

  @Test
  public void testTagReference() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TagReferenceContext actualTagReferenceResult = domainParserGrammar.tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTagReferenceResult.getStop());
    assertEquals(1, actualTagReferenceResult.getChildCount());
    assertTrue(actualTagReferenceResult.isEmpty());
    assertEquals("([] [918])", actualTagReferenceResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(919, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(918, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testTagReference2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TagReferenceContext actualTagReferenceResult = domainParserGrammar.tagReference();

    // Assert
    RecognitionException recognitionException = actualTagReferenceResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.stop;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTagReferenceResult.getStop());
    assertEquals("null", actualTagReferenceResult.getText());
    assertEquals(1, actualTagReferenceResult.getChildCount());
    assertTrue(actualTagReferenceResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(919, recognitionException.getOffendingState());
    assertSame(actualTagReferenceResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(918, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReference3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.TagReferenceContext actualTagReferenceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).tagReference();

    // Assert
    assertEquals(-1, actualTagReferenceResult.invokingState);
    List<ParseTree> parseTreeList = actualTagReferenceResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualTagReferenceResult.getParent());
    Token expectedStart = actualTagReferenceResult.start;
    Token start = actualTagReferenceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualTagReferenceResult.stop;
    Token stop = actualTagReferenceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '%'><EOF>", actualTagReferenceResult.getText());
    assertEquals(3, actualTagReferenceResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualTagReferenceResult.identifier();
    assertEquals(920, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(918, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTagReferenceContextAccept() {
    // Arrange
    DomainParserGrammar.TagReferenceContext tagReferenceContext = new DomainParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextAccept2() {
    // Arrange
    DomainParserGrammar.TagReferenceContext tagReferenceContext = new DomainParserGrammar.TagReferenceContext(
        new ParserRuleContext(), 1);
    tagReferenceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(tagReferenceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTagReferenceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(69, (new DomainParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTagReferenceContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTagReferenceContextPERCENT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).PERCENT());
  }

  @Test
  public void testTagReferenceContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TagReferenceContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTaggedValue() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TaggedValueContext actualTaggedValueResult = domainParserGrammar.taggedValue();

    // Assert
    RecognitionException recognitionException = actualTaggedValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTaggedValueResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTaggedValueResult.getParent());
    Token expectedStart = actualTaggedValueResult.start;
    Token start = actualTaggedValueResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTaggedValueResult.getStop());
    assertEquals(1, actualTaggedValueResult.getChildCount());
    assertTrue(actualTaggedValueResult.isEmpty());
    assertEquals("([] [512])", actualTaggedValueResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTaggedValueResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(513, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(512, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testTaggedValue2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TaggedValueContext actualTaggedValueResult = domainParserGrammar.taggedValue();

    // Assert
    RecognitionException recognitionException = actualTaggedValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTaggedValueResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTaggedValueResult.getParent());
    Token expectedStart = actualTaggedValueResult.stop;
    Token start = actualTaggedValueResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTaggedValueResult.getStop());
    assertEquals("null", actualTaggedValueResult.getText());
    assertEquals(1, actualTaggedValueResult.getChildCount());
    assertTrue(actualTaggedValueResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(513, recognitionException.getOffendingState());
    assertSame(actualTaggedValueResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(512, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTaggedValue3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TaggedValueContext actualTaggedValueResult = domainParserGrammar.taggedValue();

    // Assert
    RecognitionException recognitionException = actualTaggedValueResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTaggedValueResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualTaggedValueResult.getParent());
    Token expectedStart = actualTaggedValueResult.start;
    assertSame(expectedStart, actualTaggedValueResult.getStart());
    Token expectedStop = actualTaggedValueResult.stop;
    Token stop = actualTaggedValueResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '.'><EOF>", actualTaggedValueResult.getText());
    assertEquals(3, actualTaggedValueResult.getChildCount());
    assertTrue(actualTaggedValueResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualTaggedValueResult.identifier();
    assertEquals(514, identifierResult.invokingState);
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(515, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(1, stop.getTokenIndex());
    assertSame(actualTaggedValueResult, recognitionException.getCtx());
    assertEquals(512, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testTaggedValueContextAccept() {
    // Arrange
    DomainParserGrammar.TaggedValueContext taggedValueContext = new DomainParserGrammar.TaggedValueContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(taggedValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTaggedValueContextAccept2() {
    // Arrange
    DomainParserGrammar.TaggedValueContext taggedValueContext = new DomainParserGrammar.TaggedValueContext(
        new ParserRuleContext(), 1);
    taggedValueContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(taggedValueContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTaggedValueContextDOT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).DOT());
  }

  @Test
  public void testTaggedValueContextEQUAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).EQUAL());
  }

  @Test
  public void testTaggedValueContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(25, (new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTaggedValueContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTaggedValueContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTaggedValueContextSTRING() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValueContext(new ParserRuleContext(), 1)).STRING());
  }

  @Test
  public void testTaggedValues() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TaggedValuesContext actualTaggedValuesResult = domainParserGrammar.taggedValues();

    // Assert
    RecognitionException recognitionException = actualTaggedValuesResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTaggedValuesResult.invokingState);
    assertNull(actualTaggedValuesResult.getParent());
    Token expectedStart = actualTaggedValuesResult.start;
    Token start = actualTaggedValuesResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTaggedValuesResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(501, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTaggedValuesResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTaggedValues2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.TaggedValuesContext actualTaggedValuesResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).taggedValues();

    // Assert
    assertEquals(-1, actualTaggedValuesResult.invokingState);
    List<ParseTree> parseTreeList = actualTaggedValuesResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing BRACE_OPEN> ([502] ([512 502] ([1431 512 502] <EOF>))) <missing BRACE_CLOSE>)",
        actualTaggedValuesResult.toStringTree());
    assertNull(actualTaggedValuesResult.getParent());
    Token token = actualTaggedValuesResult.stop;
    Token start = actualTaggedValuesResult.getStart();
    assertSame(token, start);
    assertSame(token, actualTaggedValuesResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF><missing BRACE_CLOSE>", actualTaggedValuesResult.getText());
    assertEquals(3, actualTaggedValuesResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertSame(start, ((DomainParserGrammar.TaggedValueContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing BRACE_CLOSE>", getResult1.getText());
    assertEquals("<missing BRACE_CLOSE>", getResult1.toString());
    assertTrue(
        ((DomainParserGrammar.TaggedValueContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(actualTaggedValuesResult, getResult1.getParent());
    assertSame(start, ((DomainParserGrammar.TaggedValueContext) getResult).getStart());
    assertEquals(502, ((DomainParserGrammar.TaggedValueContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.TaggedValueContext) getResult).depth());
  }

  @Test
  public void testTaggedValuesContextAccept() {
    // Arrange
    DomainParserGrammar.TaggedValuesContext taggedValuesContext = new DomainParserGrammar.TaggedValuesContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(taggedValuesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTaggedValuesContextAccept2() {
    // Arrange
    DomainParserGrammar.TaggedValuesContext taggedValuesContext = new DomainParserGrammar.TaggedValuesContext(
        new ParserRuleContext(), 1);
    taggedValuesContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(taggedValuesContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTaggedValuesContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testTaggedValuesContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testTaggedValuesContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTaggedValuesContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(24, (new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTaggedValuesContextTaggedValue() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).taggedValue().isEmpty());
    assertNull((new DomainParserGrammar.TaggedValuesContext(new ParserRuleContext(), 1)).taggedValue(1));
  }

  @Test
  public void testToMultiplicity() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));

    // Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = domainParserGrammar.toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testToMultiplicity2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = domainParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("null", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1344, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testToMultiplicity3() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = domainParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1344, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getTokenIndex());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
  }

  @Test
  public void testToMultiplicity5() throws RecognitionException {
    // Arrange
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input")));

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = domainParserGrammar.toMultiplicity();

    // Assert
    RecognitionException recognitionException = actualToMultiplicityResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualToMultiplicityResult.children.size());
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.stop;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualToMultiplicityResult.getStop());
    assertEquals("Input", actualToMultiplicityResult.getText());
    assertEquals(1, actualToMultiplicityResult.getChildCount());
    assertTrue(actualToMultiplicityResult.isEmpty());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1344, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("Input", start.getText());
    assertSame(actualToMultiplicityResult, recognitionException.getCtx());
    assertEquals(0, start.getStartIndex());
    assertEquals(1, inputStream.index());
    assertEquals("Input", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(5, ((XPathLexer) ((BufferedTokenStream) inputStream).getTokenSource())._tokenStartCharIndex);
  }

  @Test
  public void testToMultiplicity6() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.ToMultiplicityContext actualToMultiplicityResult = domainParserGrammar.toMultiplicity();

    // Assert
    assertEquals(-1, actualToMultiplicityResult.invokingState);
    assertNull(actualToMultiplicityResult.getParent());
    Token expectedStart = actualToMultiplicityResult.start;
    Token start = actualToMultiplicityResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualToMultiplicityResult.getStop());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, tokenSource.getLine());
    assertNull(domainParserGrammar.getRuleContext());
    assertEquals(-1, domainParserGrammar.getState());
  }

  @Test
  public void testToMultiplicityContextAccept() {
    // Arrange
    DomainParserGrammar.ToMultiplicityContext toMultiplicityContext = new DomainParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextAccept2() {
    // Arrange
    DomainParserGrammar.ToMultiplicityContext toMultiplicityContext = new DomainParserGrammar.ToMultiplicityContext(
        new ParserRuleContext(), 1);
    toMultiplicityContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(toMultiplicityContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testToMultiplicityContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(119, (new DomainParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testToMultiplicityContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testToMultiplicityContextSTAR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.ToMultiplicityContext(new ParserRuleContext(), 1)).STAR());
  }

  @Test
  public void testTreePath() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TreePathContext actualTreePathResult = domainParserGrammar.treePath();

    // Assert
    assertNull(actualTreePathResult.stereotypes());
    RecognitionException recognitionException = actualTreePathResult.exception;
    assertTrue(recognitionException instanceof NoViableAltException);
    assertEquals(1, actualTreePathResult.children.size());
    assertEquals(1, actualTreePathResult.depth());
    assertEquals(-1, actualTreePathResult.invokingState);
    Token expectedStart = actualTreePathResult.start;
    Token start = actualTreePathResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTreePathResult.getStop());
    assertNull(start.getInputStream());
    DomainParserGrammar.TypeContext typeResult = actualTreePathResult.type();
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(698, typeResult.invokingState);
    assertNull(typeResult.getStop());
    assertEquals("[698]", typeResult.toString());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(actualTreePathResult, recognitionException.getCtx());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, ((NoViableAltException) recognitionException).getStartToken());
    assertEquals(706, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
  }

  @Test
  public void testTreePath2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TreePathContext actualTreePathResult = domainParserGrammar.treePath();

    // Assert
    assertNull(actualTreePathResult.stereotypes());
    RecognitionException recognitionException = actualTreePathResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualTreePathResult.children.size());
    assertEquals(1, actualTreePathResult.depth());
    assertEquals(-1, actualTreePathResult.invokingState);
    Token expectedStart = actualTreePathResult.stop;
    Token start = actualTreePathResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTreePathResult.getStop());
    assertEquals("null", actualTreePathResult.getText());
    assertEquals(0, start.getTokenIndex());
    DomainParserGrammar.TypeContext typeResult = actualTreePathResult.type();
    assertEquals(698, typeResult.invokingState);
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(1, typeResult.getChildCount());
    Interval expectedSourceInterval = actualTreePathResult.getSourceInterval();
    assertSame(expectedSourceInterval, typeResult.getSourceInterval());
    assertEquals(700, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualTreePathResult, recognitionException.getCtx());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
  }

  @Test
  public void testTreePathClassBody() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TreePathClassBodyContext actualTreePathClassBodyResult = domainParserGrammar
        .treePathClassBody();

    // Assert
    RecognitionException recognitionException = actualTreePathClassBodyResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTreePathClassBodyResult.invokingState);
    assertNull(actualTreePathClassBodyResult.getParent());
    Token expectedStart = actualTreePathClassBodyResult.start;
    Token start = actualTreePathClassBodyResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTreePathClassBodyResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(710, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTreePathClassBodyResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTreePathClassBody2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.TreePathClassBodyContext actualTreePathClassBodyResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).treePathClassBody();

    // Assert
    assertEquals(-1, actualTreePathClassBodyResult.invokingState);
    List<ParseTree> parseTreeList = actualTreePathClassBodyResult.children;
    assertEquals(3, parseTreeList.size());
    assertEquals("([] <missing BRACE_OPEN> ([715] ([748 715] ([778 748 715] <EOF>))) <missing BRACE_CLOSE>)",
        actualTreePathClassBodyResult.toStringTree());
    assertNull(actualTreePathClassBodyResult.getParent());
    Token token = actualTreePathClassBodyResult.stop;
    Token start = actualTreePathClassBodyResult.getStart();
    assertSame(token, start);
    assertSame(token, actualTreePathClassBodyResult.getStop());
    assertEquals("<missing BRACE_OPEN><EOF><missing BRACE_CLOSE>", actualTreePathClassBodyResult.getText());
    assertEquals(3, actualTreePathClassBodyResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(1, getResult.getChildCount());
    ParseTree getResult1 = parseTreeList.get(2);
    assertEquals("<missing BRACE_CLOSE>", getResult1.getText());
    assertEquals("<missing BRACE_CLOSE>", getResult1.toString());
    assertSame(actualTreePathClassBodyResult, getResult1.getParent());
    assertEquals(2, ((DomainParserGrammar.ComplexPropertyContext) getResult).depth());
    assertEquals(715, ((DomainParserGrammar.ComplexPropertyContext) getResult).invokingState);
    assertSame(start, ((DomainParserGrammar.ComplexPropertyContext) getResult).getStart());
    assertSame(start, ((DomainParserGrammar.ComplexPropertyContext) getResult).getStop());
  }

  @Test
  public void testTreePathClassBodyContextAccept() {
    // Arrange
    DomainParserGrammar.TreePathClassBodyContext treePathClassBodyContext = new DomainParserGrammar.TreePathClassBodyContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(treePathClassBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathClassBodyContextAccept2() {
    // Arrange
    DomainParserGrammar.TreePathClassBodyContext treePathClassBodyContext = new DomainParserGrammar.TreePathClassBodyContext(
        new ParserRuleContext(), 1);
    treePathClassBodyContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(treePathClassBodyContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathClassBodyContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testTreePathClassBodyContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testTreePathClassBodyContextComplexProperty() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).complexProperty().isEmpty());
    assertNull((new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).complexProperty(1));
  }

  @Test
  public void testTreePathClassBodyContextDerivedProperty() {
    // Arrange, Act and Assert
    assertTrue(
        (new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).derivedProperty().isEmpty());
    assertNull((new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).derivedProperty(1));
  }

  @Test
  public void testTreePathClassBodyContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(50, (new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTreePathClassBodyContextSimplePropertyFilter() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathClassBodyContext(new ParserRuleContext(), 1)).simplePropertyFilter());
  }

  @Test
  public void testTreePathContextAccept() {
    // Arrange
    DomainParserGrammar.TreePathContext treePathContext = new DomainParserGrammar.TreePathContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(treePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathContextAccept2() {
    // Arrange
    DomainParserGrammar.TreePathContext treePathContext = new DomainParserGrammar.TreePathContext(
        new ParserRuleContext(), 1);
    treePathContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(treePathContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathContextAlias() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).alias());
  }

  @Test
  public void testTreePathContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(49, (new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTreePathContextStereotypes() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).stereotypes());
  }

  @Test
  public void testTreePathContextTaggedValues() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).taggedValues());
  }

  @Test
  public void testTreePathContextTreePathClassBody() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).treePathClassBody());
  }

  @Test
  public void testTreePathContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testTreePathPropertyParameterType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.TreePathPropertyParameterTypeContext actualTreePathPropertyParameterTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).treePathPropertyParameterType();

    // Assert
    assertEquals(-1, actualTreePathPropertyParameterTypeResult.invokingState);
    assertEquals(2, actualTreePathPropertyParameterTypeResult.children.size());
    assertNull(actualTreePathPropertyParameterTypeResult.getParent());
    Token expectedStart = actualTreePathPropertyParameterTypeResult.start;
    Token start = actualTreePathPropertyParameterTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTreePathPropertyParameterTypeResult.getStop());
    assertEquals(2, actualTreePathPropertyParameterTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualTreePathPropertyParameterTypeResult
        .multiplicity();
    assertEquals(797, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualTreePathPropertyParameterTypeResult.type();
    assertTrue(typeResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(796, typeResult.invokingState);
    assertEquals(2, typeResult.depth());
    assertNull(typeResult.getStop());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getType());
    assertSame(start, multiplicityResult.getStart());
    assertEquals(2, multiplicityResult.depth());
    assertNull(multiplicityResult.getStop());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertNull(start.getInputStream());
  }

  @Test
  public void testTreePathPropertyParameterType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TreePathPropertyParameterTypeContext actualTreePathPropertyParameterTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).treePathPropertyParameterType();

    // Assert
    assertEquals(-1, actualTreePathPropertyParameterTypeResult.invokingState);
    assertEquals(2, actualTreePathPropertyParameterTypeResult.children.size());
    assertNull(actualTreePathPropertyParameterTypeResult.getParent());
    Token token = actualTreePathPropertyParameterTypeResult.stop;
    Token start = actualTreePathPropertyParameterTypeResult.getStart();
    assertSame(token, start);
    assertSame(token, actualTreePathPropertyParameterTypeResult.getStop());
    assertEquals(2, actualTreePathPropertyParameterTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualTreePathPropertyParameterTypeResult
        .multiplicity();
    assertEquals(797, multiplicityResult.invokingState);
    assertSame(start, multiplicityResult.getStop());
    assertEquals("[797]", multiplicityResult.toString());
    assertEquals(0, start.getTokenIndex());
    DomainParserGrammar.TypeContext typeResult = actualTreePathPropertyParameterTypeResult.type();
    assertEquals(1, typeResult.getChildCount());
    assertEquals(796, typeResult.invokingState);
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTreePathPropertyParameterType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.TreePathPropertyParameterTypeContext actualTreePathPropertyParameterTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).treePathPropertyParameterType();

    // Assert
    assertEquals(-1, actualTreePathPropertyParameterTypeResult.invokingState);
    assertEquals(2, actualTreePathPropertyParameterTypeResult.children.size());
    assertNull(actualTreePathPropertyParameterTypeResult.getParent());
    Token expectedStart = actualTreePathPropertyParameterTypeResult.start;
    Token start = actualTreePathPropertyParameterTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualTreePathPropertyParameterTypeResult.stop;
    assertSame(expectedStop, actualTreePathPropertyParameterTypeResult.getStop());
    assertEquals("null<missing '['><EOF><missing ']'>", actualTreePathPropertyParameterTypeResult.getText());
    assertEquals(2, actualTreePathPropertyParameterTypeResult.getChildCount());
    assertEquals(797, actualTreePathPropertyParameterTypeResult.multiplicity().invokingState);
    DomainParserGrammar.TypeContext typeResult = actualTreePathPropertyParameterTypeResult.type();
    assertEquals(796, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testTreePathPropertyParameterType4() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TreePathPropertyParameterTypeContext actualTreePathPropertyParameterTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).treePathPropertyParameterType();

    // Assert
    assertEquals(-1, actualTreePathPropertyParameterTypeResult.invokingState);
    assertEquals(2, actualTreePathPropertyParameterTypeResult.children.size());
    assertNull(actualTreePathPropertyParameterTypeResult.getParent());
    Token expectedStart = actualTreePathPropertyParameterTypeResult.start;
    Token start = actualTreePathPropertyParameterTypeResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualTreePathPropertyParameterTypeResult.stop;
    assertSame(expectedStop, actualTreePathPropertyParameterTypeResult.getStop());
    assertEquals("null<missing '['><EOF>null", actualTreePathPropertyParameterTypeResult.getText());
    assertEquals(2, actualTreePathPropertyParameterTypeResult.getChildCount());
    DomainParserGrammar.MultiplicityContext multiplicityResult = actualTreePathPropertyParameterTypeResult
        .multiplicity();
    assertEquals(797, multiplicityResult.invokingState);
    DomainParserGrammar.TypeContext typeResult = actualTreePathPropertyParameterTypeResult.type();
    assertEquals(796, typeResult.invokingState);
    assertNull(typeResult.type());
    assertEquals("null", typeResult.getText());
    assertSame(start, typeResult.getStart());
    assertEquals(2, typeResult.depth());
    assertSame(start, typeResult.getStop());
    assertTrue(multiplicityResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testTreePathPropertyParameterTypeContextAccept() {
    // Arrange
    DomainParserGrammar.TreePathPropertyParameterTypeContext treePathPropertyParameterTypeContext = new DomainParserGrammar.TreePathPropertyParameterTypeContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(treePathPropertyParameterTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathPropertyParameterTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.TreePathPropertyParameterTypeContext treePathPropertyParameterTypeContext = new DomainParserGrammar.TreePathPropertyParameterTypeContext(
        new ParserRuleContext(), 1);
    treePathPropertyParameterTypeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(treePathPropertyParameterTypeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTreePathPropertyParameterTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(57,
        (new DomainParserGrammar.TreePathPropertyParameterTypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTreePathPropertyParameterTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.TreePathPropertyParameterTypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testTreePathPropertyParameterTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TreePathPropertyParameterTypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testType() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(domainParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1336, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testType2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    assertEquals(-1, actualTypeResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeResult.type());
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.stop;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeResult.getStop());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.QualifiedNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.QualifiedNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.QualifiedNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.QualifiedNameContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.QualifiedNameContext) getResult)
        .identifier();
    assertEquals(1431, identifierResult.invokingState);
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
    assertEquals("[1431 1307]", identifierResult.toString());
  }

  @Test
  public void testType8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(domainParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1336, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testType9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeContext actualTypeResult = domainParserGrammar.type();

    // Assert
    RecognitionException recognitionException = actualTypeResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeResult.invokingState);
    assertNull(actualTypeResult.getParent());
    Token expectedStart = actualTypeResult.start;
    Token start = actualTypeResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeResult.getStop());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    Recognizer<?, ?> recognizer = recognitionException.getRecognizer();
    assertSame(domainParserGrammar, recognizer);
    assertEquals(0, start.getTokenIndex());
    assertSame(actualTypeResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1336, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(listTokenSource1, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, recognizer.getState());
  }

  @Test
  public void testTypeAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = domainParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.start;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1349, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeAndMultiplicityParametersContext actualTypeAndMultiplicityParametersResult = domainParserGrammar
        .typeAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeAndMultiplicityParametersResult.stop;
    Token start = actualTypeAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([1350] ([1369 1350] ([1377 1369 1350] <EOF>))))",
        actualTypeAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(1352, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(1350, ((DomainParserGrammar.TypeParametersContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept() {
    // Arrange
    DomainParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new DomainParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeAndMultiplicityParametersContext typeAndMultiplicityParametersContext = new DomainParserGrammar.TypeAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeAndMultiplicityParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeAndMultiplicityParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(121,
        (new DomainParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1))
        .multiplictyParameters());
  }

  @Test
  public void testTypeAndMultiplicityParametersContextTypeParameters() {
    // Arrange, Act and Assert
    assertNull(
        (new DomainParserGrammar.TypeAndMultiplicityParametersContext(new ParserRuleContext(), 1)).typeParameters());
  }

  @Test
  public void testTypeArguments() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((DomainParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setErrorHandler(new BailErrorStrategy());

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = domainParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = domainParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments7() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = domainParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.stop;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertNull(((DomainParserGrammar.TypeContext) getResult).multiplicity());
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeContext) getResult).getStop());
    List<ParseTree> parseTreeList1 = ((DomainParserGrammar.TypeContext) getResult).children;
    assertEquals(1, parseTreeList1.size());
    ParseTree getResult1 = parseTreeList1.get(0);
    assertEquals("[1307 1409]", getResult1.toString());
    assertEquals(1307, ((DomainParserGrammar.QualifiedNameContext) getResult1).invokingState);
    assertEquals(1, getResult1.getChildCount());
    Interval expectedSourceInterval = actualTypeArgumentsResult.getSourceInterval();
    assertSame(expectedSourceInterval, getResult1.getSourceInterval());
  }

  @Test
  public void testTypeArguments8() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new CommonTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = domainParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((DomainParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArguments9() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    domainParserGrammar.setTokenStream(new BufferedTokenStream(listTokenSource1));

    // Act
    DomainParserGrammar.TypeArgumentsContext actualTypeArgumentsResult = domainParserGrammar.typeArguments();

    // Assert
    assertEquals(-1, actualTypeArgumentsResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeArgumentsResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeArgumentsResult.getParent());
    Token expectedStart = actualTypeArgumentsResult.start;
    Token start = actualTypeArgumentsResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeArgumentsResult.getStop());
    assertEquals(1, actualTypeArgumentsResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(start, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeContext) parseTreeList.get(0)).depth());
    assertFalse(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).isEmpty());
    assertNull(((DomainParserGrammar.TypeContext) parseTreeList.get(0)).getStop());
    assertEquals(0, tokenSource.getCharPositionInLine());
    assertTrue(((DomainParserGrammar.TypeContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testTypeArgumentsContextAccept() {
    // Arrange
    DomainParserGrammar.TypeArgumentsContext typeArgumentsContext = new DomainParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeArgumentsContext typeArgumentsContext = new DomainParserGrammar.TypeArgumentsContext(
        new ParserRuleContext(), 1);
    typeArgumentsContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeArgumentsContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeArgumentsContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeArgumentsContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(129, (new DomainParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeArgumentsContextType() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type().isEmpty());
    assertNull((new DomainParserGrammar.TypeArgumentsContext(new ParserRuleContext(), 1)).type(1));
  }

  @Test
  public void testTypeContextARROW() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).ARROW());
  }

  @Test
  public void testTypeContextAccept() {
    // Arrange
    DomainParserGrammar.TypeContext typeContext = new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeContext typeContext = new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1);
    typeContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeContextBRACE_CLOSE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_CLOSE());
  }

  @Test
  public void testTypeContextBRACE_OPEN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).BRACE_OPEN());
  }

  @Test
  public void testTypeContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeContextFunctionTypePureType() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType().isEmpty());
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).functionTypePureType(1));
  }

  @Test
  public void testTypeContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(116, (new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeContextMultiplicity() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicity());
  }

  @Test
  public void testTypeContextMultiplicityArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).multiplicityArguments());
  }

  @Test
  public void testTypeContextPIPE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).PIPE());
  }

  @Test
  public void testTypeContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testTypeContextType() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).type());
  }

  @Test
  public void testTypeContextTypeArguments() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).typeArguments());
  }

  @Test
  public void testTypeContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testTypeParameter() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.TypeParameterContext actualTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertFalse(identifierResult.isEmpty());
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeParameter2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TypeParameterContext actualTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token token = actualTypeParameterResult.stop;
    assertSame(token, actualTypeParameterResult.getStart());
    Token stop = actualTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testTypeParameter3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.TypeParameterContext actualTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token token = actualTypeParameterResult.stop;
    assertSame(token, actualTypeParameterResult.getStart());
    Token stop = actualTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameter4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.TypeParameterContext actualTypeParameterResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token expectedStart = actualTypeParameterResult.start;
    Token start = actualTypeParameterResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParameterResult.getStop());
    assertEquals(1, actualTypeParameterResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertEquals(2, identifierResult.depth());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1377, identifierResult.invokingState);
    assertNull(identifierResult.getStop());
    assertSame(start, identifierResult.getStart());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
  }

  @Test
  public void testTypeParameter5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeParameterContext actualTypeParameterResult = domainParserGrammar.typeParameter();

    // Assert
    assertEquals(-1, actualTypeParameterResult.invokingState);
    assertEquals(1, actualTypeParameterResult.children.size());
    assertNull(actualTypeParameterResult.getParent());
    Token token = actualTypeParameterResult.stop;
    assertSame(token, actualTypeParameterResult.getStart());
    Token stop = actualTypeParameterResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualTypeParameterResult.getChildCount());
    assertEquals(0, stop.getStartIndex());
    assertNull(stop.getTokenSource());
    assertEquals(0, stop.getChannel());
    assertEquals(1, stop.getType());
    DomainParserGrammar.IdentifierContext identifierResult = actualTypeParameterResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals("Input", stop.getText());
    assertEquals(1, stop.getLine());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(0, stop.getTokenIndex());
    assertEquals(0, stop.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertEquals("Input", getResult.getText());
  }

  @Test
  public void testTypeParameterContextAccept() {
    // Arrange
    DomainParserGrammar.TypeParameterContext typeParameterContext = new DomainParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeParameterContext typeParameterContext = new DomainParserGrammar.TypeParameterContext(
        new ParserRuleContext(), 1);
    typeParameterContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParameterContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParameterContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(124, (new DomainParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParameterContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeParameterContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testTypeParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.TypeParametersContext actualTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertNull(((DomainParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.TypeParameterContext) getResult).children.size());
    assertEquals(1, tokenSource.getLine());
    assertEquals("([1369] [1377 1369])", getResult.toStringTree());
    assertEquals(1377, ((DomainParserGrammar.TypeParameterContext) getResult).identifier().invokingState);
  }

  @Test
  public void testTypeParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.TypeParametersContext actualTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals("null", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.TypeParameterContext) getResult).depth());
    assertFalse(((DomainParserGrammar.TypeParameterContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(1, ((DomainParserGrammar.TypeParameterContext) getResult).children.size());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1377, identifierResult.invokingState);
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    Interval expectedSourceInterval = actualTypeParametersResult.getSourceInterval();
    assertSame(expectedSourceInterval, identifierResult.getSourceInterval());
  }

  @Test
  public void testTypeParameters3() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.TypeParametersContext actualTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(1369, ((DomainParserGrammar.TypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertEquals("Input", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(2, ((DomainParserGrammar.TypeParameterContext) getResult).depth());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStart());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTypeParameters4() throws RecognitionException {
    // Arrange and Act
    DomainParserGrammar.TypeParametersContext actualTypeParametersResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ConnectionLexerGrammar(new ANTLRInputStream())))).typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals("([] ([1369] [1377 1369]))", actualTypeParametersResult.toStringTree());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.start;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersResult.getStop());
    assertEquals("", actualTypeParametersResult.getText());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("<EOF>", start.getText());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource()).getChannel());
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharPositionInLine);
    assertTrue(((ConnectionLexerGrammar) start.getTokenSource())._hitEOF);
    assertNull(((ConnectionLexerGrammar) start.getTokenSource())._text);
    assertEquals(0, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartCharIndex);
    assertEquals(1369, ((DomainParserGrammar.TypeParameterContext) parseTreeList.get(0)).invokingState);
    assertEquals(-1, ((ConnectionLexerGrammar) start.getTokenSource()).getType());
    assertEquals(1, ((ConnectionLexerGrammar) start.getTokenSource())._tokenStartLine);
  }

  @Test
  public void testTypeParameters5() throws RecognitionException {
    // Arrange
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(
        new BufferedTokenStream(new XPathLexer(new ANTLRInputStream("Input"))));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.TypeParametersContext actualTypeParametersResult = domainParserGrammar.typeParameters();

    // Assert
    assertEquals(-1, actualTypeParametersResult.invokingState);
    List<ParseTree> parseTreeList = actualTypeParametersResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualTypeParametersResult.getParent());
    Token expectedStart = actualTypeParametersResult.stop;
    Token start = actualTypeParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersResult.getStop());
    assertEquals(1, actualTypeParametersResult.getChildCount());
    assertEquals(0, start.getStartIndex());
    assertNull(start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(1, start.getType());
    assertEquals("Input", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    ParseTree getResult = parseTreeList.get(0);
    assertEquals(1369, ((DomainParserGrammar.TypeParameterContext) getResult).invokingState);
    assertEquals(1, getResult.getChildCount());
    assertEquals("Input", getResult.getText());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStop());
    assertEquals(2, ((DomainParserGrammar.TypeParameterContext) getResult).depth());
    assertSame(start, ((DomainParserGrammar.TypeParameterContext) getResult).getStart());
    DomainParserGrammar.IdentifierContext identifierResult = ((DomainParserGrammar.TypeParameterContext) getResult)
        .identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertFalse(identifierResult.isEmpty());
    assertSame(start, identifierResult.getStop());
    assertEquals(3, identifierResult.depth());
    assertSame(start, identifierResult.getStart());
  }

  @Test
  public void testTypeParametersContextAccept() {
    // Arrange
    DomainParserGrammar.TypeParametersContext typeParametersContext = new DomainParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeParametersContext typeParametersContext = new DomainParserGrammar.TypeParametersContext(
        new ParserRuleContext(), 1);
    typeParametersContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersContextCOMMA() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA().isEmpty());
    assertNull((new DomainParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).COMMA(1));
  }

  @Test
  public void testTypeParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(123, (new DomainParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersContextTypeParameter() {
    // Arrange, Act and Assert
    assertTrue((new DomainParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter().isEmpty());
    assertNull((new DomainParserGrammar.TypeParametersContext(new ParserRuleContext(), 1)).typeParameter(1));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = domainParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.invokingState);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.start;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1359, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParameters2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));
    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext actualTypeParametersWithContravarianceAndMultiplicityParametersResult = domainParserGrammar
        .typeParametersWithContravarianceAndMultiplicityParameters();

    // Assert
    RecognitionException recognitionException = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getParent());
    Token expectedStart = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.stop;
    Token start = actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getStop());
    assertEquals("<missing '<'><EOF>", actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getText());
    assertEquals(2, actualTypeParametersWithContravarianceAndMultiplicityParametersResult.getChildCount());
    assertTrue(actualTypeParametersWithContravarianceAndMultiplicityParametersResult.isEmpty());
    assertEquals("([] <missing '<'> ([1360] ([1379 1360] ([1390 1379 1360] <EOF>))))",
        actualTypeParametersWithContravarianceAndMultiplicityParametersResult.toStringTree());
    assertEquals(0, start.getTokenIndex());
    Token offendingToken = recognitionException.getOffendingToken();
    assertTrue(offendingToken instanceof CommonToken);
    assertEquals(1362, recognitionException.getOffendingState());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(actualTypeParametersWithContravarianceAndMultiplicityParametersResult, recognitionException.getCtx());
    assertSame(listTokenSource, offendingToken.getTokenSource());
    assertEquals(-1, offendingToken.getType());
    assertEquals(0, offendingToken.getChannel());
    assertEquals(2, offendingToken.getStartIndex());
    assertEquals(1, offendingToken.getStopIndex());
    assertEquals(1360, ((DomainParserGrammar.ContravarianceTypeParametersContext) parseTreeList.get(1)).invokingState);
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept() {
    // Arrange
    DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextAccept2() {
    // Arrange
    DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext typeParametersWithContravarianceAndMultiplicityParametersContext = new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1);
    typeParametersWithContravarianceAndMultiplicityParametersContext
        .<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(typeParametersWithContravarianceAndMultiplicityParametersContext
        .<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextContravarianceTypeParameters() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).contravarianceTypeParameters());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGREATER_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).GREATER_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(122, (new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextLESS_THAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).LESS_THAN());
  }

  @Test
  public void testTypeParametersWithContravarianceAndMultiplicityParametersContextMultiplictyParameters() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.TypeParametersWithContravarianceAndMultiplicityParametersContext(
        new ParserRuleContext(), 1)).multiplictyParameters());
  }

  @Test
  public void testUnitExpr() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitExprContext actualUnitExprResult = domainParserGrammar.unitExpr();

    // Assert
    RecognitionException recognitionException = actualUnitExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualUnitExprResult.children.size());
    assertNull(actualUnitExprResult.getParent());
    Token expectedStart = actualUnitExprResult.start;
    Token start = actualUnitExprResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitExprResult.getStop());
    assertEquals(1, actualUnitExprResult.getChildCount());
    assertTrue(actualUnitExprResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualUnitExprResult.identifier();
    assertEquals(584, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertNull(identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(-1, start.getStopIndex());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(585, recognitionException.getOffendingState());
    assertSame(actualUnitExprResult, recognitionException.getCtx());
    assertEquals(-1, start.getStartIndex());
    assertNull(start.getInputStream());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertTrue(identifierResult.exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(0, start.getCharPositionInLine());
    assertEquals(1, start.getLine());
  }

  @Test
  public void testUnitExpr2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitExprContext actualUnitExprResult = domainParserGrammar.unitExpr();

    // Assert
    RecognitionException recognitionException = actualUnitExprResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualUnitExprResult.children.size());
    assertNull(actualUnitExprResult.getParent());
    Token expectedStart = actualUnitExprResult.stop;
    Token start = actualUnitExprResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitExprResult.getStop());
    assertEquals("null", actualUnitExprResult.getText());
    assertEquals(1, actualUnitExprResult.getChildCount());
    assertTrue(actualUnitExprResult.isEmpty());
    DomainParserGrammar.IdentifierContext identifierResult = actualUnitExprResult.identifier();
    assertEquals(584, identifierResult.invokingState);
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(585, recognitionException.getOffendingState());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertSame(actualUnitExprResult, recognitionException.getCtx());
    assertEquals(0, start.getTokenIndex());
  }

  @Test
  public void testUnitExpr3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.UnitExprContext actualUnitExprResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitExpr();

    // Assert
    assertEquals(-1, actualUnitExprResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitExprResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualUnitExprResult.getParent());
    Token expectedStart = actualUnitExprResult.start;
    Token start = actualUnitExprResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitExprResult.stop;
    Token stop = actualUnitExprResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '->'><EOF>", actualUnitExprResult.getText());
    assertEquals(3, actualUnitExprResult.getChildCount());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    DomainParserGrammar.IdentifierContext identifierResult = actualUnitExprResult.identifier();
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(584, identifierResult.invokingState);
    assertEquals("null", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(0, start.getTokenIndex());
    assertEquals(586, ((DomainParserGrammar.CodeBlockContext) parseTreeList.get(2)).invokingState);
  }

  @Test
  public void testUnitExprContextARROW() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitExprContext(new ParserRuleContext(), 1)).ARROW());
  }

  @Test
  public void testUnitExprContextAccept() {
    // Arrange
    DomainParserGrammar.UnitExprContext unitExprContext = new DomainParserGrammar.UnitExprContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitExprContextAccept2() {
    // Arrange
    DomainParserGrammar.UnitExprContext unitExprContext = new DomainParserGrammar.UnitExprContext(
        new ParserRuleContext(), 1);
    unitExprContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitExprContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitExprContextCodeBlock() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitExprContext(new ParserRuleContext(), 1)).codeBlock());
  }

  @Test
  public void testUnitExprContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(33, (new DomainParserGrammar.UnitExprContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitExprContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitExprContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testUnitInstance() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());

    // Act
    DomainParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceResult.getStop());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(-1, start.getStartIndex());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(1, start.getLine());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertEquals(0, start.getTokenIndex());
    assertNull(start.getInputStream());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(871, ((DomainParserGrammar.UnitNameContext) getResult).invokingState);
    assertEquals("([871] [873 871])", getResult.toStringTree());
    assertNull(((DomainParserGrammar.UnitNameContext) getResult).identifier());
    assertSame(start, ((DomainParserGrammar.UnitNameContext) getResult).getStart());
    assertEquals(2, ((DomainParserGrammar.UnitNameContext) getResult).depth());
    assertNull(((DomainParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(1, tokenSource.getLine());
    ParseTree getResult1 = parseTreeList.get(0);
    assertEquals(870, ((DomainParserGrammar.UnitInstanceLiteralContext) getResult1).invokingState);
    assertTrue(
        ((DomainParserGrammar.UnitNameContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("[870]", getResult1.toString());
    assertTrue(
        ((DomainParserGrammar.UnitInstanceLiteralContext) getResult1).exception instanceof org.antlr.v4.runtime.InputMismatchException);
  }

  @Test
  public void testUnitInstance2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.stop;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceResult.getStop());
    assertEquals("null", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    ParseTree getResult = parseTreeList.get(1);
    assertEquals(2, ((DomainParserGrammar.UnitNameContext) getResult).depth());
    assertFalse(((DomainParserGrammar.UnitNameContext) getResult).isEmpty());
    assertSame(start, ((DomainParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(1, getResult.getChildCount());
    assertEquals(870, ((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    assertSame(start, ((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStart());
    assertEquals(2, ((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).depth());
    assertNull(((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).getStop());
    assertTrue(((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertTrue(
        ((DomainParserGrammar.UnitNameContext) getResult).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertSame(start, ((DomainParserGrammar.UnitNameContext) getResult).getStart());
  }

  @Test
  public void testUnitInstance3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.UnitInstanceContext actualUnitInstanceResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitInstance();

    // Assert
    assertEquals(-1, actualUnitInstanceResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitInstanceResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualUnitInstanceResult.getParent());
    Token expectedStart = actualUnitInstanceResult.start;
    Token start = actualUnitInstanceResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitInstanceResult.stop;
    Token stop = actualUnitInstanceResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitInstanceResult.getText());
    assertEquals(2, actualUnitInstanceResult.getChildCount());
    assertEquals(1, stop.getTokenIndex());
    assertEquals(0, start.getTokenIndex());
    assertTrue(((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(870, ((DomainParserGrammar.UnitInstanceLiteralContext) parseTreeList.get(0)).invokingState);
    ParseTree getResult = parseTreeList.get(1);
    assertSame(stop, ((DomainParserGrammar.UnitNameContext) getResult).getStop());
    assertEquals(3, getResult.getChildCount());
    assertEquals(871, ((DomainParserGrammar.UnitNameContext) getResult).invokingState);
    assertEquals(2, ((DomainParserGrammar.UnitNameContext) getResult).depth());
  }

  @Test
  public void testUnitInstanceContextAccept() {
    // Arrange
    DomainParserGrammar.UnitInstanceContext unitInstanceContext = new DomainParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextAccept2() {
    // Arrange
    DomainParserGrammar.UnitInstanceContext unitInstanceContext = new DomainParserGrammar.UnitInstanceContext(
        new ParserRuleContext(), 1);
    unitInstanceContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(60, (new DomainParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitInstanceContextUnitInstanceLiteral() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).unitInstanceLiteral());
  }

  @Test
  public void testUnitInstanceContextUnitName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceContext(new ParserRuleContext(), 1)).unitName());
  }

  @Test
  public void testUnitInstanceLiteral() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = domainParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualUnitInstanceLiteralResult.invokingState);
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.start;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitInstanceLiteralResult.getStop());
    assertEquals(-1, start.getStopIndex());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1232, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertNull(start.getInputStream());
    assertEquals(1, tokenSource.getLine());
  }

  @Test
  public void testUnitInstanceLiteral2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitInstanceLiteralContext actualUnitInstanceLiteralResult = domainParserGrammar
        .unitInstanceLiteral();

    // Assert
    RecognitionException recognitionException = actualUnitInstanceLiteralResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(1, actualUnitInstanceLiteralResult.children.size());
    assertNull(actualUnitInstanceLiteralResult.getParent());
    Token expectedStart = actualUnitInstanceLiteralResult.stop;
    Token start = actualUnitInstanceLiteralResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitInstanceLiteralResult.getStop());
    assertEquals("null", actualUnitInstanceLiteralResult.getText());
    assertEquals(1, actualUnitInstanceLiteralResult.getChildCount());
    assertTrue(actualUnitInstanceLiteralResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertEquals(1232, recognitionException.getOffendingState());
    assertSame(start, recognitionException.getOffendingToken());
    assertSame(actualUnitInstanceLiteralResult, recognitionException.getCtx());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.index());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
  }

  @Test
  public void testUnitInstanceLiteralContextAccept() {
    // Arrange
    DomainParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new DomainParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextAccept2() {
    // Arrange
    DomainParserGrammar.UnitInstanceLiteralContext unitInstanceLiteralContext = new DomainParserGrammar.UnitInstanceLiteralContext(
        new ParserRuleContext(), 1);
    unitInstanceLiteralContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitInstanceLiteralContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitInstanceLiteralContextDECIMAL() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).DECIMAL());
  }

  @Test
  public void testUnitInstanceLiteralContextFLOAT() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).FLOAT());
  }

  @Test
  public void testUnitInstanceLiteralContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(108, (new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitInstanceLiteralContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testUnitInstanceLiteralContextMINUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).MINUS());
  }

  @Test
  public void testUnitInstanceLiteralContextPLUS() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitInstanceLiteralContext(new ParserRuleContext(), 1)).PLUS());
  }

  @Test
  public void testUnitName() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitNameContext actualUnitNameResult = domainParserGrammar.unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualUnitNameResult.getStop());
    assertEquals(1, actualUnitNameResult.getChildCount());
    assertTrue(actualUnitNameResult.isEmpty());
    assertEquals("([] [873])", actualUnitNameResult.toStringTree());
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(874, recognitionException.getOffendingState());
    assertEquals(1, start.getLine());
    assertSame(listTokenSource, start.getTokenSource());
    assertEquals(0, start.getCharPositionInLine());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStopIndex());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals(1, inputStream.size());
    assertEquals(873, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
    assertTrue(((DomainParserGrammar.QualifiedNameContext) parseTreeList
        .get(0)).exception instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals("", ((BufferedTokenStream) inputStream).getText());
  }

  @Test
  public void testUnitName2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(new ListTokenSource(tokenList));
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.UnitNameContext actualUnitNameResult = domainParserGrammar.unitName();

    // Assert
    RecognitionException recognitionException = actualUnitNameResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(1, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.stop;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    assertSame(start, actualUnitNameResult.getStop());
    assertEquals("null", actualUnitNameResult.getText());
    assertEquals(1, actualUnitNameResult.getChildCount());
    assertTrue(actualUnitNameResult.isEmpty());
    IntStream inputStream = recognitionException.getInputStream();
    assertSame(bufferedTokenStream, inputStream);
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertEquals(0, start.getTokenIndex());
    assertTrue(recognitionException.getOffendingToken() instanceof CommonToken);
    assertEquals(874, recognitionException.getOffendingState());
    assertSame(actualUnitNameResult, recognitionException.getCtx());
    assertEquals(1, inputStream.index());
    assertEquals("List", inputStream.getSourceName());
    assertEquals("null", ((BufferedTokenStream) inputStream).getText());
    assertEquals(2, inputStream.size());
    assertEquals(873, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitName3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.UnitNameContext actualUnitNameResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).unitName();

    // Assert
    assertEquals(-1, actualUnitNameResult.invokingState);
    List<ParseTree> parseTreeList = actualUnitNameResult.children;
    assertEquals(3, parseTreeList.size());
    assertNull(actualUnitNameResult.getParent());
    Token expectedStart = actualUnitNameResult.start;
    Token start = actualUnitNameResult.getStart();
    assertSame(expectedStart, start);
    Token expectedStop = actualUnitNameResult.stop;
    Token stop = actualUnitNameResult.getStop();
    assertSame(expectedStop, stop);
    assertEquals("null<missing '~'><EOF>", actualUnitNameResult.getText());
    assertEquals(3, actualUnitNameResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualUnitNameResult.identifier();
    assertEquals(875, identifierResult.invokingState);
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(stop, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertEquals(0, start.getTokenIndex());
    assertEquals("[@1,1:1='<EOF>',<1>,channel=1,1:0]", stop.toString());
    assertEquals(873, ((DomainParserGrammar.QualifiedNameContext) parseTreeList.get(0)).invokingState);
  }

  @Test
  public void testUnitNameContextAccept() {
    // Arrange
    DomainParserGrammar.UnitNameContext unitNameContext = new DomainParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextAccept2() {
    // Arrange
    DomainParserGrammar.UnitNameContext unitNameContext = new DomainParserGrammar.UnitNameContext(
        new ParserRuleContext(), 1);
    unitNameContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(unitNameContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testUnitNameContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(61, (new DomainParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testUnitNameContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testUnitNameContextQualifiedName() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).qualifiedName());
  }

  @Test
  public void testUnitNameContextTILDE() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.UnitNameContext(new ParserRuleContext(), 1)).TILDE());
  }

  @Test
  public void testVariable() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.VariableContext actualVariableResult = domainParserGrammar.variable();

    // Assert
    RecognitionException recognitionException = actualVariableResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualVariableResult.invokingState);
    assertNull(actualVariableResult.getParent());
    Token expectedStart = actualVariableResult.start;
    Token start = actualVariableResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualVariableResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1067, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualVariableResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testVariable2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    ListTokenSource a = new ListTokenSource(new ArrayList<Token>());
    tokenList.add(new CommonToken(new Pair<TokenSource, CharStream>(a, new ANTLRInputStream()), 1, 1, 1, 1));

    // Act
    DomainParserGrammar.VariableContext actualVariableResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).variable();

    // Assert
    assertEquals(-1, actualVariableResult.invokingState);
    List<ParseTree> parseTreeList = actualVariableResult.children;
    assertEquals(2, parseTreeList.size());
    assertNull(actualVariableResult.getParent());
    Token token = actualVariableResult.stop;
    Token start = actualVariableResult.getStart();
    assertSame(token, start);
    assertSame(token, actualVariableResult.getStop());
    assertEquals("<missing '$'><EOF>", actualVariableResult.getText());
    assertEquals(2, actualVariableResult.getChildCount());
    DomainParserGrammar.IdentifierContext identifierResult = actualVariableResult.identifier();
    assertEquals(1068, identifierResult.invokingState);
    assertEquals(1, identifierResult.children.size());
    assertEquals(0, start.getTokenIndex());
    assertEquals("<EOF>", identifierResult.getText());
    assertSame(start, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertSame(start, identifierResult.getStop());
    assertEquals(1, identifierResult.getChildCount());
    assertSame(actualVariableResult, parseTreeList.get(0).getParent());
  }

  @Test
  public void testVariableContextAccept() {
    // Arrange
    DomainParserGrammar.VariableContext variableContext = new DomainParserGrammar.VariableContext(
        new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextAccept2() {
    // Arrange
    DomainParserGrammar.VariableContext variableContext = new DomainParserGrammar.VariableContext(
        new ParserRuleContext(), 1);
    variableContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(variableContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testVariableContextDOLLAR() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.VariableContext(new ParserRuleContext(), 1)).DOLLAR());
  }

  @Test
  public void testVariableContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(89, (new DomainParserGrammar.VariableContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testVariableContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.VariableContext(new ParserRuleContext(), 1)).identifier());
  }

  @Test
  public void testWord() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource);
    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(bufferedTokenStream);

    // Act
    DomainParserGrammar.WordContext actualWordResult = domainParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1444, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord2() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));

    // Act
    DomainParserGrammar.WordContext actualWordResult = (new DomainParserGrammar(
        new BufferedTokenStream(new ListTokenSource(tokenList)))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord3() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.WordContext actualWordResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord4() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setType(0);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    // Act
    DomainParserGrammar.WordContext actualWordResult = (new DomainParserGrammar(
        new BufferedTokenStream(listTokenSource))).word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord5() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setBuildParseTree(true);

    // Act
    DomainParserGrammar.WordContext actualWordResult = domainParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord6() throws RecognitionException {
    // Arrange
    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(new CommonToken(1));
    tokenList.add(new CommonToken(1));

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.WordContext actualWordResult = domainParserGrammar.word();

    // Assert
    assertEquals(-1, actualWordResult.invokingState);
    assertEquals(1, actualWordResult.children.size());
    assertNull(actualWordResult.getParent());
    Token token = actualWordResult.stop;
    assertSame(token, actualWordResult.getStart());
    Token stop = actualWordResult.getStop();
    assertSame(token, stop);
    assertEquals(1, actualWordResult.getChildCount());
    assertEquals(0, stop.getTokenIndex());
    DomainParserGrammar.IdentifierContext identifierResult = actualWordResult.identifier();
    assertSame(stop, identifierResult.getStart());
    assertEquals(2, identifierResult.depth());
    assertFalse(identifierResult.isEmpty());
    assertSame(stop, identifierResult.getStop());
    List<ParseTree> parseTreeList = identifierResult.children;
    assertEquals(1, parseTreeList.size());
    assertEquals(1, identifierResult.getChildCount());
    ParseTree getResult = parseTreeList.get(0);
    assertSame(identifierResult, getResult.getParent());
    assertNull(getResult.getText());
  }

  @Test
  public void testWord7() throws RecognitionException {
    // Arrange
    ListTokenSource listTokenSource = new ListTokenSource(new ArrayList<Token>());
    CommonTokenStream commonTokenStream = new CommonTokenStream(listTokenSource);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(commonTokenStream);
    domainParserGrammar.setTrace(true);

    // Act
    DomainParserGrammar.WordContext actualWordResult = domainParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1444, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(commonTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWord8() throws RecognitionException {
    // Arrange
    CommonToken commonToken = new CommonToken(1);
    commonToken.setLine(2);

    ArrayList<Token> tokenList = new ArrayList<Token>();
    tokenList.add(commonToken);

    ListTokenSource listTokenSource = new ListTokenSource(tokenList);
    listTokenSource.setTokenFactory(null);

    DomainParserGrammar domainParserGrammar = new DomainParserGrammar(new BufferedTokenStream(listTokenSource));
    ListTokenSource listTokenSource1 = new ListTokenSource(new ArrayList<Token>());
    BufferedTokenStream bufferedTokenStream = new BufferedTokenStream(listTokenSource1);
    domainParserGrammar.setTokenStream(bufferedTokenStream);

    // Act
    DomainParserGrammar.WordContext actualWordResult = domainParserGrammar.word();

    // Assert
    RecognitionException recognitionException = actualWordResult.exception;
    assertTrue(recognitionException instanceof org.antlr.v4.runtime.InputMismatchException);
    assertEquals(-1, actualWordResult.invokingState);
    assertNull(actualWordResult.getParent());
    Token expectedStart = actualWordResult.start;
    Token start = actualWordResult.getStart();
    assertSame(expectedStart, start);
    assertNull(actualWordResult.getStop());
    TokenSource tokenSource = start.getTokenSource();
    assertSame(listTokenSource1, tokenSource);
    assertEquals(0, start.getChannel());
    assertEquals(-1, start.getType());
    assertEquals(0, start.getTokenIndex());
    assertSame(start, recognitionException.getOffendingToken());
    assertEquals(1444, recognitionException.getOffendingState());
    assertSame(domainParserGrammar, recognitionException.getRecognizer());
    assertSame(bufferedTokenStream, recognitionException.getInputStream());
    assertEquals(1, start.getLine());
    assertEquals(-1, start.getStopIndex());
    assertEquals(0, start.getCharPositionInLine());
    assertSame(actualWordResult, recognitionException.getCtx());
    assertEquals("EOF", start.getText());
    assertNull(start.getInputStream());
    assertEquals(-1, start.getStartIndex());
    assertEquals(0, tokenSource.getCharPositionInLine());
  }

  @Test
  public void testWordContextAccept() {
    // Arrange
    DomainParserGrammar.WordContext wordContext = new DomainParserGrammar.WordContext(new ParserRuleContext(), 1);

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextAccept2() {
    // Arrange
    DomainParserGrammar.WordContext wordContext = new DomainParserGrammar.WordContext(new ParserRuleContext(), 1);
    wordContext.<ParseTree>addAnyChild(new InterpreterRuleContext());

    // Act and Assert
    assertNull(wordContext.<Object>accept(new CodeParserGrammarBaseVisitor<Object>()));
  }

  @Test
  public void testWordContextBOOLEAN() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.WordContext(new ParserRuleContext(), 1)).BOOLEAN());
  }

  @Test
  public void testWordContextGetRuleIndex() {
    // Arrange, Act and Assert
    assertEquals(133, (new DomainParserGrammar.WordContext(new ParserRuleContext(), 1)).getRuleIndex());
  }

  @Test
  public void testWordContextINTEGER() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.WordContext(new ParserRuleContext(), 1)).INTEGER());
  }

  @Test
  public void testWordContextIdentifier() {
    // Arrange, Act and Assert
    assertNull((new DomainParserGrammar.WordContext(new ParserRuleContext(), 1)).identifier());
  }
}

